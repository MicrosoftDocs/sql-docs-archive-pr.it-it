---
title: Linee guida per i livelli di isolamento delle transazioni con tabelle con ottimizzazione per la memoria | Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: e365e9ca-c34b-44ae-840c-10e599fa614f
author: stevestein
ms.author: sstein
ms.openlocfilehash: 834c5950a8f8b0ddf8854d06c6fb1073a264fc22
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/04/2020
ms.locfileid: "87716599"
---
# <a name="guidelines-for-transaction-isolation-levels-with-memory-optimized-tables"></a><span data-ttu-id="fcd1f-102">Linee guida per i livelli di isolamento delle transazioni con tabelle con ottimizzazione per la memoria</span><span class="sxs-lookup"><span data-stu-id="fcd1f-102">Guidelines for Transaction Isolation Levels with Memory-Optimized Tables</span></span>
  <span data-ttu-id="fcd1f-103">In molti scenari è necessario specificare il livello di isolamento.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-103">In many scenarios, you must specify the transaction isolation level.</span></span> <span data-ttu-id="fcd1f-104">L'isolamento delle transazioni per le tabelle ottimizzate per la memoria è diverso dalle tabelle basate su disco.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-104">Transaction isolation for memory-optimized tables differs from disk-based tables.</span></span>  
  
 <span data-ttu-id="fcd1f-105">Requisiti per specificare il livello di isolamento:</span><span class="sxs-lookup"><span data-stu-id="fcd1f-105">Requirements for specifying transaction isolation level:</span></span>  
  
-   <span data-ttu-id="fcd1f-106">TRANSACTION ISOLATION LEVEL è un'opzione obbligatoria per il blocco ATOMIC che include il contenuto di una stored procedure compilata in modo nativo.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-106">TRANSACTION ISOLATION LEVEL is a required option for the ATOMIC block comprising the content of a natively compiled stored procedure.</span></span>  
  
-   <span data-ttu-id="fcd1f-107">A causa delle restrizioni sull'utilizzo del livello di isolamento nelle transazioni tra contenitori, l'utilizzo di tabelle ottimizzate per la memoria in codice [!INCLUDE[tsql](../includes/tsql-md.md)] interpretato deve essere spesso accompagnato da un hint di tabella che specifica il livello di isolamento utilizzato per accedere alla tabella.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-107">Because of restrictions on isolation level use in cross-container transactions, uses of memory-optimized tables in interpreted [!INCLUDE[tsql](../includes/tsql-md.md)] must often be accompanied by a table hint specifying the isolation level used to access the table.</span></span> <span data-ttu-id="fcd1f-108">Per ulteriori informazioni sugli hint del livello di isolamento e sulle transazioni tra contenitori, vedere [livelli di isolamento delle transazioni](../../2014/database-engine/transaction-isolation-levels.md).</span><span class="sxs-lookup"><span data-stu-id="fcd1f-108">For more information about isolation level hints and cross-container transactions, see [Transaction Isolation Levels](../../2014/database-engine/transaction-isolation-levels.md).</span></span>  
  
-   <span data-ttu-id="fcd1f-109">Il livello di isolamento delle transazioni desiderato deve essere dichiarato in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-109">The desired transaction isolation level must be explicitly declared.</span></span> <span data-ttu-id="fcd1f-110">Non è possibile utilizzare hint di blocco (ad esempio XLOCK) per garantire l'isolamento di determinate righe o tabelle nella transazione.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-110">It is not possible to use locking hints (such as XLOCK) to guarantee the isolation of certain rows or tables in the transaction.</span></span>  
  
-   <span data-ttu-id="fcd1f-111">Per l'applicazione che accede al database deve essere implementata la logica di riesecuzione per gestire gli errori risultanti da conflitti alla fine della transazione, gli errori di convalida e gli errori di dipendenza di commit.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-111">The application accessing the database should implement retry logic to deal with errors resulting from transaction-dooming conflicts, validation failures, and commit-dependency failures.</span></span> <span data-ttu-id="fcd1f-112">Si noti che gli errori di dipendenza di commit possono verificarsi anche con transazioni di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-112">Note that commit dependency failures can occur even with read-only transactions.</span></span>  
  
-   <span data-ttu-id="fcd1f-113">Con le tabelle ottimizzate per la memoria è opportuno evitare transazioni con esecuzione prolungata.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-113">Long-running transactions should be avoided with memory-optimized tables.</span></span> <span data-ttu-id="fcd1f-114">Tali transazioni aumentano la probabilità di conflitti e la conseguente interruzione della transazione.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-114">Such transactions increase the likelihood of conflicts and subsequent transaction terminations.</span></span> <span data-ttu-id="fcd1f-115">Una transazione con esecuzione prolungata può posticipare il processo di Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-115">A long-running transaction also defers garbage collection.</span></span> <span data-ttu-id="fcd1f-116">Più lunga è l'esecuzione di una transazione, più a lungo OLTP in memoria mantiene le versioni delle righe eliminate di recente; questo può ridurre le prestazioni di ricerca di nuove transazioni.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-116">The longer a transaction runs, the longer In-Memory OLTP keeps recently deleted row versions, which can decrease lookup performance for new transactions.</span></span>  
  
 <span data-ttu-id="fcd1f-117">Le tabelle basate su disco in genere si basano sul blocco per l'isolamento delle transazioni.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-117">Disk-based tables typically rely on locking and blocking for transaction isolation.</span></span> <span data-ttu-id="fcd1f-118">Le tabelle con ottimizzazione per la memoria si basano sul controllo di più versioni e sul rilevamento dei conflitti per garantire l'isolamento.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-118">Memory-optimized tables rely on multi-versioning and conflict detection to guarantee isolation.</span></span> <span data-ttu-id="fcd1f-119">Per informazioni dettagliate, vedere la sezione relativa ai controlli di rilevamento dei conflitti, convalida e dipendenza di commit nelle [transazioni nelle tabelle ottimizzate](../relational-databases/in-memory-oltp/memory-optimized-tables.md)per la memoria.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-119">For details, see the section on Conflict Detection, Validation, and Commit Dependency Checks in [Transactions in Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).</span></span>  
  
 <span data-ttu-id="fcd1f-120">Le tabelle basate su disco consentono il controllo di più versioni con i livelli di isolamento SNAPSHOT e READ_COMMITTED_SNAPSHOT.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-120">Disk-based tables do allow multi-versioning with the isolation levels SNAPSHOT and READ_COMMITTED_SNAPSHOT.</span></span> <span data-ttu-id="fcd1f-121">Per le tabelle ottimizzate per la memoria tutti i livelli di isolamento sono basati su più versioni, inclusi REPEATABLE READ e SERIALIZABLE.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-121">For memory-optimized tables all isolation levels are multi-version based, including REPEATABLE READ and SERIALIZABLE.</span></span>  
  
## <a name="types-of-transactions"></a><span data-ttu-id="fcd1f-122">Tipi di transazioni</span><span class="sxs-lookup"><span data-stu-id="fcd1f-122">Types of Transactions</span></span>  
 <span data-ttu-id="fcd1f-123">Ogni query in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] viene eseguita nel contesto di una transazione.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-123">Every query in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] runs in the context of a transaction.</span></span>  
  
 <span data-ttu-id="fcd1f-124">Sono disponibili tre tipi di transazioni in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]:</span><span class="sxs-lookup"><span data-stu-id="fcd1f-124">There are three types of transactions in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]:</span></span>  
  
-   <span data-ttu-id="fcd1f-125">Transazioni con autocommit.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-125">Autocommit transactions.</span></span> <span data-ttu-id="fcd1f-126">Se non esiste un contesto di transazione attiva e le transazioni implicite non sono impostate su ON nella sessione, ogni query dispone del proprio contesto di transazione.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-126">If there is no active transaction context and implicit transactions are not set to ON in the session, each query has its own transaction context.</span></span> <span data-ttu-id="fcd1f-127">La transazione viene avviata quando l'istruzione avvia l'esecuzione e viene completata quando termina l'istruzione.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-127">The transaction starts when the statement starts execution, and completes when the statement finishes.</span></span>  
  
-   <span data-ttu-id="fcd1f-128">Transazioni esplicite.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-128">Explicit transactions.</span></span> <span data-ttu-id="fcd1f-129">L'utente avvia la transazione tramite un'istruzione esplicita BEGIN TRAN o BEGIN ATOMIC.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-129">The user starts the transaction through an explicit BEGIN TRAN or BEGIN ATOMIC.</span></span> <span data-ttu-id="fcd1f-130">La transazione viene completata in base alle corrispondenti istruzioni COMMIT e ROLLBACK o END (nel caso di un blocco atomic).</span><span class="sxs-lookup"><span data-stu-id="fcd1f-130">The transaction is completed following the corresponding COMMIT and ROLLBACK or END (in the case of an atomic block).</span></span>  
  
-   <span data-ttu-id="fcd1f-131">Transazioni implicite.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-131">Implicit transactions.</span></span> <span data-ttu-id="fcd1f-132">Quando l'opzione SET IMPLICIT_TRANSACTIONS è impostata su ON, viene avviata implicitamente una transazione ogni volta che l'utente esegue un'istruzione e non è presente alcun contesto di transazione attiva.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-132">When the option IMPLICIT_TRANSACTIONS is set to ON, a transaction is started implicitly whenever the user executes a statement and there is no active transaction context.</span></span> <span data-ttu-id="fcd1f-133">La transazione viene completata tramite istruzioni COMMIT e ROLLBACK esplicite.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-133">The transaction is completed through an explicit COMMIT and ROLLBACK.</span></span>  
  
## <a name="baseline-read-committed-isolation"></a><span data-ttu-id="fcd1f-134">Isolamento READ COMMITTED di base</span><span class="sxs-lookup"><span data-stu-id="fcd1f-134">Baseline READ COMMITTED Isolation</span></span>  
 <span data-ttu-id="fcd1f-135">READ COMMITTED è il livello di isolamento predefinito in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="fcd1f-135">READ COMMITTED is the default isolation level in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span>  
  
 <span data-ttu-id="fcd1f-136">Il livello di isolamento READ COMMITTED garantisce che le transazioni non possano visualizzare dati di cui non è stato eseguito il commit a seguito delle modifiche all'esterno della transazione corrente.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-136">The isolation level READ COMMITTED guarantees that transactions do not see any uncommitted data from changes outside the current transaction.</span></span> <span data-ttu-id="fcd1f-137">In altre parole, la transazione legge solo i dati di cui è stato eseguito il commit nel database o che sono stati modificati dalla transazione corrente.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-137">In other words, the transaction only reads data which has either been committed to the database, or has been changed by the current transaction.</span></span>  
  
 <span data-ttu-id="fcd1f-138">Tutti i livelli di isolamento supportati per le tabelle ottimizzate per la memoria forniscono Read Committed garantito.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-138">All isolation levels supported for memory-optimized tables provide the read committed guarantee.</span></span> <span data-ttu-id="fcd1f-139">Pertanto, se la transazione non richiede garanzie maggiori, è possibile utilizzare uno dei livelli di isolamento supportati per le tabelle ottimizzate per la memoria.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-139">Therefore, if the transaction does not require stronger guarantees, you can use any of the isolation levels supported for memory-optimized tables.</span></span> <span data-ttu-id="fcd1f-140">SNAPSHOT utilizza la minore quantità delle risorse di sistema, rispetto agli altri livelli di isolamento.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-140">SNAPSHOT uses the fewest system resources, compared to other isolation levels.</span></span>  
  
 <span data-ttu-id="fcd1f-141">La garanzia offerta dal livello di isolamento SNAPSHOT (il livello più basso di isolamento supportato per le tabelle ottimizzate per la memoria) include le garanzie di READ COMMITTED.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-141">The guarantee provided by the SNAPSHOT isolation level (the lowest level of isolation supported for memory-optimized tables) includes the guarantees of READ COMMITTED.</span></span> <span data-ttu-id="fcd1f-142">Ogni istruzione della transazione legge la stessa versione coerente del database.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-142">Every statement in the transaction reads the same, consistent version of the database.</span></span> <span data-ttu-id="fcd1f-143">Non solo tutte le righe vengono lette dalla transazione di cui è stato eseguito il commit nel database, ma anche tutte le operazioni di lettura rilevano il set di modifiche apportate dallo stesso set di transazioni.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-143">Not only are all the rows read by the transaction committed to the database, also all the read operations see the set of changes made by the same set of transactions.</span></span>  
  
 <span data-ttu-id="fcd1f-144">**Linee guida**: se è necessaria solo la garanzia di isolamento Read Committed, usare l'isolamento dello snapshot con le stored procedure compilate in modo nativo e per accedere alle tabelle ottimizzate per la memoria tramite interpretato [!INCLUDE[tsql](../includes/tsql-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="fcd1f-144">**Guideline**: If only the READ COMMITTED isolation guarantee is required, use SNAPSHOT isolation with natively compiled stored procedures and for accessing memory-optimized tables through interpreted [!INCLUDE[tsql](../includes/tsql-md.md)].</span></span>  
  
 <span data-ttu-id="fcd1f-145">Per le transazioni in modalità autocommit, viene eseguito il mapping implicito del livello di isolamento READ COMMITTED a SNAPSHOT per le tabelle ottimizzate per la memoria.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-145">For autocommit transactions, the isolation level READ COMMITTED is implicitly mapped to SNAPSHOT for memory-optimized tables.</span></span> <span data-ttu-id="fcd1f-146">Pertanto, se il valore della sessione TRANSACTION ISOLATION LEVEL è impostato su READ COMMITTED, non è necessario specificare il livello di isolamento tramite un hint di tabella durante l'accesso alle tabelle ottimizzate per la memoria.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-146">Therefore, if the TRANSACTION ISOLATION LEVEL session setting is set to READ COMMITTED, it is not necessary to specify the isolation level through a table hint when accessing memory-optimized tables.</span></span>  
  
 <span data-ttu-id="fcd1f-147">Nell'esempio di transazione in modalità autocommit seguente viene illustrato un join tra una tabella Customers ottimizzata per la memoria e una tabella normale [Order History], come parte di un batch ad hoc:</span><span class="sxs-lookup"><span data-stu-id="fcd1f-147">The following autocommit transaction example shows a join between a memory-optimized table Customers and a regular table [Order History], as part of an ad hoc batch:</span></span>  
  
```sql  
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;  
GO  
SELECT *   
FROM dbo.Customers AS c   
LEFT JOIN dbo.[Order History] AS oh   
    ON c.customer_id = oh.customer_id;  
```  
  
 <span data-ttu-id="fcd1f-148">Nell'esempio di transazioni esplicite o implicite riportato di seguito viene illustrato lo stesso join, ma questa volta a una transazione utente esplicita.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-148">The following explicit or implicit transactions example shows the same join, but this time in an explicit user transaction.</span></span> <span data-ttu-id="fcd1f-149">L'accesso alla tabella ottimizzata per la memoria Customers viene effettuato nel livello di isolamento SNAPSHOT, come indicato tramite l'hint di tabella WITH (SNAPSHOT), mentre l'accesso alla tabella normale [Order History] viene effettuato con il livello di isolamento READ COMMITTED:</span><span class="sxs-lookup"><span data-stu-id="fcd1f-149">The memory-optimized table Customers is accessed under snapshot isolation, as indicated through the table hint WITH (SNAPSHOT), and the regular table [Order History] is accessed under read committed isolation:</span></span>  
  
```sql  
SET TRANSACTION ISOLATION LEVEL READ COMMITTED  
GO  
BEGIN TRAN  
SELECT * FROM dbo.Customers c with (SNAPSHOT)   
LEFT JOIN dbo.[Order History] oh   
    ON c.customer_id=oh.customer_id  
...  
COMMIT  
```  
  
### <a name="operational-differences"></a><span data-ttu-id="fcd1f-150">Differenze operative</span><span class="sxs-lookup"><span data-stu-id="fcd1f-150">Operational Differences</span></span>  
 <span data-ttu-id="fcd1f-151">Oltre alla garanzia READ COMMITTED, sono inoltre disponibili due dettagli di implementazione chiave che possono essere utilizzati nelle applicazioni utilizzano tabelle basate su disco.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-151">Besides the read committed guarantee, there are also two key implementation details that applications using disk-based tables may rely on.</span></span> <span data-ttu-id="fcd1f-152">Considerare i seguenti fattori durante la conversione di una tabella basata su disco a cui si accede tramite isolamento READ COMMITTED in una tabella ottimizzata per la memoria a cui si accede con l'isolamento SNAPSHOT:</span><span class="sxs-lookup"><span data-stu-id="fcd1f-152">Be aware of the following when converting a disk-based table that is accessed using READ COMMITTED isolation to a memory-optimized table that is accessed using SNAPSHOT isolation:</span></span>  
  
-   <span data-ttu-id="fcd1f-153">Nell'implementazione del livello di isolamento READ COMMITTED per le tabelle basate su disco (presupponendo che READ_COMMITTED_SNAPSHOT sia impostato su OFF) vengono utilizzati blocchi per evitare conflitti tra lettori e writer.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-153">The implementation of the READ COMMITTED isolation level for disk-based tables (assuming READ_COMMITTED_SNAPSHOT is OFF) uses locks to prevent conflicts between readers and writers.</span></span> <span data-ttu-id="fcd1f-154">Quando un writer avvia l'aggiornamento di una riga, accetta un blocco e non lo rilascia finché non viene eseguito il commit della transazione.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-154">When a writer starts updating a row, it takes a lock and does not release the lock until the transaction is committed.</span></span> <span data-ttu-id="fcd1f-155">Tutte le operazioni di lettura vengono bloccate in attesa che venga eseguito il commit della transazione di scrittura.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-155">Any read operations are blocked and will wait for the write transaction to commit.</span></span>  
  
     <span data-ttu-id="fcd1f-156">In alcune applicazioni è possibile che venga presupposto che i lettori attendano sempre i writer per eseguire il commit, in particolare in presenza di un'eventuale sincronizzazione tra le due transazioni nel livello applicazione.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-156">Some applications may assume readers always wait for writers to commit, particularly if there is any synchronization between the two transactions in the application tier.</span></span>  
  
     <span data-ttu-id="fcd1f-157">**Linee guida:** Le applicazioni non possono basarsi sul comportamento di blocco.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-157">**Guideline:** Applications cannot rely on blocking behavior.</span></span> <span data-ttu-id="fcd1f-158">Se un'applicazione richiede la sincronizzazione tra transazioni simultanee, tale logica può essere implementata a livello di applicazione o a livello di database, tramite [sp_getapplock &#40;&#41;Transact-SQL ](/sql/relational-databases/system-stored-procedures/sp-getapplock-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="fcd1f-158">If an application needs synchronization between concurrent transactions, such logic can be implemented in the application tier or in the database tier, through [sp_getapplock &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-getapplock-transact-sql).</span></span>  
  
-   <span data-ttu-id="fcd1f-159">Nelle transazioni che utilizzano l'isolamento READ COMMITTED ogni istruzione rileva la versione più recente delle righe nel database.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-159">In transactions that use READ COMMITTED isolation, each statement sees the most recent version of the rows in the database.</span></span> <span data-ttu-id="fcd1f-160">Pertanto, le istruzioni successive rilevano le modifiche apportate nello stato del database.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-160">Therefore, subsequent statements see changes in the state of the database.</span></span>  
  
     <span data-ttu-id="fcd1f-161">Il polling di una tabella utilizzando un loop WHILE fino a trovare una nuova riga è un esempio di modello applicativo che utilizza questo presupposto.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-161">Polling a table using a WHILE loop until a new row has been found is an example of an application pattern that uses this assumption.</span></span> <span data-ttu-id="fcd1f-162">A ogni iterazione del ciclo la query rileverà gli aggiornamenti più recenti nel database.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-162">With each iteration of the loop, the query will see the latest updates in the database.</span></span>  
  
     <span data-ttu-id="fcd1f-163">**Linee guida:** Se un'applicazione deve eseguire il polling di una tabella ottimizzata per la memoria per ottenere le righe più recenti scritte nella tabella, spostare il ciclo di polling al di fuori dell'ambito della transazione.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-163">**Guideline:** If an application needs to poll a memory-optimized table to obtain the most recent rows written to the table, move the polling loop outside the scope of the transaction.</span></span>  
  
     <span data-ttu-id="fcd1f-164">Di seguito è riportato un modello di un'applicazione di esempio che utilizza questo presupposto.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-164">The following is an example application pattern that uses this assumption.</span></span> <span data-ttu-id="fcd1f-165">Eseguire il polling di una tabella utilizzando un ciclo WHILE fino a trovare una nuova riga.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-165">Polling a table using a WHILE loop until a new row is found.</span></span> <span data-ttu-id="fcd1f-166">In ogni iterazione del ciclo la query accederà agli aggiornamenti più recenti nel database.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-166">In each loop iteration, the query will access the latest updates in the database.</span></span>  
  
 <span data-ttu-id="fcd1f-167">Nel seguente script di esempio viene eseguito il polling di una tabella t1 fino a trovare una riga.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-167">The following example script polls a table t1 until it has a row.</span></span> <span data-ttu-id="fcd1f-168">Viene quindi rimossa una singola riga dalla tabella per un'ulteriore elaborazione.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-168">It then removes a single row from the table for further processing.</span></span>  
  
 <span data-ttu-id="fcd1f-169">Si noti che la logica di polling deve essere all'esterno dell'ambito della transazione, poiché utilizza l'isolamento Snapshot per accedere alla tabella t1.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-169">Notice that the polling logic needs to be outside the scope of the transaction, as it is using snapshot isolation to access table t1.</span></span> <span data-ttu-id="fcd1f-170">L'utilizzo della logica di polling all'interno dell'ambito di una transazione crea una transazione con esecuzione prolungata, quindi è sconsigliata.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-170">Using polling logic inside the scope of a transaction would create a long-running transaction, which is a bad practice.</span></span>  
  
```sql  
-- poll table  
WHILE NOT EXISTS (SELECT 1 FROM dbo.t1)  
BEGIN   
  -- if empty, wait and poll again  
  WAITFOR DELAY '00:00:01'  
END  
  
BEGIN TRANSACTION  
  DECLARE @id int  
  SELECT TOP 1 @id=id FROM dbo.t1 WITH (SNAPSHOT)  
  DELETE FROM dbo.t1 WITH (SNAPSHOT) WHERE id=@id  
  
  -- insert processing based on @id  
COMMIT  
```  
  
## <a name="locking-table-hints"></a><span data-ttu-id="fcd1f-171">Hint di tabella di blocco</span><span class="sxs-lookup"><span data-stu-id="fcd1f-171">Locking Table Hints</span></span>  
 <span data-ttu-id="fcd1f-172">Gli hint di blocco ([hint di tabella &#40;&#41;Transact-SQL ](/sql/t-sql/queries/hints-transact-sql-table)), ad esempio HOLDLOCK e XLOCK, possono essere utilizzati con le tabelle basate su disco in modo da [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] richiedere più blocchi rispetto a quelli necessari per il livello di isolamento specificato.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-172">Locking hints ([Table Hints &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-table)) such as HOLDLOCK and XLOCK can be used with disk-based tables to have [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] take more locks than are required for the specified isolation level.</span></span>  
  
 <span data-ttu-id="fcd1f-173">I blocchi non vengono utilizzati per le tabelle con ottimizzazione per la memoria.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-173">Memory-optimized tables do not use locks.</span></span> <span data-ttu-id="fcd1f-174">I livelli di isolamento più elevati quali REPEATABLE READ e SERIALIZABLE possono essere utilizzati per dichiarare le garanzie desiderate.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-174">Higher isolation levels such as REPEATABLE READ and SERIALIZABLE can be used to declare the desired guarantees.</span></span>  
  
 <span data-ttu-id="fcd1f-175">Gli hint di blocco non sono supportati.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-175">Locking hints are not supported.</span></span> <span data-ttu-id="fcd1f-176">In alternativa, è possibile dichiarare le garanzie necessarie tramite i livelli di isolamento delle transazioni.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-176">Instead, declare the required guarantees through the transaction isolation levels.</span></span> <span data-ttu-id="fcd1f-177">NOLOCK è supportato poiché [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] non accetta blocchi sulle tabelle ottimizzate per la memoria.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-177">(NOLOCK is supported because [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] does not take locks on memory-optimized tables.</span></span> <span data-ttu-id="fcd1f-178">Si noti che, diversamente dalle tabelle basate su disco, NOLOCK non implica il comportamento READ UNCOMMITTED per le tabelle ottimizzate per la memoria.</span><span class="sxs-lookup"><span data-stu-id="fcd1f-178">Note that, in contrast to disk-based tables, NOLOCK does not imply READ UNCOMMITTED behavior for memory-optimized tables.)</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="fcd1f-179">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="fcd1f-179">See Also</span></span>  
 <span data-ttu-id="fcd1f-180">[Informazioni sulle transazioni nelle tabelle ottimizzate per la memoria](../../2014/database-engine/understanding-transactions-on-memory-optimized-tables.md) </span><span class="sxs-lookup"><span data-stu-id="fcd1f-180">[Understanding Transactions on Memory-Optimized Tables](../../2014/database-engine/understanding-transactions-on-memory-optimized-tables.md) </span></span>  
 <span data-ttu-id="fcd1f-181">[Linee guida per la logica di ripetizione tentativi per le transazioni nelle tabelle ottimizzate per la memoria](../../2014/database-engine/guidelines-for-retry-logic-for-transactions-on-memory-optimized-tables.md) </span><span class="sxs-lookup"><span data-stu-id="fcd1f-181">[Guidelines for Retry Logic for Transactions on Memory-Optimized Tables](../../2014/database-engine/guidelines-for-retry-logic-for-transactions-on-memory-optimized-tables.md) </span></span>  
 [<span data-ttu-id="fcd1f-182">Livelli di isolamento delle transazioni</span><span class="sxs-lookup"><span data-stu-id="fcd1f-182">Transaction Isolation Levels</span></span>](../../2014/database-engine/transaction-isolation-levels.md)  
  
  
