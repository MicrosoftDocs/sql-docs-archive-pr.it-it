---
title: Determinazione del numero di bucket corretto per gli indici hash | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 6d1ac280-87db-4bd8-ad43-54353647d8b5
author: stevestein
ms.author: sstein
ms.openlocfilehash: e0579a98e3302b6944f68ca449d3e7cda0ecc01d
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/04/2020
ms.locfileid: "87626259"
---
# <a name="determining-the-correct-bucket-count-for-hash-indexes"></a><span data-ttu-id="46188-102">Determinazione del numero di bucket corretto per gli indici hash</span><span class="sxs-lookup"><span data-stu-id="46188-102">Determining the Correct Bucket Count for Hash Indexes</span></span>
  <span data-ttu-id="46188-103">È necessario specificare un valore per il parametro `BUCKET_COUNT` durante la creazione della tabella ottimizzata per la memoria.</span><span class="sxs-lookup"><span data-stu-id="46188-103">You must specify a value for the `BUCKET_COUNT` parameter when you create the memory-optimized table.</span></span> <span data-ttu-id="46188-104">In questo argomento vengono fornite indicazioni per determinare il valore appropriato per il parametro `BUCKET_COUNT`.</span><span class="sxs-lookup"><span data-stu-id="46188-104">This topic makes recommendations for determining the appropriate value for the `BUCKET_COUNT` parameter.</span></span> <span data-ttu-id="46188-105">Se non è possibile determinare il numero di bucket corretto, utilizzare in alternativa un indice non cluster.</span><span class="sxs-lookup"><span data-stu-id="46188-105">If you cannot determine the correct bucket count, use a nonclustered index instead.</span></span>  <span data-ttu-id="46188-106">Un valore `BUCKET_COUNT` errato, in particolare se troppo basso, può influire in modo significativo sulle prestazioni del carico di lavoro e sul tempo di recupero del database.</span><span class="sxs-lookup"><span data-stu-id="46188-106">An incorrect `BUCKET_COUNT` value, especially one that is too low, can significantly impact workload performance, as well as recovery time of the database.</span></span> <span data-ttu-id="46188-107">È consigliabile sovrastimare il numero di bucket.</span><span class="sxs-lookup"><span data-stu-id="46188-107">It is better to overestimate the bucket count.</span></span>  
  
 <span data-ttu-id="46188-108">Le chiavi duplicate dell'indice possono ridurre le prestazioni con un indice hash perché viene eseguito l'hash delle chiavi nello stesso bucket, causando un aumento della catena del bucket.</span><span class="sxs-lookup"><span data-stu-id="46188-108">Duplicate index keys can decrease performance with a hash index because the keys are hashed to the same bucket, causing that bucket's chain to increase.</span></span>  
  
 <span data-ttu-id="46188-109">Per ulteriori informazioni sugli indici hash non cluster, vedere [Hash Indexes](hash-indexes.md) e [Guidelines for Using Indexes on Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).</span><span class="sxs-lookup"><span data-stu-id="46188-109">For more information about nonclustered hash indexes, see [Hash Indexes](hash-indexes.md) and [Guidelines for Using Indexes on Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).</span></span>  
  
 <span data-ttu-id="46188-110">Una tabella hash viene allocata per ogni indice hash in una tabella ottimizzata per la memoria.</span><span class="sxs-lookup"><span data-stu-id="46188-110">One hash table is allocated for each hash index on a memory-optimized table.</span></span> <span data-ttu-id="46188-111">Le dimensioni della tabella hash allocata per un indice sono specificate dal `BUCKET_COUNT` parametro in [Create Table &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql) o [create Type &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-type-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="46188-111">The size of the hash table allocated for an index is specified by the `BUCKET_COUNT` parameter in [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql) or [CREATE TYPE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-type-transact-sql).</span></span> <span data-ttu-id="46188-112">Il numero di bucket verrà arrotondato internamente per eccesso alla potenza più vicina di due.</span><span class="sxs-lookup"><span data-stu-id="46188-112">The bucket count will internally be rounded up to the next power of two.</span></span> <span data-ttu-id="46188-113">Se, ad esempio, si specifica un numero di bucket pari a 300.000 si avrà un numero di bucket effettivo pari a 524.288.</span><span class="sxs-lookup"><span data-stu-id="46188-113">For example, specifying a bucket count of 300,000 will result in an actual bucket count of 524,288.</span></span>  
  
 <span data-ttu-id="46188-114">Per i collegamenti a un articolo e a un video sul numero di bucket, vedere [Come determinare 'esatto numero di bucket per gli indici hash (OLTP in memoria)](https://www.mssqltips.com/sqlservertip/3104/determine-bucketcount-for-hash-indexes-for-sql-server-memory-optimized-tables/).</span><span class="sxs-lookup"><span data-stu-id="46188-114">For links to an article and video on bucket count, see [How to determine the right bucket count for hash indexes (In-Memory OLTP)](https://www.mssqltips.com/sqlservertip/3104/determine-bucketcount-for-hash-indexes-for-sql-server-memory-optimized-tables/).</span></span>  
  
## <a name="recommendations"></a><span data-ttu-id="46188-115">Consigli</span><span class="sxs-lookup"><span data-stu-id="46188-115">Recommendations</span></span>  
 <span data-ttu-id="46188-116">Nella maggior parte dei casi, il numero di bucket dovrebbe essere impostato su un valore compreso tra una e due volte il numero di valori distinct nella chiave di indice.</span><span class="sxs-lookup"><span data-stu-id="46188-116">In most cases the bucket count should be between 1 and 2 times the number of distinct values in the index key.</span></span> <span data-ttu-id="46188-117">Se la chiave di indice contiene molti valori duplicati (in media sono presenti più di 10 righe per ogni valore di chiave di indice), utilizzare in alternativa un indice non cluster.</span><span class="sxs-lookup"><span data-stu-id="46188-117">If the index key contains a lot of duplicate values, on average there are more than 10 rows for each index key value, use a nonclustered index instead</span></span>  
  
 <span data-ttu-id="46188-118">Non è sempre possibile stimare quanti valori ha o potrebbe avere una particolare chiave di indice.</span><span class="sxs-lookup"><span data-stu-id="46188-118">You may not always be able to predict how many values a particular index key may have or will have.</span></span> <span data-ttu-id="46188-119">Le prestazioni dovrebbero essere accettabili se il valore `BUCKET_COUNT` non supera di 5 volte il numero effettivo dei valori di chiave.</span><span class="sxs-lookup"><span data-stu-id="46188-119">Performance should be acceptable if the `BUCKET_COUNT` value is within 5 times of the actual number of key values.</span></span>  
  
 <span data-ttu-id="46188-120">Per determinare il numero delle chiavi di indice univoche nei dati esistenti, utilizzare query simili agli esempi seguenti:</span><span class="sxs-lookup"><span data-stu-id="46188-120">To determine the number of unique index keys in existing data, use queries similar to the following examples:</span></span>  
  
### <a name="primary-key-and-unique-indexes"></a><span data-ttu-id="46188-121">Chiave primaria e indici univoci</span><span class="sxs-lookup"><span data-stu-id="46188-121">Primary Key and Unique Indexes</span></span>  
 <span data-ttu-id="46188-122">Poiché l'indice di chiave primaria è univoco, il numero di valori distinct nella chiave corrisponde al numero di righe nella tabella.</span><span class="sxs-lookup"><span data-stu-id="46188-122">Because the primary key index is unique, the number of distinct values in the key corresponds to the number of rows in the table.</span></span> <span data-ttu-id="46188-123">Per un esempio di chiave primaria in (SalesOrderID, SalesOrderDetailID) nella tabella Sales.SalesOrderDetail del database AdventureWorks, eseguire la query seguente per calcolare il numero di valori di chiave primaria distinct, che corrisponde al numero di righe nella tabella:</span><span class="sxs-lookup"><span data-stu-id="46188-123">For an example primary key on (SalesOrderID, SalesOrderDetailID) in the table Sales.SalesOrderDetail in the AdventureWorks database, issue the following query to calculate the number of distinct primary key values, which corresponds to the number of rows in the table:</span></span>  
  
```sql  
SELECT COUNT(*) AS [row count]   
FROM Sales.SalesOrderDetail  
```  
  
 <span data-ttu-id="46188-124">La query indica un numero di righe pari a 121.317.</span><span class="sxs-lookup"><span data-stu-id="46188-124">This query shows a row count of 121,317.</span></span> <span data-ttu-id="46188-125">Utilizzare un numero di bucket pari a 240.000 se il conteggio delle righe non cambia in modo significativo.</span><span class="sxs-lookup"><span data-stu-id="46188-125">Use a bucket count of 240,000 if the row count will not change significantly.</span></span> <span data-ttu-id="46188-126">Utilizzare un numero di bucket pari a 480.000 se si prevede che il numero di ordini di vendita nella tabella venga quadruplicato.</span><span class="sxs-lookup"><span data-stu-id="46188-126">Use a bucket count of 480,000 if the number of sales orders in the table is expected to quadruple.</span></span>  
  
### <a name="non-unique-indexes"></a><span data-ttu-id="46188-127">Indici non univoci</span><span class="sxs-lookup"><span data-stu-id="46188-127">Non-Unique Indexes</span></span>  
 <span data-ttu-id="46188-128">Per altri indici, ad esempio un indice a più colonne in (SpecialOfferID, ProductID), eseguire la query seguente per determinare il numero di valori di chiave di indice univoci:</span><span class="sxs-lookup"><span data-stu-id="46188-128">For other indexes, for example a multi-column index on (SpecialOfferID, ProductID), issue the following query to determine the number of unique index key values:</span></span>  
  
```sql  
SELECT COUNT(*) AS [SpecialOfferID_ProductID index key count]  
FROM   
   (SELECT DISTINCT SpecialOfferID, ProductID   
    FROM Sales.SalesOrderDetail) t  
```  
  
 <span data-ttu-id="46188-129">Questa query restituisce un conteggio di chiavi di indice per (SpecialOfferID, ProductID) di 484, per indicare che deve essere utilizzato un indice non cluster anziché un indice hash non cluster.</span><span class="sxs-lookup"><span data-stu-id="46188-129">This query returns an index key count for (SpecialOfferID, ProductID) of 484, indicating a that a nonclustered index should be used instead of a nonclustered hash index.</span></span>  
  
### <a name="determining-the-number-of-duplicates"></a><span data-ttu-id="46188-130">Determinazione del numero di duplicati</span><span class="sxs-lookup"><span data-stu-id="46188-130">Determining the Number of Duplicates</span></span>  
 <span data-ttu-id="46188-131">Per determinare il numero medio di valori duplicati per un valore di chiave di indice, dividere il numero totale delle righe per il numero di chiavi di indice univoche.</span><span class="sxs-lookup"><span data-stu-id="46188-131">To determine the average number of duplicate values for an index key value, divide the total number of rows by the number of unique index keys.</span></span>  
  
 <span data-ttu-id="46188-132">Per l'indice dell'esempio in (SpecialOfferID, ProductID), si ha il calcolo 121317/484 = 251.</span><span class="sxs-lookup"><span data-stu-id="46188-132">For the example index on (SpecialOfferID, ProductID), this leads to 121317 / 484 = 251.</span></span> <span data-ttu-id="46188-133">Ciò significa che la media dei valori di chiave di indice è pari 251 ed è pertanto consigliabile un indice non cluster.</span><span class="sxs-lookup"><span data-stu-id="46188-133">This means index key values have an average of 251, and thus this should be a nonclustered index.</span></span>  
  
## <a name="troubleshooting-the-bucket-count"></a><span data-ttu-id="46188-134">Risoluzione dei problemi relativi al numero di bucket</span><span class="sxs-lookup"><span data-stu-id="46188-134">Troubleshooting the Bucket Count</span></span>  
 <span data-ttu-id="46188-135">Per risolvere i problemi relativi al numero di bucket nelle tabelle ottimizzate per la memoria, utilizzare [sys. dm_db_xtp_hash_index_stats &#40;&#41;Transact-SQL](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-hash-index-stats-transact-sql) per ottenere statistiche sui bucket vuoti e la lunghezza delle catene di righe.</span><span class="sxs-lookup"><span data-stu-id="46188-135">To troubleshoot bucket count issues in memory-optimized tables, use [sys.dm_db_xtp_hash_index_stats &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-hash-index-stats-transact-sql) to obtain statistics about the empty buckets and the length of row chains.</span></span> <span data-ttu-id="46188-136">È possibile utilizzare la query seguente per ottenere statistiche su tutti gli indici hash nel database corrente.</span><span class="sxs-lookup"><span data-stu-id="46188-136">The following query can be used to obtain statistics about all the hash indexes in the current database.</span></span> <span data-ttu-id="46188-137">L'esecuzione della query può richiedere alcuni minuti se sono presenti tabelle di grandi dimensioni nel database.</span><span class="sxs-lookup"><span data-stu-id="46188-137">The query can take several minutes to run if there are large tables in the database.</span></span>  
  
```sql  
SELECT   
   object_name(hs.object_id) AS 'object name',   
   i.name as 'index name',   
   hs.total_bucket_count,  
   hs.empty_bucket_count,  
   floor((cast(empty_bucket_count as float)/total_bucket_count) * 100) AS 'empty_bucket_percent',  
   hs.avg_chain_length,   
   hs.max_chain_length  
FROM sys.dm_db_xtp_hash_index_stats AS hs   
   JOIN sys.indexes AS i   
   ON hs.object_id=i.object_id AND hs.index_id=i.index_id  
```  
  
 <span data-ttu-id="46188-138">I due indicatori principali dell'indice hash sono i seguenti:</span><span class="sxs-lookup"><span data-stu-id="46188-138">The two key indicators of hash index health are:</span></span>  
  
 <span data-ttu-id="46188-139">*empty_bucket_percent*</span><span class="sxs-lookup"><span data-stu-id="46188-139">*empty_bucket_percent*</span></span>  
 <span data-ttu-id="46188-140">*empty_bucket_percent* indica il numero di bucket vuoti nell'indice hash.</span><span class="sxs-lookup"><span data-stu-id="46188-140">*empty_bucket_percent* indicates the number of empty buckets in the hash index.</span></span>  
  
 <span data-ttu-id="46188-141">Se *empty_bucket_percent* è minore del 10%, il numero di bucket è probabilmente troppo basso.</span><span class="sxs-lookup"><span data-stu-id="46188-141">If *empty_bucket_percent* is less than 10 percent, the bucket count is likely to be too low.</span></span> <span data-ttu-id="46188-142">In teoria, il valore *empty_bucket_percent* dovrebbe essere pari al 33% o superiore.</span><span class="sxs-lookup"><span data-stu-id="46188-142">Ideally, the *empty_bucket_percent* should be 33 percent or greater.</span></span> <span data-ttu-id="46188-143">Se il numero di bucket corrisponde al numero di valori di chiave di indice, circa 1/3 dei bucket è vuoto, a causa della distribuzione hash.</span><span class="sxs-lookup"><span data-stu-id="46188-143">If the bucket count matches the number of index key values, about 1/3 of the buckets is empty, due to hash distribution.</span></span>  
  
 <span data-ttu-id="46188-144">*avg_chain_length*</span><span class="sxs-lookup"><span data-stu-id="46188-144">*avg_chain_length*</span></span>  
 <span data-ttu-id="46188-145">*avg_chain_length* indica la lunghezza media delle catene di righe nel bucket di hash.</span><span class="sxs-lookup"><span data-stu-id="46188-145">*avg_chain_length* indicates the average length of the row chains in the hash buckets.</span></span>  
  
 <span data-ttu-id="46188-146">Se *avg_chain_length* è maggiore di 10 e *empty_bucket_percent* è maggiore del 10%, probabilmente sono presenti molti valori di chiave di indice duplicati ed è più adatto un indice non cluster.</span><span class="sxs-lookup"><span data-stu-id="46188-146">If *avg_chain_length* is greater than 10 and *empty_bucket_percent* is greater than 10 percent, there likely are many duplicate index key values and a nonclustered index would be more appropriate.</span></span> <span data-ttu-id="46188-147">La lunghezza media ideale della catena è pari a 1.</span><span class="sxs-lookup"><span data-stu-id="46188-147">An average chain length of 1 is ideal.</span></span>  
  
 <span data-ttu-id="46188-148">Sulla lunghezza della catena influiscono due fattori:</span><span class="sxs-lookup"><span data-stu-id="46188-148">There are two factors that impact the chain length:</span></span>  
  
1.  <span data-ttu-id="46188-149">Duplicati. Tutte le righe duplicate fanno parte della stessa catena nell'indice hash.</span><span class="sxs-lookup"><span data-stu-id="46188-149">Duplicates; all duplicate rows are part of the same chain in the hash index.</span></span>  
  
2.  <span data-ttu-id="46188-150">Viene eseguito il mapping di più valori allo stesso bucket.</span><span class="sxs-lookup"><span data-stu-id="46188-150">Multiple key values map to the same bucket.</span></span> <span data-ttu-id="46188-151">Più basso è il numero di bucket, maggiore sarà il numero di bucket con più valori a cui verrà eseguito il mapping.</span><span class="sxs-lookup"><span data-stu-id="46188-151">The lower the bucket count, the more buckets that will have multiple values mapped to them.</span></span>  
  
 <span data-ttu-id="46188-152">Ad esempio, si considerino la tabella e lo script per inserire righe di esempio nella tabella riportati di seguito:</span><span class="sxs-lookup"><span data-stu-id="46188-152">As an example, consider the following table and script to insert sample rows in the table:</span></span>  
  
```sql  
CREATE TABLE [Sales].[SalesOrderHeader_test]  
(  
   [SalesOrderID] [uniqueidentifier] NOT NULL DEFAULT (newid()),  
   [OrderSequence] int NOT NULL,  
   [OrderDate] [datetime2](7) NOT NULL,  
   [Status] [tinyint] NOT NULL,  
  
PRIMARY KEY NONCLUSTERED HASH ([SalesOrderID]) WITH ( BUCKET_COUNT = 262144 ),  
INDEX IX_OrderSequence HASH (OrderSequence) WITH ( BUCKET_COUNT = 20000),  
INDEX IX_Status HASH ([Status]) WITH ( BUCKET_COUNT = 8),  
INDEX IX_OrderDate NONCLUSTERED ([OrderDate] ASC),  
)WITH ( MEMORY_OPTIMIZED = ON , DURABILITY = SCHEMA_AND_DATA )  
GO  
  
DECLARE @i int = 0  
BEGIN TRAN  
WHILE @i < 262144  
BEGIN  
   INSERT Sales.SalesOrderHeader_test (OrderSequence, OrderDate, [Status]) VALUES (@i, sysdatetime(), @i % 8)  
   SET @i += 1  
END  
COMMIT  
GO  
```  
  
 <span data-ttu-id="46188-153">Lo script inserisce 262.144 righe nella tabella.</span><span class="sxs-lookup"><span data-stu-id="46188-153">The script inserts 262,144 rows in the table.</span></span> <span data-ttu-id="46188-154">Vengono inseriti valori univoci nell'indice di chiave primaria e in IX_OrderSequence.</span><span class="sxs-lookup"><span data-stu-id="46188-154">It inserts unique values in the primary key index and in IX_OrderSequence.</span></span> <span data-ttu-id="46188-155">Vengono inseriti molti valori duplicati nell'indice IX_Status: lo script genera solo 8 valori distinct.</span><span class="sxs-lookup"><span data-stu-id="46188-155">It inserts a lot of duplicate values in the index IX_Status: the script only generates 8 distinct values.</span></span>  
  
 <span data-ttu-id="46188-156">L'output della query per la risoluzione dei problemi di BUCKET_COUNT è il seguente:</span><span class="sxs-lookup"><span data-stu-id="46188-156">The output of the BUCKET_COUNT troubleshooting query is as follows:</span></span>  
  
|<span data-ttu-id="46188-157">nome indice</span><span class="sxs-lookup"><span data-stu-id="46188-157">index name</span></span>|<span data-ttu-id="46188-158">total_bucket_count</span><span class="sxs-lookup"><span data-stu-id="46188-158">total_bucket_count</span></span>|<span data-ttu-id="46188-159">empty_bucket_count</span><span class="sxs-lookup"><span data-stu-id="46188-159">empty_bucket_count</span></span>|<span data-ttu-id="46188-160">empty_bucket_percent</span><span class="sxs-lookup"><span data-stu-id="46188-160">empty_bucket_percent</span></span>|<span data-ttu-id="46188-161">avg_chain_length</span><span class="sxs-lookup"><span data-stu-id="46188-161">avg_chain_length</span></span>|<span data-ttu-id="46188-162">max_chain_length</span><span class="sxs-lookup"><span data-stu-id="46188-162">max_chain_length</span></span>|  
|----------------|--------------------------|--------------------------|----------------------------|------------------------|------------------------|  
|<span data-ttu-id="46188-163">IX_Status</span><span class="sxs-lookup"><span data-stu-id="46188-163">IX_Status</span></span>|<span data-ttu-id="46188-164">8</span><span class="sxs-lookup"><span data-stu-id="46188-164">8</span></span>|<span data-ttu-id="46188-165">4</span><span class="sxs-lookup"><span data-stu-id="46188-165">4</span></span>|<span data-ttu-id="46188-166">50</span><span class="sxs-lookup"><span data-stu-id="46188-166">50</span></span>|<span data-ttu-id="46188-167">65536</span><span class="sxs-lookup"><span data-stu-id="46188-167">65536</span></span>|<span data-ttu-id="46188-168">65536</span><span class="sxs-lookup"><span data-stu-id="46188-168">65536</span></span>|  
|<span data-ttu-id="46188-169">IX_OrderSequence</span><span class="sxs-lookup"><span data-stu-id="46188-169">IX_OrderSequence</span></span>|<span data-ttu-id="46188-170">32768</span><span class="sxs-lookup"><span data-stu-id="46188-170">32768</span></span>|<span data-ttu-id="46188-171">13</span><span class="sxs-lookup"><span data-stu-id="46188-171">13</span></span>|<span data-ttu-id="46188-172">0</span><span class="sxs-lookup"><span data-stu-id="46188-172">0</span></span>|<span data-ttu-id="46188-173">8</span><span class="sxs-lookup"><span data-stu-id="46188-173">8</span></span>|<span data-ttu-id="46188-174">26</span><span class="sxs-lookup"><span data-stu-id="46188-174">26</span></span>|  
|<span data-ttu-id="46188-175">PK_SalesOrd_B14003C3F8FB3364</span><span class="sxs-lookup"><span data-stu-id="46188-175">PK_SalesOrd_B14003C3F8FB3364</span></span>|<span data-ttu-id="46188-176">262144</span><span class="sxs-lookup"><span data-stu-id="46188-176">262144</span></span>|<span data-ttu-id="46188-177">96319</span><span class="sxs-lookup"><span data-stu-id="46188-177">96319</span></span>|<span data-ttu-id="46188-178">36</span><span class="sxs-lookup"><span data-stu-id="46188-178">36</span></span>|<span data-ttu-id="46188-179">1</span><span class="sxs-lookup"><span data-stu-id="46188-179">1</span></span>|<span data-ttu-id="46188-180">8</span><span class="sxs-lookup"><span data-stu-id="46188-180">8</span></span>|  
  
 <span data-ttu-id="46188-181">Si considerino i tre indici hash in questa tabella:</span><span class="sxs-lookup"><span data-stu-id="46188-181">Consider the three hash indexes on this table:</span></span>  
  
-   <span data-ttu-id="46188-182">IX_Status: il 50 percento dei bucket sono vuoti, una condizione positiva.</span><span class="sxs-lookup"><span data-stu-id="46188-182">IX_Status: 50 percent of the buckets are empty, which is good.</span></span> <span data-ttu-id="46188-183">Tuttavia, la lunghezza media della catena è molto elevata (65.536).</span><span class="sxs-lookup"><span data-stu-id="46188-183">However, the average chain length is very high (65,536).</span></span> <span data-ttu-id="46188-184">Ciò indica un numero alto di valori duplicati.</span><span class="sxs-lookup"><span data-stu-id="46188-184">This indicates a large number of duplicate values.</span></span> <span data-ttu-id="46188-185">Pertanto, l'utilizzo di un indice hash non cluster non è appropriato in questo caso.</span><span class="sxs-lookup"><span data-stu-id="46188-185">Therefore, using a nonclustered hash index is not appropriate in this case.</span></span> <span data-ttu-id="46188-186">È più opportuno utilizzare in alternativa un indice non cluster.</span><span class="sxs-lookup"><span data-stu-id="46188-186">A nonclustered index should be used instead.</span></span>  
  
-   <span data-ttu-id="46188-187">IX_OrderSequence: lo 0 percento dei bucket è vuoto, un valore troppo basso.</span><span class="sxs-lookup"><span data-stu-id="46188-187">IX_OrderSequence: 0 percent of the buckets are empty, which is too low.</span></span> <span data-ttu-id="46188-188">Inoltre, la lunghezza media della catena è pari a 8.</span><span class="sxs-lookup"><span data-stu-id="46188-188">In addition, the average chain length is 8.</span></span> <span data-ttu-id="46188-189">I valori di questo indice sono univoci e ciò implica che, in media, viene eseguito il mapping di 8 valori per ogni bucket.</span><span class="sxs-lookup"><span data-stu-id="46188-189">As the values in this index are unique, this means on average 8 values are mapped to each bucket.</span></span> <span data-ttu-id="46188-190">Il numero di bucket deve essere aumentato.</span><span class="sxs-lookup"><span data-stu-id="46188-190">The bucket count should be increased.</span></span> <span data-ttu-id="46188-191">Poiché la chiave di indice ha 262.144 valori univoci, il numero di bucket deve essere pari ad almeno 262.144.</span><span class="sxs-lookup"><span data-stu-id="46188-191">As the index key has 262,144 unique values, the bucket count should be at least 262,144.</span></span> <span data-ttu-id="46188-192">Se si prevede una crescita futura, il numero deve essere maggiore.</span><span class="sxs-lookup"><span data-stu-id="46188-192">If future growth is expected, the number should be higher.</span></span>  
  
-   <span data-ttu-id="46188-193">Indice di chiave primaria (PK__SalesOrder...): il 36% dei bucket è vuoto, il che è valido.</span><span class="sxs-lookup"><span data-stu-id="46188-193">Primary key index (PK__SalesOrder...): 36 percent of the buckets are empty, which is good.</span></span> <span data-ttu-id="46188-194">Inoltre, la lunghezza media della catena è pari a 1, un'altra condizione positiva.</span><span class="sxs-lookup"><span data-stu-id="46188-194">In addition the average chain length is 1, which is also good.</span></span> <span data-ttu-id="46188-195">Non è necessario apportare alcuna modifica.</span><span class="sxs-lookup"><span data-stu-id="46188-195">No change needed.</span></span>  
  
 <span data-ttu-id="46188-196">Per ulteriori informazioni sulla risoluzione dei problemi relativi agli indici hash ottimizzati per la memoria, vedere [Troubleshooting Common Performance Problems with Memory-Optimized Hash Indexes](../../2014/database-engine/troubleshooting-common-performance-problems-with-memory-optimized-hash-indexes.md).</span><span class="sxs-lookup"><span data-stu-id="46188-196">For more information on troubleshooting issues with your memory-optimized hash indexes, see [Troubleshooting Common Performance Problems with Memory-Optimized Hash Indexes](../../2014/database-engine/troubleshooting-common-performance-problems-with-memory-optimized-hash-indexes.md).</span></span>  
  
## <a name="detailed-considerations-for-further-optimization"></a><span data-ttu-id="46188-197">Considerazioni dettagliate per un'ulteriore ottimizzazione</span><span class="sxs-lookup"><span data-stu-id="46188-197">Detailed Considerations for Further Optimization</span></span>  
 <span data-ttu-id="46188-198">In questa sezione vengono presentate altre considerazioni per l'ottimizzazione del numero di bucket.</span><span class="sxs-lookup"><span data-stu-id="46188-198">This section outlines further considerations for optimizing the bucket count.</span></span>  
  
 <span data-ttu-id="46188-199">Per ottenere prestazioni ottimali per gli indici hash, è opportuno bilanciare la quantità di memoria allocata alla tabella hash e il numero di valori distinct nella chiave di indice.</span><span class="sxs-lookup"><span data-stu-id="46188-199">To achieve the best performance for hash indexes, balance the amount of memory allocated to the hash table and the number of distinct values in the index key.</span></span> <span data-ttu-id="46188-200">Esiste inoltre un compromesso tra le prestazioni delle ricerche di punti e le scansioni di tabella:</span><span class="sxs-lookup"><span data-stu-id="46188-200">There is also a balance between the performance of point lookups and table scans:</span></span>  
  
-   <span data-ttu-id="46188-201">Più alto è il valore del numero di bucket, maggiore sarà il numero di bucket vuoti nell'indice.</span><span class="sxs-lookup"><span data-stu-id="46188-201">The higher the bucket count value, the more empty buckets there will be in the index.</span></span> <span data-ttu-id="46188-202">Ciò influisce sull'utilizzo della memoria (8 byte per bucket) e sulle prestazioni delle analisi di tabella, in quanto ogni bucket viene analizzato come parte di un'analisi di tabella.</span><span class="sxs-lookup"><span data-stu-id="46188-202">This has an impact on memory usage (8 bytes per bucket) and the performance of table scans, as each bucket is scanned as part of a table scan.</span></span>  
  
-   <span data-ttu-id="46188-203">Più basso è il numero di bucket, più saranno i valori assegnati a un singolo bucket.</span><span class="sxs-lookup"><span data-stu-id="46188-203">The lower the bucket count, the more values are assigned to a single bucket.</span></span> <span data-ttu-id="46188-204">Ciò riduce le prestazioni per le ricerche di punti e gli inserimenti, perché in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] può essere necessario attraversare diversi valori in un singolo bucket per trovare il valore specificato nel predicato.</span><span class="sxs-lookup"><span data-stu-id="46188-204">This decreases performance for point lookups and inserts, because [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] may need to traverse several values in a single bucket to find the value specified by the search predicate.</span></span>  
  
 <span data-ttu-id="46188-205">Se il numero di bucket è notevolmente inferiore al numero di chiavi di indice univoche, verrà eseguito il mapping di molti valori a ogni bucket.</span><span class="sxs-lookup"><span data-stu-id="46188-205">If the bucket count is significantly lower than the number of unique index keys, many values will map to each bucket.</span></span> <span data-ttu-id="46188-206">Ciò comporta una riduzione delle prestazioni della maggior parte delle operazioni DML, in particolare delle ricerche di punti (ricerca di singole chiavi di indice) e delle operazioni di inserimento.</span><span class="sxs-lookup"><span data-stu-id="46188-206">This degrades performance of most DML operations, particularly point lookups (lookups of individual index keys) and insert operations.</span></span> <span data-ttu-id="46188-207">Ad esempio, si può avere un peggioramento delle prestazioni delle query SELECT e delle operazioni UPDATE e DELETE con predicati di uguaglianza corrispondenti alle colonne chiave di indice nella clausola WHERE.</span><span class="sxs-lookup"><span data-stu-id="46188-207">For example, you may see poor performance of SELECT queries and, UPDATE and DELETE operations with equality predicates matching the index key columns in the WHERE clause.</span></span> <span data-ttu-id="46188-208">Un numero di bucket basso influisce anche sul tempo di recupero del database, in quanto gli indici vengono ricreati all'avvio del database.</span><span class="sxs-lookup"><span data-stu-id="46188-208">A low bucket count will also affect the recovery time of the database, as the indexes are recreated on database startup.</span></span>  
  
### <a name="duplicate-index-key-values"></a><span data-ttu-id="46188-209">Valori di chiave di indice duplicati</span><span class="sxs-lookup"><span data-stu-id="46188-209">Duplicate Index Key Values</span></span>  
 <span data-ttu-id="46188-210">I valori duplicati possono aumentare l'impatto sulle prestazioni delle collisioni hash.</span><span class="sxs-lookup"><span data-stu-id="46188-210">Duplicate values can increase the performance impact of hash collisions.</span></span> <span data-ttu-id="46188-211">Ciò non costituisce generalmente un problema se ogni chiave di indice dispone di un numero basso di duplicati.</span><span class="sxs-lookup"><span data-stu-id="46188-211">This is usually not a problem if each index key has a low number of duplicates.</span></span> <span data-ttu-id="46188-212">Può tuttavia costituire un problema se la discrepanza tra il numero di chiavi di indice univoche e il numero di righe delle tabelle aumenta molto.</span><span class="sxs-lookup"><span data-stu-id="46188-212">But this can be a problem if the discrepancy between the number of unique index keys and the number of rows in the tables becomes very large.</span></span>  
  
 <span data-ttu-id="46188-213">Tutte le righe con la stessa chiave di indice saranno nella stessa catena duplicata.</span><span class="sxs-lookup"><span data-stu-id="46188-213">All rows with the same index key will go into the same duplicate chain.</span></span> <span data-ttu-id="46188-214">Se più chiavi di indice si trovano nello stesso bucket a causa di una collisione hash, gli scanner dell'indice devono sempre analizzare l'intera catena di duplicati per trovare il primo valore prima di poter individuare la prima riga corrispondente al secondo valore.</span><span class="sxs-lookup"><span data-stu-id="46188-214">If multiple index keys are in the same bucket due to a hash collision, index scanners always need to scan the full duplicate chain for the first value before they can locate the first row corresponding to the second value.</span></span> <span data-ttu-id="46188-215">Le chiavi duplicate rendono inoltre più difficile l'individuazione della riga da parte di Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="46188-215">Duplicate keys also make it more difficult for garbage collection to locate the row.</span></span> <span data-ttu-id="46188-216">Ad esempio, se sono presenti 1.000 duplicati per una chiave e una delle righe viene eliminata, il Garbage Collector deve analizzare la catena di 1.000 duplicati per scollegare la riga dall'indice.</span><span class="sxs-lookup"><span data-stu-id="46188-216">For example, if there are 1,000 duplicates for any key and one of the rows is deleted, the garbage collector needs to scan the chain of 1,000 duplicates to unlink the row from the index.</span></span> <span data-ttu-id="46188-217">Ciò vale anche se la query che ha individuato l'eliminazione ha utilizzato un indice più efficiente (un indice di chiave primaria) per individuare la riga, perché il Garbage Collector deve rimuovere il collegamento da ogni indice.</span><span class="sxs-lookup"><span data-stu-id="46188-217">This is true even if the query that found the delete used a more efficient index (a primary key index) to locate the row, because the garbage collector needs to unlink from every index</span></span>  
  
 <span data-ttu-id="46188-218">Per gli indici hash è possibile ridurre la quantità di operazioni rese necessarie dai valori di chiave di indice duplicati in due modi:</span><span class="sxs-lookup"><span data-stu-id="46188-218">For hash indexes, there are two ways to reduce the work caused by duplicate index key values:</span></span>  
  
-   <span data-ttu-id="46188-219">Utilizzare in alternativa un indice non cluster.</span><span class="sxs-lookup"><span data-stu-id="46188-219">Use a nonclustered index instead.</span></span> <span data-ttu-id="46188-220">È possibile ridurre i duplicati aggiungendo colonne alla chiave di indice senza che sia necessario apportare alcuna modifica all'applicazione.</span><span class="sxs-lookup"><span data-stu-id="46188-220">You can decrease the duplicates by adding columns to the index key without requiring any changes to the application.</span></span>  
  
-   <span data-ttu-id="46188-221">Specificare un numero di bucket molto elevato per l'indice.</span><span class="sxs-lookup"><span data-stu-id="46188-221">Specify a very high bucket count for the index.</span></span> <span data-ttu-id="46188-222">Ad esempio, da 20 a 100 volte il numero di chiavi di indice univoche.</span><span class="sxs-lookup"><span data-stu-id="46188-222">For example, 20-to-100 times the number of unique index keys.</span></span> <span data-ttu-id="46188-223">In questo modo si riducono le collisioni hash.</span><span class="sxs-lookup"><span data-stu-id="46188-223">This will reduce hash collisions.</span></span>  
  
### <a name="small-tables"></a><span data-ttu-id="46188-224">Tabelle di piccole dimensioni</span><span class="sxs-lookup"><span data-stu-id="46188-224">Small Tables</span></span>  
 <span data-ttu-id="46188-225">Per le tabelle più piccole, l'utilizzo della memoria non costituisce in genere un problema, perché le dimensioni dell'indice saranno ridotte rispetto alle dimensioni complessive del database.</span><span class="sxs-lookup"><span data-stu-id="46188-225">For smaller tables, memory utilization is usually not a concern, as the size of the index will be small compared to the overall size of the database.</span></span>  
  
 <span data-ttu-id="46188-226">È necessario operare una scelta in base al tipo di prestazioni desiderate:</span><span class="sxs-lookup"><span data-stu-id="46188-226">You must now make a choice based on the kind of performance you want:</span></span>  
  
-   <span data-ttu-id="46188-227">Se le operazioni critiche per le prestazioni nell'indice sono principalmente le ricerche di punti e/o le operazioni di inserimento, un numero di bucket elevato è più adatto per ridurre la probabilità di collisioni hash.</span><span class="sxs-lookup"><span data-stu-id="46188-227">If the performance-critical operations on the index are predominantly point lookups and/or insert operations, a higher bucket count would be appropriate to reduce the likelihood of hash collisions.</span></span> <span data-ttu-id="46188-228">La scelta ottimale sarà un valore pari a tre o più volte il numero di righe.</span><span class="sxs-lookup"><span data-stu-id="46188-228">Three times the number of rows or even more would be the best option.</span></span>  
  
-   <span data-ttu-id="46188-229">Se le scansioni complete dell'indice sono le operazioni critiche per le prestazioni più frequenti, utilizzare un numero di bucket simile al numero effettivo dei valori di chiave di indice.</span><span class="sxs-lookup"><span data-stu-id="46188-229">If full index scans are the predominant performance-critical operations, use a bucket count that is close to the actual number of index key values.</span></span>  
  
### <a name="big-tables"></a><span data-ttu-id="46188-230">Tabelle di grandi dimensioni</span><span class="sxs-lookup"><span data-stu-id="46188-230">Big Tables</span></span>  
 <span data-ttu-id="46188-231">Per le tabelle di grandi dimensioni, l'utilizzo della memoria può costituire un problema.</span><span class="sxs-lookup"><span data-stu-id="46188-231">For large tables, memory utilization could become a concern.</span></span> <span data-ttu-id="46188-232">Ad esempio, con una tabella di 250 milioni righe con 4 indici hash, ognuno con un numero di bucket pari a 1 miliardo, l'overhead per le tabelle hash è 4 indici \* 1 miliardo bucket \* 8 byte = 32 gigabyte di utilizzo della memoria.</span><span class="sxs-lookup"><span data-stu-id="46188-232">For example, with a 250 million row table that has 4 hash indexes, each with a bucket count of one billion, the overhead for the hash tables is 4 indexes \* 1 billion buckets \* 8 bytes = 32 gigabytes of memory utilization.</span></span> <span data-ttu-id="46188-233">Quando si sceglie un numero di bucket di 250 milioni per ciascun indice, l'overhead totale per le tabelle hash sarà di 8 GB.</span><span class="sxs-lookup"><span data-stu-id="46188-233">When choosing a bucket count of 250 million for each of the indexes, the total overhead for the hash tables will be 8 gigabytes.</span></span> <span data-ttu-id="46188-234">Si noti che questo è in aggiunta agli 8 byte di utilizzo della memoria, ogni indice aggiunge a ogni singola riga, ovvero 8 gigabyte in questo scenario (4 indici \* 8 byte \* 250 milioni righe).</span><span class="sxs-lookup"><span data-stu-id="46188-234">Note that this is in addition to the 8 bytes of memory usage each index adds to each individual row, which is 8 gigabytes in this scenario (4 indexes \* 8 bytes \* 250 million rows).</span></span>  
  
 <span data-ttu-id="46188-235">Le scansioni complete delle tabelle non fanno in genere parte del percorso critico per le prestazioni per i carichi di lavoro OLTP.</span><span class="sxs-lookup"><span data-stu-id="46188-235">Full table scans are not usually in the performance-critical path for OLTP workloads.</span></span> <span data-ttu-id="46188-236">Pertanto, occorre scegliere tra l'utilizzo della memoria e le prestazioni della operazioni di ricerca di punti e di inserimento:</span><span class="sxs-lookup"><span data-stu-id="46188-236">Therefore, the choice is between memory utilization versus performance of point lookup and insert operations:</span></span>  
  
-   <span data-ttu-id="46188-237">Se l'utilizzo della memoria rappresenta un problema, scegliere un numero di bucket simile al numero dei valori di chiave di indice.</span><span class="sxs-lookup"><span data-stu-id="46188-237">If memory utilization is a concern, choose a bucket count close to the number of index key values.</span></span> <span data-ttu-id="46188-238">Il numero di bucket non deve essere notevolmente inferiore al numero di valori di chiave di indice, in quanto ciò influisce sulla maggior parte delle operazioni DML nonché sul tempo necessario per il recupero del database dopo il riavvio del server.</span><span class="sxs-lookup"><span data-stu-id="46188-238">The bucket count should not be significantly lower than the number of index key values, as this impacts most DML operations as well the time it takes to recover the database after server restart.</span></span>  
  
-   <span data-ttu-id="46188-239">Per ottimizzare le prestazioni per le ricerche di punti, è consigliabile un numero di bucket superiore di due o persino tre volte al numero di valori di indice univoci.</span><span class="sxs-lookup"><span data-stu-id="46188-239">When optimizing the performance for point lookups, a higher bucket count of two or even three times the number of unique index values would be appropriate.</span></span> <span data-ttu-id="46188-240">Un numero di bucket più alto comporterebbe un aumento dell'utilizzo della memoria e del tempo richiesto per un'analisi completa dell'indice.</span><span class="sxs-lookup"><span data-stu-id="46188-240">A higher bucket count would mean an increased memory utilization and an increase in the time required for a full index scan.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="46188-241">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="46188-241">See Also</span></span>  
 [<span data-ttu-id="46188-242">Indici in tabelle con ottimizzazione per la memoria</span><span class="sxs-lookup"><span data-stu-id="46188-242">Indexes on Memory-Optimized Tables</span></span>](../../2014/database-engine/indexes-on-memory-optimized-tables.md)  
  
  
