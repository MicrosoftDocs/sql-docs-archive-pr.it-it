---
title: Guida per la progettazione di indici di SQL Server | Microsoft Docs
ms.custom: ''
ms.date: 06/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
ms.assetid: b856ee9a-49e7-4fab-a88d-48a633fce269
author: rothja
ms.author: jroth
ms.openlocfilehash: 1f5ad72413fe71004fb1c5f125969b984db815d3
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/04/2020
ms.locfileid: "87624456"
---
# <a name="sql-server-index-design-guide"></a><span data-ttu-id="2bb2c-102">Guida per la progettazione di indici di SQL Server</span><span class="sxs-lookup"><span data-stu-id="2bb2c-102">SQL Server Index Design Guide</span></span>

  <span data-ttu-id="2bb2c-103">Gli indici progettati in modo non corretto e la mancanza di indici costituiscono le cause principali dei colli di bottiglia delle applicazioni di database.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-103">Poorly designed indexes and a lack of indexes are primary sources of database application bottlenecks.</span></span> <span data-ttu-id="2bb2c-104">La progettazione di indici efficienti è fondamentale per ottenere buone prestazioni del database e dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-104">Designing efficient indexes is paramount to achieving good database and application performance.</span></span> <span data-ttu-id="2bb2c-105">In questa guida per la progettazione di indici di SQL Server sono contenute informazioni e procedure consigliate che consentono di progettare indici validi per soddisfare le esigenze dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-105">This SQL Server index design guide contains information and best practices to help you design effective indexes to meet the needs of your application.</span></span>  
  
<span data-ttu-id="2bb2c-106">**Si applica a**: [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] tramite, [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] se non specificato diversamente.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-106">**Applies to**: [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] through [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] unless noted otherwise.</span></span>  
  
 <span data-ttu-id="2bb2c-107">In questa guida si presuppone che il lettore conosca i tipi di indice disponibili in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="2bb2c-107">This guide assumes the reader has a general understanding of the index types available in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="2bb2c-108">Per una descrizione generale dei tipi di indice, vedere [Tipi di indice](../relational-databases/indexes/indexes.md).</span><span class="sxs-lookup"><span data-stu-id="2bb2c-108">For a general description of index types, see [Index Types](../relational-databases/indexes/indexes.md).</span></span>  
  
##  <a name="in-this-guide"></a><a name="Top"></a><span data-ttu-id="2bb2c-109">Contenuto della Guida</span><span class="sxs-lookup"><span data-stu-id="2bb2c-109">In This Guide</span></span>  

 [<span data-ttu-id="2bb2c-110">Nozioni fondamentali sulla progettazione di indici</span><span class="sxs-lookup"><span data-stu-id="2bb2c-110">Index Design Basics</span></span>](#Basics)  
  
 [<span data-ttu-id="2bb2c-111">Linee guida generali per la progettazione degli indici</span><span class="sxs-lookup"><span data-stu-id="2bb2c-111">General Index Design Guidelines</span></span>](#General_Design)  
  
 [<span data-ttu-id="2bb2c-112">Linee guida per la progettazione di indici cluster</span><span class="sxs-lookup"><span data-stu-id="2bb2c-112">Clustered Index Design Guidelines</span></span>](#Clustered)  
  
 [<span data-ttu-id="2bb2c-113">Linee guida per la progettazione di indici non cluster</span><span class="sxs-lookup"><span data-stu-id="2bb2c-113">Nonclustered Index Design Guidelines</span></span>](#Nonclustered)  
  
 [<span data-ttu-id="2bb2c-114">Linee guida di progettazione di indici univoci</span><span class="sxs-lookup"><span data-stu-id="2bb2c-114">Unique Index Design Guidelines</span></span>](#Unique)  
  
 [<span data-ttu-id="2bb2c-115">Linee guida sulla progettazione di indici filtrati</span><span class="sxs-lookup"><span data-stu-id="2bb2c-115">Filtered Index Design Guidelines</span></span>](#Filtered)  
  
 [<span data-ttu-id="2bb2c-116">Letture aggiuntive</span><span class="sxs-lookup"><span data-stu-id="2bb2c-116">Additional Reading</span></span>](#Additional_Reading)  
  
##  <a name="index-design-basics"></a><a name="Basics"></a> <span data-ttu-id="2bb2c-117">Nozioni fondamentali sulla progettazione di indici</span><span class="sxs-lookup"><span data-stu-id="2bb2c-117">Index Design Basics</span></span>  

 <span data-ttu-id="2bb2c-118">Un indice è una struttura su disco associata a una tabella o a una vista che consente di recuperare in modo rapido le righe della tabella o della vista.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-118">An index is an on-disk structure associated with a table or view that speeds retrieval of rows from the table or view.</span></span> <span data-ttu-id="2bb2c-119">L'indice contiene chiavi costituite da una o più colonne della tabella o della vista.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-119">An index contains keys built from one or more columns in the table or view.</span></span> <span data-ttu-id="2bb2c-120">Queste chiavi vengono archiviate in una struttura (albero B) che consente a SQL Server di individuare con rapidità ed efficienza la riga o le righe associate ai valori di chiave.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-120">These keys are stored in a structure (B-tree) that enables SQL Server to find the row or rows associated with the key values quickly and efficiently.</span></span>  
  
 <span data-ttu-id="2bb2c-121">La selezione degli indici adatti a un database e al relativo carico di lavoro è un'operazione complessa che comporta la ricerca di un equilibrio tra velocità delle query e costi di aggiornamento.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-121">The selection of the right indexes for a database and its workload is a complex balancing act between query speed and update cost.</span></span> <span data-ttu-id="2bb2c-122">Gli indici limitati, ovvero con poche colonne nella chiave di indice, richiedono meno spazio su disco e overhead di gestione.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-122">Narrow indexes, or indexes with few columns in the index key, require less disk space and maintenance overhead.</span></span> <span data-ttu-id="2bb2c-123">Gli indici estesi, d'altra parte, coprono più query.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-123">Wide indexes, on the other hand, cover more queries.</span></span> <span data-ttu-id="2bb2c-124">Potrebbe essere necessario sperimentare diverse soluzioni prima di trovare l'indice più efficiente.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-124">You may have to experiment with several different designs before finding the most efficient index.</span></span> <span data-ttu-id="2bb2c-125">È possibile aggiungere, modificare ed eliminare indici senza modificare lo schema del database o la struttura dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-125">Indexes can be added, modified, and dropped without affecting the database schema or application design.</span></span> <span data-ttu-id="2bb2c-126">È pertanto opportuno sperimentare il funzionamento di vari tipi di indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-126">Therefore, you should not hesitate to experiment with different indexes.</span></span>  
  
 <span data-ttu-id="2bb2c-127">Query Optimizer in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] consente di scegliere in modo affidabile l'indice più efficace nella maggior parte dei casi.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-127">The query optimizer in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] reliably chooses the most effective index in the vast majority of cases.</span></span> <span data-ttu-id="2bb2c-128">La strategia globale di progettazione dell'indice deve offrire a Query Optimizer un'ampia gamma di indici tra cui scegliere e fare affidamento su questo strumento per la scelta.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-128">Your overall index design strategy should provide a variety of indexes for the query optimizer to choose from and trust it to make the right decision.</span></span> <span data-ttu-id="2bb2c-129">In questo modo, è possibile ridurre i tempi di analisi e garantire buone prestazioni in numerose situazioni.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-129">This reduces analysis time and produces good performance over a variety of situations.</span></span> <span data-ttu-id="2bb2c-130">Per visualizzare gli indici usati da Query Optimizer per una query specifica, in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]scegliere **Includi piano di esecuzione effettivo** dal menu **Query**.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-130">To see which indexes the query optimizer uses for a specific query, in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], on the **Query** menu, select **Include Actual Execution Plan**.</span></span>  
  
 <span data-ttu-id="2bb2c-131">L'utilizzo di indici non consente necessariamente di ottenere prestazioni ottimali e prestazioni ottimali non sempre sono da mettere in relazione all'utilizzo di indici.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-131">Do not always equate index usage with good performance, and good performance with efficient index use.</span></span> <span data-ttu-id="2bb2c-132">Se l'utilizzo di un indice garantisse sempre le prestazioni migliori, il processo di Query Optimizer risulterebbe semplice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-132">If using an index always helped produce the best performance, the job of the query optimizer would be simple.</span></span> <span data-ttu-id="2bb2c-133">In realtà, una scelta non corretta di un indice può portare a prestazioni per niente ottimali.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-133">In reality, an incorrect index choice can cause less than optimal performance.</span></span> <span data-ttu-id="2bb2c-134">L'attività di Query Optimizer consiste pertanto nel selezionare un indice, o una combinazione di indici, solo quando questo comporta un miglioramento delle prestazioni e nell'evitare il recupero indicizzato quando ciò potrebbe avere conseguenze negative sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-134">Therefore, the task of the query optimizer is to select an index, or combination of indexes, only when it will improve performance, and to avoid indexed retrieval when it will hinder performance.</span></span>  
  
### <a name="index-design-tasks"></a><span data-ttu-id="2bb2c-135">Attività di progettazione di indici</span><span class="sxs-lookup"><span data-stu-id="2bb2c-135">Index Design Tasks</span></span>  

 <span data-ttu-id="2bb2c-136">Le attività seguenti costituiscono la strategia consigliata per la progettazione di indici:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-136">The follow tasks make up our recommended strategy for designing indexes:</span></span>  
  
1.  <span data-ttu-id="2bb2c-137">Comprendere le caratteristiche del database.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-137">Understand the characteristics of the database itself.</span></span> <span data-ttu-id="2bb2c-138">Stabilire, ad esempio, se si tratta di un database OLTP (Online Transaction Processing) in cui avvengono frequenti modifiche dei dati o di un database DSS (Decision Support System) o di data warehouse (OLAP) contenente principalmente dati di sola lettura e tramite cui è necessario elaborare rapidamente set di dati di grandi dimensioni.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-138">For example, is it an online transaction processing (OLTP) database with frequent data modifications, or a Decision Support System (DSS) or data warehousing (OLAP) database that contains primarily read-only data and must process very large data sets quickly.</span></span> <span data-ttu-id="2bb2c-139">In [!INCLUDE[ssSQL11](../includes/sssql11-md.md)]l'indice *columnstore con ottimizzazione per la memoria di xVelocity* è particolarmente appropriato per set di dati di data warehousing tipici.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-139">In [!INCLUDE[ssSQL11](../includes/sssql11-md.md)], *xVelocity memory optimized columnstore* index is especially appropriate for typical data warehousing data sets.</span></span> <span data-ttu-id="2bb2c-140">Gli indici columnstore possono trasformare l'ambiente di data warehousing per gli utenti consentendo prestazioni più veloci per le query di data warehousing comuni quali quelle di filtro, aggregazione, raggruppamento e join a stella.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-140">Columnstore indexes can transform the data warehousing experience for users by enabling faster performance for common data warehousing queries such as filtering, aggregating, grouping, and star-join queries.</span></span> <span data-ttu-id="2bb2c-141">Per altre informazioni, vedere gli [indici columnstore descritti](../relational-databases/indexes/columnstore-indexes-described.md).</span><span class="sxs-lookup"><span data-stu-id="2bb2c-141">For more information, see [Columnstore Indexes Described](../relational-databases/indexes/columnstore-indexes-described.md).</span></span>  
  
2.  <span data-ttu-id="2bb2c-142">Comprendere le caratteristiche delle query utilizzate più di frequente.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-142">Understand the characteristics of the most frequently used queries.</span></span> <span data-ttu-id="2bb2c-143">Se, ad esempio, si stabilisce che una query utilizzata di frequente unisce in join due o più tabelle, è possibile determinare il tipo più adatto di indici da utilizzare.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-143">For example, knowing that a frequently used query joins two or more tables will help you determine the best type of indexes to use.</span></span>  
  
3.  <span data-ttu-id="2bb2c-144">Comprendere le caratteristiche delle colonne utilizzate nelle query.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-144">Understand the characteristics of the columns used in the queries.</span></span> <span data-ttu-id="2bb2c-145">Un indice è ad esempio ideale per colonne con tipo di dati integer e univoche o non Null.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-145">For example, an index is ideal for columns that have an integer data type and are also unique or nonnull columns.</span></span> <span data-ttu-id="2bb2c-146">Per colonne con subset di dati ben definiti, è possibile utilizzare un indice filtrato in [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] e versioni successive.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-146">For columns that have well-defined subsets of data, you can use a filtered index in [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] and higher versions.</span></span> <span data-ttu-id="2bb2c-147">Per altre informazioni, vedere [Linee guida per la progettazione di indici filtrati](#Filtered) in questa guida.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-147">For more information, see [Filtered Index Design Guidelines](#Filtered) in this guide.</span></span>  
  
4.  <span data-ttu-id="2bb2c-148">Determinare quali opzioni dell'indice potrebbero migliorare le prestazioni in fase di creazione o manutenzione dell'indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-148">Determine which index options might enhance performance when the index is created or maintained.</span></span> <span data-ttu-id="2bb2c-149">Per la creazione, ad esempio, di un indice cluster in una tabella esistente di grandi dimensioni può essere utile utilizzare l'opzione ONLINE.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-149">For example, creating a clustered index on an existing large table would benefit from the ONLINE index option.</span></span> <span data-ttu-id="2bb2c-150">Tale opzione consente l'esecuzione di attività simultanee sui dati sottostanti durante la creazione o la ricompilazione dell'indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-150">The ONLINE option allows for concurrent activity on the underlying data to continue while the index is being created or rebuilt.</span></span> <span data-ttu-id="2bb2c-151">Per altre informazioni vedere [Impostare le opzioni di indice](../relational-databases/indexes/set-index-options.md).</span><span class="sxs-lookup"><span data-stu-id="2bb2c-151">For more information, see [Set Index Options](../relational-databases/indexes/set-index-options.md).</span></span>  
  
5.  <span data-ttu-id="2bb2c-152">Determinare il percorso di archiviazione ottimale per l'indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-152">Determine the optimal storage location for the index.</span></span> <span data-ttu-id="2bb2c-153">Un indice non cluster può essere archiviato nello stesso filegroup della tabella sottostante oppure in un filegroup diverso.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-153">A nonclustered index can be stored in the same filegroup as the underlying table, or on a different filegroup.</span></span> <span data-ttu-id="2bb2c-154">Il percorso di archiviazione degli indici può consentire di migliorare le prestazioni di esecuzione delle query grazie a un aumento delle prestazioni di I/O su disco.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-154">The storage location of indexes can improve query performance by increasing disk I/O performance.</span></span> <span data-ttu-id="2bb2c-155">L'archiviazione, ad esempio, di un indice non cluster in un filegroup in un disco diverso rispetto al filegroup della tabella può consentire di migliorare le prestazioni in quanto è possibile leggere più dischi contemporaneamente.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-155">For example, storing a nonclustered index on a filegroup that is on a different disk than the table filegroup can improve performance because multiple disks can be read at the same time.</span></span>  
  
     <span data-ttu-id="2bb2c-156">In alternativa, per gli indici cluster e non cluster è possibile utilizzare uno schema di partizione in più filegroup.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-156">Alternatively, clustered and nonclustered indexes can use a partition scheme across multiple filegroups.</span></span> <span data-ttu-id="2bb2c-157">Il partizionamento semplifica la gestione di tabelle o indici di grandi dimensioni in quanto consente di gestire o accedere a subset di dati in modo rapido ed efficace mantenendo l'integrità della raccolta.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-157">Partitioning makes large tables or indexes more manageable by letting you access or manage subsets of data quickly and efficiently, while maintaining the integrity of the overall collection.</span></span> <span data-ttu-id="2bb2c-158">Per ulteriori informazioni, vedere [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span><span class="sxs-lookup"><span data-stu-id="2bb2c-158">For more information, see [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span></span> <span data-ttu-id="2bb2c-159">Quando si considera il partizionamento, determinare se è necessario che l'indice sia allineato, ovvero partizionato nello stesso modo della tabella, o partizionato in modo indipendente.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-159">When you consider partitioning, determine whether the index should be aligned, that is, partitioned in essentially the same manner as the table, or partitioned independently.</span></span>  
  
##  <a name="general-index-design-guidelines"></a><a name="General_Design"></a> <span data-ttu-id="2bb2c-160">Linee guida generali per la progettazione di indici</span><span class="sxs-lookup"><span data-stu-id="2bb2c-160">General Index Design Guidelines</span></span>  

 <span data-ttu-id="2bb2c-161">Gli amministratori di database esperti in genere sono in grado di progettare un set di indici adeguato, ma questa attività è molto complessa, richiede tempo ed è soggetta ad errori anche nel caso di database e carichi di lavoro di media complessità.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-161">Experienced database administrators can design a good set of indexes, but this task is very complex, time-consuming, and error-prone even for moderately complex databases and workloads.</span></span> <span data-ttu-id="2bb2c-162">Conoscere le caratteristiche del database, delle query e delle colonne di dati può aiutare a progettare indici ottimali.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-162">Understanding the characteristics of your database, queries, and data columns can help you design optimal indexes.</span></span>  
  
### <a name="database-considerations"></a><span data-ttu-id="2bb2c-163">Considerazioni sui database</span><span class="sxs-lookup"><span data-stu-id="2bb2c-163">Database Considerations</span></span>  

 <span data-ttu-id="2bb2c-164">Quando si progetta un indice è consigliabile attenersi alle linee guida seguenti sui database:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-164">When you design an index, consider the following database guidelines:</span></span>  
  
-   <span data-ttu-id="2bb2c-165">Un numero elevato di indici in una tabella ha ripercussioni sulle prestazioni delle istruzioni INSERT, UPDATE, DELETE e MERGE perché, quando vengono modificati i dati nella tabella, tutti gli indici devono essere modificati di conseguenza.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-165">Large numbers of indexes on a table affect the performance of INSERT, UPDATE, DELETE, and MERGE statements because all indexes must be adjusted appropriately as data in the table changes.</span></span> <span data-ttu-id="2bb2c-166">Ad esempio, se una colonna viene utilizzata in molti indici e si esegue un'istruzione UPDATE tramite cui i dati della colonna vengono modificati, ogni indice contenente la colonna in questione deve essere aggiornato, nonché la colonna nella tabella di base sottostante (heap o indice cluster).</span><span class="sxs-lookup"><span data-stu-id="2bb2c-166">For example, if a column is used in several indexes and you execute an UPDATE statement that modifies that column's data, each index that contains that column must be updated as well as the column in the underlying base table (heap or clustered index).</span></span>  
  
    -   <span data-ttu-id="2bb2c-167">Evitare di creare un numero eccessivo di indici in tabelle che vengono aggiornate spesso e mantenere indici di piccole dimensioni, vale a dire con il minor numero possibile di colonne.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-167">Avoid over-indexing heavily updated tables and keep indexes narrow, that is, with as few columns as possible.</span></span>  
  
    -   <span data-ttu-id="2bb2c-168">Utilizzare molti indici per migliorare le prestazioni delle query nelle tabelle che vengono aggiornate raramente ma che contengono grandi volumi di dati.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-168">Use many indexes to improve query performance on tables with low update requirements, but large volumes of data.</span></span> <span data-ttu-id="2bb2c-169">Un numero elevato di indici può contribuire a migliorare le prestazioni delle query che non modificano i dati, ad esempio delle istruzioni SELECT, perché Query Optimizer può scegliere fra un numero maggiore di indici per determinare il metodo di accesso più rapido.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-169">Large numbers of indexes can help the performance of queries that do not modify data, such as SELECT statements, because the query optimizer has more indexes to choose from to determine the fastest access method.</span></span>  
  
-   <span data-ttu-id="2bb2c-170">L'indicizzazione di tabelle di piccole dimensioni può non risultare ottimale, perché Query Optimizer impiega più tempo per scorrere l'indice cercando i dati che per eseguire una semplice scansione della tabella.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-170">Indexing small tables may not be optimal because it can take the query optimizer longer to traverse the index searching for data than to perform a simple table scan.</span></span> <span data-ttu-id="2bb2c-171">Pertanto, può accadere che gli indici delle tabelle di piccole dimensioni non vengano mai utilizzati, ma devono comunque essere gestiti in caso di modifica dei dati della tabella.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-171">Therefore, indexes on small tables might never be used, but must still be maintained as data in the table changes.</span></span>  
  
-   <span data-ttu-id="2bb2c-172">Gli indici nelle viste possono garantire miglioramenti significativi delle prestazioni quando la vista contiene aggregazioni, join di tabella o una combinazione di aggregazioni e join.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-172">Indexes on views can provide significant performance gains when the view contains aggregations, table joins, or a combination of aggregations and joins.</span></span> <span data-ttu-id="2bb2c-173">Non è necessario che venga fatto riferimento esplicito alla vista nella query affinché Query Optimizer la utilizzi.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-173">The view does not have to be explicitly referenced in the query for the query optimizer to use it.</span></span>  
  
-   <span data-ttu-id="2bb2c-174">Utilizzare Ottimizzazione guidata motore di database per analizzare il database e raccogliere informazioni per gli indici.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-174">Use the Database Engine Tuning Advisor to analyze your database and make index recommendations.</span></span> <span data-ttu-id="2bb2c-175">Per altre informazioni, vedere [Database Engine Tuning Advisor](../relational-databases/performance/database-engine-tuning-advisor.md).</span><span class="sxs-lookup"><span data-stu-id="2bb2c-175">For more information, see [Database Engine Tuning Advisor](../relational-databases/performance/database-engine-tuning-advisor.md).</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="2bb2c-176">Considerazioni sulle query</span><span class="sxs-lookup"><span data-stu-id="2bb2c-176">Query Considerations</span></span>  

 <span data-ttu-id="2bb2c-177">Quando si progetta un indice è consigliabile attenersi alle linee guida seguenti sulle query:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-177">When you design an index, consider the following query guidelines:</span></span>  
  
-   <span data-ttu-id="2bb2c-178">Creare indici non cluster nelle colonne che vengono utilizzate spesso in predicati e condizioni di join nelle query.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-178">Create nonclustered indexes on the columns that are frequently used in predicates and join conditions in queries.</span></span> <span data-ttu-id="2bb2c-179">Tuttavia, è consigliabile non aggiungere colonne non necessarie.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-179">However, you should avoid adding unnecessary columns.</span></span> <span data-ttu-id="2bb2c-180">L'aggiunta di un numero eccessivo di colonne di indice può avere effetti negativi sullo spazio su disco e sulle prestazioni per la gestione degli indici.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-180">Adding too many index columns can adversely affect disk space and index maintenance performance.</span></span>  
  
-   <span data-ttu-id="2bb2c-181">Gli indici di copertura possono migliorare le prestazioni delle query, perché tutti i dati necessari per soddisfare i requisiti della query esistono all'interno dell'indice stesso.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-181">Covering indexes can improve query performance because all the data needed to meet the requirements of the query exists within the index itself.</span></span> <span data-ttu-id="2bb2c-182">In altre parole, per recuperare i dati richiesti sono necessarie solo le pagine di indice, e non le pagine di dati della tabella o dell'indice cluster. Viene dunque ridotto l'I/O complessivo del disco.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-182">That is, only the index pages, and not the data pages of the table or clustered index, are required to retrieve the requested data; therefore, reducing overall disk I/O.</span></span> <span data-ttu-id="2bb2c-183">Una query di colonne **a** e **b** in una tabella con un indice composto creato nelle colonne **a**, **b**e **c** può recuperare i dati specificati dall'indice solo.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-183">For example, a query of columns **a** and **b** on a table that has a composite index created on columns **a**, **b**, and **c** can retrieve the specified data from the index alone.</span></span>  
  
-   <span data-ttu-id="2bb2c-184">Scrivere query che inseriscono o modificano il numero più alto possibile di righe con una sola istruzione, anziché utilizzare più query per aggiornare le stesse righe.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-184">Write queries that insert or modify as many rows as possible in a single statement, instead of using multiple queries to update the same rows.</span></span> <span data-ttu-id="2bb2c-185">L'utilizzo di una sola istruzione consente di avvalersi della gestione ottimizzata degli indici.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-185">By using only one statement, optimized index maintenance could be exploited.</span></span>  
  
-   <span data-ttu-id="2bb2c-186">Valutare il tipo di query e la modalità di utilizzo delle colonne nella query.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-186">Evaluate the query type and how columns are used in the query.</span></span> <span data-ttu-id="2bb2c-187">Una colonna utilizzata in un tipo di query di corrispondenze esatte, ad esempio, potrebbe essere valida per un indice non cluster o cluster.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-187">For example, a column used in an exact-match query type would be a good candidate for a nonclustered or clustered index.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="2bb2c-188">Considerazioni sulle colonne</span><span class="sxs-lookup"><span data-stu-id="2bb2c-188">Column Considerations</span></span>  

 <span data-ttu-id="2bb2c-189">Quando si progetta un indice è consigliabile attenersi alle linee guidata seguenti:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-189">When you design an index consider the following column guidelines:</span></span>  
  
-   <span data-ttu-id="2bb2c-190">Mantenere corta la chiave dell'indice negli indici cluster.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-190">Keep the length of the index key short for clustered indexes.</span></span> <span data-ttu-id="2bb2c-191">Inoltre, è consigliabile creare gli indici cluster su colonne univoche o non Null.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-191">Additionally, clustered indexes benefit from being created on unique or nonnull columns.</span></span>  
  
-   <span data-ttu-id="2bb2c-192">Non è possibile specificare come colonne chiave indice le colonne di tipo `ntext`, `text`, `image`, `varchar(max)`, `nvarchar(max)` e `varbinary(max)`.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-192">Columns that are of the `ntext`, `text`, `image`, `varchar(max)`, `nvarchar(max)`, and `varbinary(max)` data types cannot be specified as index key columns.</span></span> <span data-ttu-id="2bb2c-193">Tuttavia, i tipi di dati `varchar(max)`, `nvarchar(max)`, `varbinary(max)` e `xml` possono partecipare a un indice non cluster come colonne non chiave dell'indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-193">However, `varchar(max)`, `nvarchar(max)`, `varbinary(max)`, and `xml` data types can participate in a nonclustered index as nonkey index columns.</span></span> <span data-ttu-id="2bb2c-194">Per altre informazioni, vedere la sezione " [Indice con colonne incluse](#Included_Columns)" in questa guida.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-194">For more information, see the section ['Index with Included Columns](#Included_Columns)' in this guide.</span></span>  
  
-   <span data-ttu-id="2bb2c-195">Un tipo di dati `xml` può essere solo una colonna chiave solo in un indice XML.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-195">An `xml` data type can only be a key column only in an XML index.</span></span> <span data-ttu-id="2bb2c-196">Per altre informazioni, vedere [Indici XML &#40;SQL Server&#41;](../relational-databases/xml/xml-indexes-sql-server.md).</span><span class="sxs-lookup"><span data-stu-id="2bb2c-196">For more information, see [XML Indexes &#40;SQL Server&#41;](../relational-databases/xml/xml-indexes-sql-server.md).</span></span> <span data-ttu-id="2bb2c-197">In SQL Server 2012 SP1 viene introdotto un nuovo tipo di indice XML noto come indice XML selettivo.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-197">SQL Server 2012 SP1 introduces a new type of XML index known as a Selective XML Index.</span></span> <span data-ttu-id="2bb2c-198">Grazie al nuovo indice potranno essere migliorate le prestazioni di esecuzione delle query sui dati archiviati come XML in SQL Server, pertanto sarà possibile un'indicizzazione molto più rapida di carichi di lavoro di dati XML di grandi dimensioni, nonché un miglioramento della scalabilità riducendo i costi di archiviazione dell'indice stesso.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-198">This new index can improve querying performance over data stored as XML in SQL Server, allow for much faster indexing of large XML data workloads, and improve scalability by reducing storage costs of the index itself.</span></span> <span data-ttu-id="2bb2c-199">Per altre informazioni vedere [Indici XML selettivi &#40;SXI&#41;](../relational-databases/xml/selective-xml-indexes-sxi.md).</span><span class="sxs-lookup"><span data-stu-id="2bb2c-199">For more information, see [Selective XML Indexes &#40;SXI&#41;](../relational-databases/xml/selective-xml-indexes-sxi.md).</span></span>  
  
-   <span data-ttu-id="2bb2c-200">Esaminare l'univocità delle colonne.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-200">Examine column uniqueness.</span></span> <span data-ttu-id="2bb2c-201">Un indice univoco al posto di un indice non univoco nella stessa combinazione di colonne fornisce informazioni aggiuntive per Query Optimizer, che rendono l'indice più utile.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-201">A unique index instead of a nonunique index on the same combination of columns provides additional information for the query optimizer that makes the index more useful.</span></span> <span data-ttu-id="2bb2c-202">Per altre informazioni, vedere [Linee guida per la progettazione di indici univoci](#Unique) in questa guida.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-202">For more information, see [Unique Index Design Guidelines](#Unique) in this guide.</span></span>  
  
-   <span data-ttu-id="2bb2c-203">Esaminare la distribuzione dei dati nelle colonne indicizzate.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-203">Examine data distribution in the column.</span></span> <span data-ttu-id="2bb2c-204">Spesso l'esecuzione prolungata di una query deriva dall'indicizzazione di una colonna con pochi valori univoci o dall'esecuzione di un join su tale colonna.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-204">Frequently, a long-running query is caused by indexing a column with few unique values, or by performing a join on such a column.</span></span> <span data-ttu-id="2bb2c-205">Questo problema fondamentale relativo ai dati e alle query in genere non può essere risolto senza identificare questa situazione specifica.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-205">This is a fundamental problem with the data and query, and generally cannot be resolved without identifying this situation.</span></span> <span data-ttu-id="2bb2c-206">Ad esempio, in un elenco telefonico ordinato alfabeticamente in base al cognome non sarà possibile velocizzare la ricerca se i nomi di tutti gli abitanti della città sono Bianchi o Rossi.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-206">For example, a physical telephone directory sorted alphabetically on last name will not expedite locating a person if all people in the city are named Smith or Jones.</span></span> <span data-ttu-id="2bb2c-207">Per altre informazioni sulla distribuzione dei dati, vedere [Statistiche](../relational-databases/statistics/statistics.md).</span><span class="sxs-lookup"><span data-stu-id="2bb2c-207">For more information about data distribution, see [Statistics](../relational-databases/statistics/statistics.md).</span></span>  
  
-   <span data-ttu-id="2bb2c-208">È consigliabile utilizzare indici filtrati su colonne dispongono di subset ben definiti, ad esempio colonne di tipo sparse, colonne con la maggior parte di valori Null, colonne con categorie di valori e colonne con intervalli di valori distinti.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-208">Consider using filtered indexes on columns that have well-defined subsets, for example sparse columns, columns with mostly NULL values, columns with categories of values, and columns with distinct ranges of values.</span></span> <span data-ttu-id="2bb2c-209">Un indice filtrato progettato correttamente consente di migliorare le prestazioni di esecuzione delle query e di ridurre i costi di archiviazione e di manutenzione dell'indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-209">A well-designed filtered index can improve query performance, reduce index maintenance costs, and reduce storage costs.</span></span>  
  
-   <span data-ttu-id="2bb2c-210">Esaminare l'ordine delle colonne se l'indice conterrà più colonne.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-210">Consider the order of the columns if the index will contain multiple columns.</span></span> <span data-ttu-id="2bb2c-211">La colonna che viene utilizzata nella clausola WHERE in una condizione di ricerca uguale a (=), maggiore di (>), minore di (<) o BETWEEN oppure che partecipa a un join deve essere al primo posto.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-211">The column that is used in the WHERE clause in an equal to (=), greater than (>), less than (<), or BETWEEN search condition, or participates in a join, should be placed first.</span></span> <span data-ttu-id="2bb2c-212">Le altre colonne devono essere ordinate in base alla presenza di valori distinct, vale a dire da quella con più valori distinct a quella con meno valori distinct.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-212">Additional columns should be ordered based on their level of distinctness, that is, from the most distinct to the least distinct.</span></span>  
  
     <span data-ttu-id="2bb2c-213">Se, ad esempio, l'indice è definito come `LastName`, `FirstName` l'indice risulterà utile se il criterio di ricerca è `WHERE LastName = 'Smith'` o `WHERE LastName = Smith AND FirstName LIKE 'J%'`.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-213">For example, if the index is defined as `LastName`, `FirstName` the index will be useful when the search criterion is `WHERE LastName = 'Smith'` or `WHERE LastName = Smith AND FirstName LIKE 'J%'`.</span></span> <span data-ttu-id="2bb2c-214">Query Optimizer, tuttavia, non utilizzerebbe l'indice per una query che effettuasse la ricerca solo in base a `FirstName (WHERE FirstName = 'Jane')`.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-214">However, the query optimizer would not use the index for a query that searched only on `FirstName (WHERE FirstName = 'Jane')`.</span></span>  
  
-   <span data-ttu-id="2bb2c-215">Valutare l'opportunità di indicizzare colonne calcolate.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-215">Consider indexing computed columns.</span></span> <span data-ttu-id="2bb2c-216">Per altre informazioni, vedere [Indici per le colonne calcolate](../relational-databases/indexes/indexes-on-computed-columns.md).</span><span class="sxs-lookup"><span data-stu-id="2bb2c-216">For more information, see [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).</span></span>  
  
### <a name="index-characteristics"></a><span data-ttu-id="2bb2c-217">Caratteristiche degli indici</span><span class="sxs-lookup"><span data-stu-id="2bb2c-217">Index Characteristics</span></span>  

 <span data-ttu-id="2bb2c-218">Dopo avere determinato che un indice è adeguato per una query, è possibile scegliere il tipo di indice più adatto a seconda della situazione.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-218">After you have determined that an index is appropriate for a query, you can select the type of index that best fits your situation.</span></span> <span data-ttu-id="2bb2c-219">Le caratteristiche degli indici sono:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-219">Index characteristics include the following:</span></span>  
  
-   <span data-ttu-id="2bb2c-220">Cluster e non cluster</span><span class="sxs-lookup"><span data-stu-id="2bb2c-220">Clustered versus nonclustered</span></span>  
  
-   <span data-ttu-id="2bb2c-221">Univoci e non univoci</span><span class="sxs-lookup"><span data-stu-id="2bb2c-221">Unique versus nonunique</span></span>  
  
-   <span data-ttu-id="2bb2c-222">A colonna singola e a più colonne</span><span class="sxs-lookup"><span data-stu-id="2bb2c-222">Single column versus multicolumn</span></span>  
  
-   <span data-ttu-id="2bb2c-223">In ordine crescente o decrescente per le colonne dell'indice</span><span class="sxs-lookup"><span data-stu-id="2bb2c-223">Ascending or descending order on the columns in the index</span></span>  
  
-   <span data-ttu-id="2bb2c-224">Di tabella completa o filtrato per gli indici non cluster</span><span class="sxs-lookup"><span data-stu-id="2bb2c-224">Full-table versus filtered for nonclustered indexes</span></span>  
  
 <span data-ttu-id="2bb2c-225">È inoltre possibile personalizzare le caratteristiche iniziali dell'archiviazione dell'indice per ottimizzarne le prestazioni o la gestione impostando un'opzione quale FILLFACTOR.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-225">You can also customize the initial storage characteristics of the index to optimize its performance or maintenance by setting an option such as FILLFACTOR.</span></span> <span data-ttu-id="2bb2c-226">È inoltre possibile determinare la posizione di archiviazione dell'indice utilizzando filegroup o schemi di partizione per ottimizzare le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-226">Also, you can determine the index storage location by using filegroups or partition schemes to optimize performance.</span></span>  
  
###  <a name="index-placement-on-filegroups-or-partitions-schemes"></a><a name="Index_placement"></a> <span data-ttu-id="2bb2c-227">Posizione degli indici nei filegroup o negli schemi di partizioni</span><span class="sxs-lookup"><span data-stu-id="2bb2c-227">Index Placement on Filegroups or Partitions Schemes</span></span>  

 <span data-ttu-id="2bb2c-228">Durante lo sviluppo della strategia di progettazione degli indici, è opportuno considerare la posizione degli indici nei filegroup associati al database.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-228">As you develop your index design strategy, you should consider the placement of the indexes on the filegroups associated with the database.</span></span> <span data-ttu-id="2bb2c-229">Un'attenta selezione dello schema di filegroup o di partizione può contribuire a migliorare le prestazioni delle query.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-229">Careful selection of the filegroup or partition scheme can improve query performance.</span></span>  
  
 <span data-ttu-id="2bb2c-230">Per impostazione predefinita, gli indici vengono archiviati nello stesso filegroup della tabella di base in cui viene creato l'indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-230">By default, indexes are stored in the same filegroup as the base table on which the index is created.</span></span> <span data-ttu-id="2bb2c-231">Un indice cluster non partizionato e la tabella di base sono sempre inclusi nello stesso filegroup.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-231">A nonpartitioned clustered index and the base table always reside in the same filegroup.</span></span> <span data-ttu-id="2bb2c-232">È tuttavia possibile eseguire una delle operazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-232">However, you can do the following:</span></span>  
  
-   <span data-ttu-id="2bb2c-233">Creare indici non cluster in un filegroup diverso dal filegroup della tabella di base o un indice cluster.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-233">Create nonclustered indexes on a filegroup other than the filegroup of the base table or clustered index.</span></span>  
  
-   <span data-ttu-id="2bb2c-234">Partizionare indici cluster e non cluster tra più filegroup.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-234">Partition clustered and nonclustered indexes to span multiple filegroups.</span></span>  
  
-   <span data-ttu-id="2bb2c-235">Spostare una tabella da un filegroup a un altro eliminando l'indice cluster e specificando un nuovo schema di filegroup o di partizione nella clausola MOVE TO dell'istruzione DROP INDEX oppure utilizzando l'istruzione CREATE INDEX con la clausola DROP_EXISTING.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-235">Move a table from one filegroup to another by dropping the clustered index and specifying a new filegroup or partition scheme in the MOVE TO clause of the DROP INDEX statement or by using the CREATE INDEX statement with the DROP_EXISTING clause.</span></span>  
  
 <span data-ttu-id="2bb2c-236">La creazione dell'indice non cluster in un altro filegroup consente di migliorare le prestazioni se i filegroup utilizzano unità fisiche diverse con controller distinti.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-236">By creating the nonclustered index on a different filegroup, you can achieve performance gains if the filegroups are using different physical drives with their own controllers.</span></span> <span data-ttu-id="2bb2c-237">In tal caso, i dati e le informazioni degli indici possono essere letti in parallelo contemporaneamente da più testine.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-237">Data and index information can then be read in parallel by the multiple disk heads.</span></span> <span data-ttu-id="2bb2c-238">Ad esempio, se `Table_A` nel filegroup `f1` e `Index_A` nel filegroup `f2` vengono entrambi utilizzati dalla stessa query, è possibile che si riscontrino miglioramenti delle prestazioni, in quanto i filegroup vengono utilizzati integralmente senza contese.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-238">For example, if `Table_A` on filegroup `f1` and `Index_A` on filegroup `f2` are both being used by the same query, performance gains can be achieved because both filegroups are being fully used without contention.</span></span> <span data-ttu-id="2bb2c-239">Se invece tramite la query viene eseguita l'analisi di `Table_A` ma non è presente un riferimento a `Index_A` , verrà utilizzato solo il filegroup `f1` .</span><span class="sxs-lookup"><span data-stu-id="2bb2c-239">However, if `Table_A` is scanned by the query but `Index_A` is not referenced, only filegroup `f1` is used.</span></span> <span data-ttu-id="2bb2c-240">e non si otterrà un miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-240">This creates no performance gain.</span></span>  
  
 <span data-ttu-id="2bb2c-241">Non potendo prevedere il tipo di accesso e tantomeno il momento in cui questo si verifica, risulta più appropriato scegliere di suddividere le tabelle e gli indici tra tutti i filegroup.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-241">Because you cannot predict what type of access will occur and when it will occur, it could be a better decision to spread your tables and indexes across all filegroups.</span></span> <span data-ttu-id="2bb2c-242">Poiché tutti i dati e gli indici sono suddivisi equamente in tutti i dischi, l'accesso riguarderà tutti i dischi, indipendentemente dalla modalità di accesso.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-242">This would guarantee that all disks are being accessed because all data and indexes are spread evenly across all disks, regardless of which way the data is accessed.</span></span> <span data-ttu-id="2bb2c-243">Questo approccio è inoltre più semplice per gli amministratori del sistema.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-243">This is also a simpler approach for system administrators.</span></span>  
  
#### <a name="partitions-across-multiple-filegroups"></a><span data-ttu-id="2bb2c-244">Partizioni tra più filegroup</span><span class="sxs-lookup"><span data-stu-id="2bb2c-244">Partitions Across Multiple Filegroups</span></span>  

 <span data-ttu-id="2bb2c-245">È anche possibile scegliere di partizionare indici cluster e non cluster tra più filegroup.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-245">You can also consider partitioning clustered and nonclustered indexes across multiple filegroups.</span></span> <span data-ttu-id="2bb2c-246">Gli indici vengono partizionati in orizzontale, ovvero per riga, in base a una funzione di partizione.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-246">Partitioned indexes are partitioned horizontally, or by row, based on a partition function.</span></span> <span data-ttu-id="2bb2c-247">Tale funzione definisce la modalità di mapping di ciascuna riga a un set di partizioni sulla base dei valori di colonne specifiche, dette colonne di partizionamento.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-247">The partition function defines how each row is mapped to a set of partitions based on the values of certain columns, called partitioning columns.</span></span> <span data-ttu-id="2bb2c-248">Uno schema di partizione consente di specificare il mapping delle partizioni a un set di filegroup.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-248">A partition scheme specifies the mapping of the partitions to a set of filegroups.</span></span>  
  
 <span data-ttu-id="2bb2c-249">Il partizionamento di un indice può offrire i vantaggi seguenti:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-249">Partitioning an index can provide the following benefits:</span></span>  
  
-   <span data-ttu-id="2bb2c-250">Fornire sistemi scalabili per una maggior gestibilità degli indici di grandi dimensioni.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-250">Provide scalable systems that make large indexes more manageable.</span></span> <span data-ttu-id="2bb2c-251">I sistemi OLTP, ad esempio, possono implementare applicazioni che riconoscono le partizioni e gestiscono correttamente gli indici di grandi dimensioni.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-251">OLTP systems, for example, can implement partition-aware applications that deal with large indexes.</span></span>  
  
-   <span data-ttu-id="2bb2c-252">Rendere più rapida ed efficace l'esecuzione delle query.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-252">Make queries run faster and more efficiently.</span></span> <span data-ttu-id="2bb2c-253">Quando le query accedono a diverse partizioni di un indice, Query Optimizer è in grado di elaborare le singole partizioni contemporaneamente e di escludere quelle non interessate dalla query.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-253">When queries access several partitions of an index, the query optimizer can process individual partitions at the same time and exclude partitions that are not affected by the query.</span></span>  
  
 <span data-ttu-id="2bb2c-254">Per ulteriori informazioni, vedere [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span><span class="sxs-lookup"><span data-stu-id="2bb2c-254">For more information, see [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span></span>  
  
###  <a name="index-sort-order-design-guidelines"></a><a name="Sort_Order"></a> <span data-ttu-id="2bb2c-255">Linee guida per la progettazione dell'ordinamento dell'indice</span><span class="sxs-lookup"><span data-stu-id="2bb2c-255">Index Sort Order Design Guidelines</span></span>  

 <span data-ttu-id="2bb2c-256">Quando si definiscono gli indici, è necessario valutare se la colonna chiave dell'indice deve essere archiviata in ordine crescente o decrescente.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-256">When defining indexes, you should consider whether the data for the index key column should be stored in ascending or descending order.</span></span> <span data-ttu-id="2bb2c-257">L'ordine crescente rappresenta l'impostazione predefinita e consente di garantire la compatibilità con le versioni precedenti di [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="2bb2c-257">Ascending is the default and maintains compatibility with earlier versions of [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="2bb2c-258">La sintassi delle istruzioni CREATE INDEX, CREATE TABLE e ALTER TABLE supporta le parole chiave ASC (ascending, crescente) e DESC (descending, decrescente) per singole colonne di indici e vincoli.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-258">The syntax of the CREATE INDEX, CREATE TABLE, and ALTER TABLE statements supports the keywords ASC (ascending) and DESC (descending) on individual columns in indexes and constraints.</span></span>  
  
 <span data-ttu-id="2bb2c-259">È utile specificare l'ordine di archiviazione dei valori chiave in un indice nel caso in cui le query che fanno riferimento alla tabella includono clausole ORDER BY che specificano direzioni diverse per la colonna o le colonne chiave nell'indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-259">Specifying the order in which key values are stored in an index is useful when queries referencing the table have ORDER BY clauses that specify different directions for the key column or columns in that index.</span></span> <span data-ttu-id="2bb2c-260">In questi casi, l'indice non richiede un operatore SORT nel piano della query e pertanto la query risulta più efficiente.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-260">In these cases, the index can remove the need for a SORT operator in the query plan; therefore, this makes the query more efficient.</span></span> <span data-ttu-id="2bb2c-261">Gli acquirenti nel reparto acquisti di [!INCLUDE[ssSampleDBCoFull](../includes/sssampledbcofull-md.md)] , ad esempio, devono valutare la qualità dei prodotti acquistati dai fornitori.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-261">For example, the buyers in the [!INCLUDE[ssSampleDBCoFull](../includes/sssampledbcofull-md.md)] purchasing department have to evaluate the quality of products they purchase from vendors.</span></span> <span data-ttu-id="2bb2c-262">Gli acquirenti sono più interessati a trovare i prodotti inviati dai fornitori con una percentuale di resi maggiore.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-262">The buyers are most interested in finding products sent by these vendors with a high rejection rate.</span></span> <span data-ttu-id="2bb2c-263">Come illustrato nella query seguente, per recuperare i dati che soddisfano questo criterio è necessario che la colonna `RejectedQty` della tabella `Purchasing.PurchaseOrderDetail` sia disposta in ordine decrescente, ovvero dal valore più grande al più piccolo, e che la colonna `ProductID` sia disposta in ordine crescente, ovvero dal valore più piccolo al più grande.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-263">As shown in the following query, retrieving the data to meet this criteria requires the `RejectedQty` column in the `Purchasing.PurchaseOrderDetail` table to be sorted in descending order (large to small) and the `ProductID` column to be sorted in ascending order (small to large).</span></span>  
  
```sql
SELECT RejectedQty, ((RejectedQty/OrderQty)*100) AS RejectionRate,  
    ProductID, DueDate  
FROM Purchasing.PurchaseOrderDetail  
ORDER BY RejectedQty DESC, ProductID ASC;  
```  
  
 <span data-ttu-id="2bb2c-264">Il piano di esecuzione seguente per questa query mostra che in Query Optimizer viene utilizzato un operatore SORT per restituire il set di risultati nell'ordine specificato dalla clausola ORDER BY.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-264">The following execution plan for this query shows that the query optimizer used a SORT operator to return the result set in the order specified by the ORDER BY clause.</span></span>  
  
 <span data-ttu-id="2bb2c-265">![Il piano di esecuzione indica l'utilizzo di un operatore SORT](media/indexsort1.gif "Il piano di esecuzione indica l'utilizzo di un operatore SORT")</span><span class="sxs-lookup"><span data-stu-id="2bb2c-265">![Execution plan shows a SORT operator is used.](media/indexsort1.gif "Execution plan shows a SORT operator is used.")</span></span>  
  
 <span data-ttu-id="2bb2c-266">Se un indice viene creato con colonne chiave che corrispondono a quelle della clausola ORDER BY nella query, è possibile eliminare l'operatore SORT nel piano della query, migliorando l'efficienza della query.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-266">If an index is created with key columns that match those in the ORDER BY clause in the query, the SORT operator can be eliminated in the query plan and the query plan is more efficient.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX IX_PurchaseOrderDetail_RejectedQty  
ON Purchasing.PurchaseOrderDetail  
    (RejectedQty DESC, ProductID ASC, DueDate, OrderQty);  
```  
  
 <span data-ttu-id="2bb2c-267">Dopo che la query è stata eseguita di nuovo, il piano di esecuzione seguente mostra che l'operatore SORT è stato eliminato ed è stato utilizzato il nuovo indice non cluster creato.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-267">After the query is executed again, the following execution plan shows that the SORT operator has been eliminated and the newly created nonclustered index is used.</span></span>  
  
 <span data-ttu-id="2bb2c-268">![Il piano di esecuzione indica che non è usato un operatore SORT](media/insertsort2.gif "Il piano di esecuzione indica che non è usato un operatore SORT")</span><span class="sxs-lookup"><span data-stu-id="2bb2c-268">![Execution plan shows a SORT operator is not used](media/insertsort2.gif "Execution plan shows a SORT operator is not used")</span></span>  
  
 <span data-ttu-id="2bb2c-269">Il [!INCLUDE[ssDE](../includes/ssde-md.md)] consente di spostarsi con la stessa efficienza in entrambe le direzioni.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-269">The [!INCLUDE[ssDE](../includes/ssde-md.md)] can move equally efficiently in either direction.</span></span> <span data-ttu-id="2bb2c-270">Un indice definito come `(RejectedQty DESC, ProductID ASC)` può comunque essere utilizzato per una query in cui l'ordinamento delle colonne nella clausola ORDER BY viene invertito.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-270">An index defined as `(RejectedQty DESC, ProductID ASC)` can still be used for a query in which the sort direction of the columns in the ORDER BY clause are reversed.</span></span> <span data-ttu-id="2bb2c-271">L'indice può ad esempio essere utilizzato da una query con la clausola ORDER BY `ORDER BY RejectedQty ASC, ProductID DESC` .</span><span class="sxs-lookup"><span data-stu-id="2bb2c-271">For example, a query with the ORDER BY clause `ORDER BY RejectedQty ASC, ProductID DESC` can use the index.</span></span>  
  
 <span data-ttu-id="2bb2c-272">È possibile specificare l'ordinamento solo per le colonne chiave.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-272">Sort order can be specified only for key columns.</span></span> <span data-ttu-id="2bb2c-273">La vista del catalogo [sys.index_columns](/sql/relational-databases/system-catalog-views/sys-indexes-transact-sql) e la funzione INDEXKEY_PROPERTY indicano se una colonna di un indice è archiviata in ordine crescente o decrescente.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-273">The [sys.index_columns](/sql/relational-databases/system-catalog-views/sys-indexes-transact-sql) catalog view and the INDEXKEY_PROPERTY function report whether an index column is stored in ascending or descending order.</span></span>  
  
 <span data-ttu-id="2bb2c-274">![Icona freccia usata con il collegamento Torna all'inizio](media/uparrow16x16.gif "Icona freccia usata con il collegamento Torna all'inizio") [in questa guida](#Top)</span><span class="sxs-lookup"><span data-stu-id="2bb2c-274">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="clustered-index-design-guidelines"></a><a name="Clustered"></a> <span data-ttu-id="2bb2c-275">Linee guida per la progettazione di indici cluster</span><span class="sxs-lookup"><span data-stu-id="2bb2c-275">Clustered Index Design Guidelines</span></span>  

 <span data-ttu-id="2bb2c-276">Gli indici cluster ordinano e archiviano le righe di dati della tabella in base ai valori di chiave.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-276">Clustered indexes sort and store the data rows in the table based on their key values.</span></span> <span data-ttu-id="2bb2c-277">Per ogni tabella è disponibile un solo indice cluster poiché le righe di dati possono essere ordinate con un solo tipo di ordinamento.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-277">There can only be one clustered index per table, because the data rows themselves can only be sorted in one order.</span></span> <span data-ttu-id="2bb2c-278">Con poche eccezioni, è opportuno definire un indice cluster sulla colonna o sulle colonne di tutte le tabelle che presentano le caratteristiche seguenti:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-278">With few exceptions, every table should have a clustered index defined on the column, or columns, that offer the following:</span></span>  
  
-   <span data-ttu-id="2bb2c-279">Possono essere utilizzate per query frequenti.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-279">Can be used for frequently used queries.</span></span>  
  
-   <span data-ttu-id="2bb2c-280">Garantiscono un elevato livello di univocità.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-280">Provide a high degree of uniqueness.</span></span>  
  
    > [!NOTE]  
    >  <span data-ttu-id="2bb2c-281">Quando si crea un vincolo PRIMARY KEY, viene automaticamente creato un indice univoco sulla colonna o sulle colonne.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-281">When you create a PRIMARY KEY constraint, a unique index on the column, or columns, is automatically created.</span></span> <span data-ttu-id="2bb2c-282">Per impostazione predefinita, tale indice è cluster. È tuttavia possibile specificare un indice non cluster durante la creazione del vincolo.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-282">By default, this index is clustered; however, you can specify a nonclustered index when you create the constraint.</span></span>  
  
-   <span data-ttu-id="2bb2c-283">Possono essere utilizzate in query di intervallo.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-283">Can be used in range queries.</span></span>  
  
 <span data-ttu-id="2bb2c-284">Se l'indice cluster non viene creato con la proprietà UNIQUE, [!INCLUDE[ssDE](../includes/ssde-md.md)] aggiunge automaticamente una colonna uniquifier a 4 byte alla tabella.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-284">If the clustered index is not created with the UNIQUE property, the [!INCLUDE[ssDE](../includes/ssde-md.md)] automatically adds a 4-byte uniquifier column to the table.</span></span> <span data-ttu-id="2bb2c-285">Quando necessario, [!INCLUDE[ssDE](../includes/ssde-md.md)] aggiunge automaticamente un valore uniquifier a una riga per rendere univoca ciascuna chiave.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-285">When it is required, the [!INCLUDE[ssDE](../includes/ssde-md.md)] automatically adds a uniquifier value to a row to make each key unique.</span></span> <span data-ttu-id="2bb2c-286">Questa colonna e i relativi valori sono per uso interno e non sono visualizzati o accessibili dagli utenti.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-286">This column and its values are used internally and cannot be seen or accessed by users.</span></span>  
  
### <a name="clustered-index-architecture"></a><span data-ttu-id="2bb2c-287">Architettura dell'indice cluster</span><span class="sxs-lookup"><span data-stu-id="2bb2c-287">Clustered Index Architecture</span></span>  

 <span data-ttu-id="2bb2c-288">In [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]gli indici sono organizzati in alberi B.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-288">In [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], indexes are organized as B-trees.</span></span> <span data-ttu-id="2bb2c-289">Ogni pagina dell'albero B di un indice viene definita nodo.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-289">Each page in an index B-tree is called an index node.</span></span> <span data-ttu-id="2bb2c-290">Il nodo di livello superiore dell'albero B viene definito nodo radice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-290">The top node of the B-tree is called the root node.</span></span> <span data-ttu-id="2bb2c-291">I nodi inferiori dell'indice vengono definiti nodi foglia.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-291">The bottom nodes in the index are called the leaf nodes.</span></span> <span data-ttu-id="2bb2c-292">I livelli dell'indice compresi tra il nodo radice e i nodi foglia sono noti come livelli intermedi.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-292">Any index levels between the root and the leaf nodes are collectively known as intermediate levels.</span></span> <span data-ttu-id="2bb2c-293">In un indice cluster il livello foglia include le pagine di dati della tabella sottostante.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-293">In a clustered index, the leaf nodes contain the data pages of the underlying table.</span></span> <span data-ttu-id="2bb2c-294">I nodi di livello radice e intermedio contengono pagine di indice che includono le righe dell'indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-294">The root and intermediate level nodes contain index pages holding index rows.</span></span> <span data-ttu-id="2bb2c-295">Ogni riga di indice contiene un valore di chiave e un puntatore a una pagina di livello intermedio nell'albero B o a una riga di dati nel livello foglia dell'indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-295">Each index row contains a key value and a pointer to either an intermediate level page in the B-tree, or a data row in the leaf level of the index.</span></span> <span data-ttu-id="2bb2c-296">Le pagine di ogni livello dell'indice sono collegate in un elenco collegato doppiamente.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-296">The pages in each level of the index are linked in a doubly-linked list.</span></span>  
  
 <span data-ttu-id="2bb2c-297">Gli indici cluster includono una riga in [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql), con **index_id** = 1 per ogni partizione usata dall'indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-297">Clustered indexes have one row in [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql), with **index_id** = 1 for each partition used by the index.</span></span> <span data-ttu-id="2bb2c-298">Per impostazione predefinita, un indice cluster include una singola partizione.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-298">By default, a clustered index has a single partition.</span></span> <span data-ttu-id="2bb2c-299">Quando in un indice cluster sono incluse più partizioni, ogni partizione ha un albero B contenente i dati per la partizione specifica.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-299">When a clustered index has multiple partitions, each partition has a B-tree structure that contains the data for that specific partition.</span></span> <span data-ttu-id="2bb2c-300">Se, ad esempio, un indice cluster include quattro partizioni, vi sono quattro alberi B, una in ogni partizione.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-300">For example, if a clustered index has four partitions, there are four B-tree structures; one in each partition.</span></span>  
  
 <span data-ttu-id="2bb2c-301">In base al tipo di dati nell'indice non cluster, ogni struttura dell'indice non cluster avrà una o più unità di allocazione in cui archiviare e gestire i dati per una partizione specifica.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-301">Depending on the data types in the clustered index, each clustered index structure will have one or more allocation units in which to store and manage the data for a specific partition.</span></span> <span data-ttu-id="2bb2c-302">Ogni indice cluster conterrà almeno un'unità di allocazione IN_ROW_DATA per partizione</span><span class="sxs-lookup"><span data-stu-id="2bb2c-302">At a minimum, each clustered index will have one IN_ROW_DATA allocation unit per partition.</span></span> <span data-ttu-id="2bb2c-303">e anche un'unità di allocazione LOB_DATA per partizione se contiene colonne LOB.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-303">The clustered index will also have one LOB_DATA allocation unit per partition if it contains large object (LOB) columns.</span></span> <span data-ttu-id="2bb2c-304">Conterrà inoltre un'unità di allocazione ROW_OVERFLOW_DATA per partizione, se include colonne a lunghezza variabile che superano il limite della lunghezza di riga di 8.060.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-304">It will also have one ROW_OVERFLOW_DATA allocation unit per partition if it contains variable length columns that exceed the 8,060 byte row size limit.</span></span>  
  
 <span data-ttu-id="2bb2c-305">Le pagine nella catena di dati e le righe incluse nelle pagine vengono ordinate in base al valore della chiave dell'indice cluster.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-305">The pages in the data chain and the rows in them are ordered on the value of the clustered index key.</span></span> <span data-ttu-id="2bb2c-306">Tutti gli inserimenti vengono eseguiti in corrispondenza del punto in cui il valore di chiave della riga inserita rientra nella sequenza di ordinamento tra righe esistenti.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-306">All inserts are made at the point where the key value in the inserted row fits in the ordering sequence among existing rows.</span></span>  
  
 <span data-ttu-id="2bb2c-307">Nella figura seguente viene illustrata la struttura di un indice cluster in una singola partizione.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-307">This illustration shows the structure of a clustered index in a single partition.</span></span>  
  
 <span data-ttu-id="2bb2c-308">![Livelli di un indice cluster](media/bokind2.gif "Livelli di un indice cluster")</span><span class="sxs-lookup"><span data-stu-id="2bb2c-308">![Levels of a clustered index](media/bokind2.gif "Levels of a clustered index")</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="2bb2c-309">Considerazioni sulle query</span><span class="sxs-lookup"><span data-stu-id="2bb2c-309">Query Considerations</span></span>  

 <span data-ttu-id="2bb2c-310">Prima di creare indici cluster, è consigliabile conoscere la modalità di accesso ai dati.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-310">Before you create clustered indexes, understand how your data will be accessed.</span></span> <span data-ttu-id="2bb2c-311">Utilizzare ad esempio un indice cluster per query che eseguono le operazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-311">Consider using a clustered index for queries that do the following:</span></span>  
  
-   <span data-ttu-id="2bb2c-312">Restituiscono un intervallo di valori utilizzando operatori quali BETWEEN, >, >=, < e <=.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-312">Return a range of values by using operators such as BETWEEN, >, >=, <, and <=.</span></span>  
  
     <span data-ttu-id="2bb2c-313">Quando la riga con il primo valore viene trovata utilizzando l'indice cluster, le righe con i valori indicizzati successivi sono sempre fisicamente adiacenti.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-313">After the row with the first value is found by using the clustered index, rows with subsequent indexed values are guaranteed to be physically adjacent.</span></span> <span data-ttu-id="2bb2c-314">Se, ad esempio, tramite una query vengono recuperati i record compresi tra un intervallo di numeri di ordini vendita, la presenza di un indice cluster nella colonna `SalesOrderNumber` consente di individuare rapidamente la riga contenente il numero iniziale dell'ordine di vendita e quindi di recuperare tutte le righe successive nella tabella fino al raggiungimento dell'ultimo numero dell'ordine vendita.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-314">For example, if a query retrieves records between a range of sales order numbers, a clustered index on the column `SalesOrderNumber` can quickly locate the row that contains the starting sales order number, and then retrieve all successive rows in the table until the last sales order number is reached.</span></span>  
  
-   <span data-ttu-id="2bb2c-315">Restituiscono set di risultati di grandi dimensioni.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-315">Return large result sets.</span></span>  
  
-   <span data-ttu-id="2bb2c-316">Utilizzano clausole JOIN, come nel caso delle colonne chiave esterne.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-316">Use JOIN clauses; typically these are foreign key columns.</span></span>  
  
-   <span data-ttu-id="2bb2c-317">Utilizzano clausole ORDER BY o GROUP BY.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-317">Use ORDER BY, or GROUP BY clauses.</span></span>  
  
     <span data-ttu-id="2bb2c-318">L'utilizzo di un indice basato sulle colonne specificate nella clausola ORDER BY o GROUP BY consente di evitare operazioni di ordinamento dei dati in [!INCLUDE[ssDE](../includes/ssde-md.md)] perché le righe sono già ordinate</span><span class="sxs-lookup"><span data-stu-id="2bb2c-318">An index on the columns specified in the ORDER BY or GROUP BY clause may remove the need for the [!INCLUDE[ssDE](../includes/ssde-md.md)] to sort the data, because the rows are already sorted.</span></span> <span data-ttu-id="2bb2c-319">e pertanto di ottimizzare le prestazioni delle query.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-319">This improves query performance.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="2bb2c-320">Considerazioni sulle colonne</span><span class="sxs-lookup"><span data-stu-id="2bb2c-320">Column Considerations</span></span>  

 <span data-ttu-id="2bb2c-321">È in genere opportuno definire la chiave di indice cluster con il minor numero di colonne possibile.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-321">Generally, you should define the clustered index key with as few columns as possible.</span></span> <span data-ttu-id="2bb2c-322">Utilizzare colonne che presentano o più degli attributi seguenti:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-322">Consider columns that have one or more of the following attributes:</span></span>  
  
-   <span data-ttu-id="2bb2c-323">Sono univoche o contengono molti valori distinti.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-323">Are unique or contain many distinct values</span></span>  
  
     <span data-ttu-id="2bb2c-324">Gli ID dipendente consentono ad esempio di identificare in modo univoco i dipendenti.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-324">For example, an employee ID uniquely identifies employees.</span></span> <span data-ttu-id="2bb2c-325">Un indice cluster o un vincolo PRIMARY KEY nella colonna `EmployeeID` contribuisce a migliorare le prestazioni di query tramite cui viene eseguita la ricerca di informazioni sui dipendenti in base al numero ID del dipendente.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-325">A clustered index or PRIMARY KEY constraint on the `EmployeeID` column would improve the performance of queries that search for employee information based on the employee ID number.</span></span> <span data-ttu-id="2bb2c-326">In alternativa, è possibile creare un indice cluster in `LastName`, `FirstName`, `MiddleName` perché i record relativi ai dipendenti sono in genere raggruppati e sottoposti a query in questo modo. Inoltre, la combinazione di queste colonne garantisce un elevato livello di differenziazione.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-326">Alternatively, a clustered index could be created on `LastName`, `FirstName`, `MiddleName` because employee records are frequently grouped and queried in this way, and the combination of these columns would still provide a high degree of difference.</span></span>  
  
-   <span data-ttu-id="2bb2c-327">Sono caratterizzate dall'accesso in modalità sequenziale.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-327">Are accessed sequentially</span></span>  
  
     <span data-ttu-id="2bb2c-328">Tramite un ID prodotto, ad esempio, vengono identificati in modo univoco i prodotti inclusi nella tabella `Production.Product` del database [!INCLUDE[ssSampleDBobject](../includes/sssampledbobject-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="2bb2c-328">For example, a product ID uniquely identifies products in the `Production.Product` table in the [!INCLUDE[ssSampleDBobject](../includes/sssampledbobject-md.md)] database.</span></span> <span data-ttu-id="2bb2c-329">La definizione di un indice cluster in `WHERE ProductID BETWEEN 980 and 999`produce effetti positivi sulle query in cui è stata specificata una ricerca sequenziale, come nel caso di `ProductID`,</span><span class="sxs-lookup"><span data-stu-id="2bb2c-329">Queries in which a sequential search is specified, such as `WHERE ProductID BETWEEN 980 and 999`, would benefit from a clustered index on `ProductID`.</span></span> <span data-ttu-id="2bb2c-330">in quanto le righe vengono archiviate in base all'ordinamento definito per tale colonna chiave.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-330">This is because the rows would be stored in sorted order on that key column.</span></span>  
  
-   <span data-ttu-id="2bb2c-331">Definite come IDENTITY.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-331">Defined as IDENTITY.</span></span>  
  
-   <span data-ttu-id="2bb2c-332">Vengono utilizzate di frequente per ordinare i dati recuperati da una tabella.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-332">Used frequently to sort the data retrieved from a table.</span></span>  
  
     <span data-ttu-id="2bb2c-333">Può essere utile eseguire il clustering della tabella, ovvero ordinarla fisicamente, in base a tale colonna per evitare il costo di un'operazione di ordinamento ogni volta che si esegue la query sulla colonna.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-333">It can be a good idea to cluster, that is physically sort, the table on that column to save the cost of a sort operation every time the column is queried.</span></span>  
  
 <span data-ttu-id="2bb2c-334">Gli indici cluster non sono consigliati per gli attributi seguenti:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-334">Clustered indexes are not a good choice for the following attributes:</span></span>  
  
-   <span data-ttu-id="2bb2c-335">Colonne che vengono modificate di frequente</span><span class="sxs-lookup"><span data-stu-id="2bb2c-335">Columns that undergo frequent changes</span></span>  
  
     <span data-ttu-id="2bb2c-336">In questo modo viene spostata l'intera riga, perché [!INCLUDE[ssDE](../includes/ssde-md.md)] deve contenere i valori dei dati di una riga in ordine fisico.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-336">This causes the whole row to move, because the [!INCLUDE[ssDE](../includes/ssde-md.md)] must keep the data values of a row in physical order.</span></span> <span data-ttu-id="2bb2c-337">Si tratta di una considerazione importante nel caso di sistemi che elaborano volumi elevati di transazioni in cui i dati sono in genere volatili.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-337">This is an important consideration in high-volume transaction processing systems in which data is typically volatile.</span></span>  
  
-   <span data-ttu-id="2bb2c-338">Chiavi estese</span><span class="sxs-lookup"><span data-stu-id="2bb2c-338">Wide keys</span></span>  
  
     <span data-ttu-id="2bb2c-339">Le chiavi estese sono costituite da diverse colonne normali o di grandi dimensioni.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-339">Wide keys are a composite of several columns or several large-size columns.</span></span> <span data-ttu-id="2bb2c-340">I valori di chiave dell'indice cluster vengono utilizzati come chiavi di ricerca da tutti gli indici non cluster.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-340">The key values from the clustered index are used by all nonclustered indexes as lookup keys.</span></span> <span data-ttu-id="2bb2c-341">Gli indici non cluster definiti nella stessa tabella saranno significativamente più grandi perché le voci di indice non cluster includono la chiave di clustering, nonché le colonne chiave definite per l'indice non cluster.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-341">Any nonclustered indexes defined on the same table will be significantly larger because the nonclustered index entries contain the clustering key and also the key columns defined for that nonclustered index.</span></span>  
  
 <span data-ttu-id="2bb2c-342">![Icona freccia usata con il collegamento Torna all'inizio](media/uparrow16x16.gif "Icona freccia usata con il collegamento Torna all'inizio") [in questa guida](#Top)</span><span class="sxs-lookup"><span data-stu-id="2bb2c-342">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="nonclustered-index-design-guidelines"></a><a name="Nonclustered"></a> <span data-ttu-id="2bb2c-343">Linee guida per la progettazione di un indice non cluster</span><span class="sxs-lookup"><span data-stu-id="2bb2c-343">Nonclustered Index Design Guidelines</span></span>  

 <span data-ttu-id="2bb2c-344">Un indice non cluster contiene i valori della chiave di indice e gli indicatori di posizione delle righe che puntano al percorso di archiviazione dei dati della tabella.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-344">A nonclustered index contains the index key values and row locators that point to the storage location of the table data.</span></span> <span data-ttu-id="2bb2c-345">In una vista tabella o indicizzata è possibile creare più indici non cluster.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-345">You can create multiple nonclustered indexes on a table or indexed view.</span></span> <span data-ttu-id="2bb2c-346">In genere, gli indici non cluster consentono di migliorare le prestazioni di query utilizzate di frequente non coperte da un indice cluster.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-346">Generally, nonclustered indexes should be designed to improve the performance of frequently used queries that are not covered by the clustered index.</span></span>  
  
 <span data-ttu-id="2bb2c-347">Analogamente a quando si utilizza l'indice di un libro, Query Optimizer cerca un valore di dati eseguendo una ricerca nell'indice non cluster per trovare la posizione del valore di dati nella tabella e quindi recupera i dati direttamente da quella posizione.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-347">Similar to the way you use an index in a book, the query optimizer searches for a data value by searching the nonclustered index to find the location of the data value in the table and then retrieves the data directly from that location.</span></span> <span data-ttu-id="2bb2c-348">Per questo motivo, gli indici non cluster sono la scelta ottimale per le query di corrispondenza esatta, in quanto l'indice contiene le voci che descrivono la posizione esatta nella tabella dei valori di dati cercati dalle query.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-348">This makes nonclustered indexes the optimal choice for exact match queries because the index contains entries describing the exact location in the table of the data values being searched for in the queries.</span></span> <span data-ttu-id="2bb2c-349">Per eseguire, ad esempio, una query sulla tabella `HumanResources. Employee` per cercare tutti i dipendenti che fanno riferimento a un responsabile specifico, tramite Query Optimizer si potrebbe utilizzare l'indice non cluster `IX_Employee_ManagerID`, la cui colonna chiave è `ManagerID` .</span><span class="sxs-lookup"><span data-stu-id="2bb2c-349">For example, to query the `HumanResources. Employee` table for all employees that report to a specific manager, the query optimizer might use the nonclustered index `IX_Employee_ManagerID`; this has `ManagerID` as its key column.</span></span> <span data-ttu-id="2bb2c-350">Query Optimizer consente di trovare in modo rapido tutte le voci di indice che corrispondono all'oggetto `ManagerID`specificato.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-350">The query optimizer can quickly find all entries in the index that match the specified `ManagerID`.</span></span> <span data-ttu-id="2bb2c-351">Ogni voce di indice punta alla pagina e alla riga esatte nella tabella o all'indice cluster in cui è possibile trovare i dati corrispondenti.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-351">Each index entry points to the exact page and row in the table, or clustered index, in which the corresponding data can be found.</span></span> <span data-ttu-id="2bb2c-352">Dopo avere trovato tutte le voci nell'indice, Query Optimizer può passare direttamente alla pagina e alla riga esatte per recuperare i dati.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-352">After the query optimizer finds all entries in the index, it can go directly to the exact page and row to retrieve the data.</span></span>  
  
### <a name="nonclustered-index-architecture"></a><span data-ttu-id="2bb2c-353">Architettura dell'indice non cluster</span><span class="sxs-lookup"><span data-stu-id="2bb2c-353">Nonclustered Index Architecture</span></span>  

 <span data-ttu-id="2bb2c-354">Gli indici non cluster hanno lo stesso albero B degli indici cluster, con due differenze significative:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-354">Nonclustered indexes have the same B-tree structure as clustered indexes, except for the following significant differences:</span></span>  
  
-   <span data-ttu-id="2bb2c-355">Le righe di dati della tabella sottostante vengono archiviate con ordinamento basato sulle relative chiavi non cluster.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-355">The data rows of the underlying table are not sorted and stored in order based on their nonclustered keys.</span></span>  
  
-   <span data-ttu-id="2bb2c-356">Il livello foglia di un indice non cluster è composto da pagine di indice invece che da pagine di dati.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-356">The leaf layer of a nonclustered index is made up of index pages instead of data pages.</span></span>  
  
 <span data-ttu-id="2bb2c-357">Gli indicatori di posizione delle righe nelle righe di indice non cluster sono rappresentati da un puntatore a una riga o da una chiave di indice cluster per una riga, come illustrato di seguito:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-357">The row locators in nonclustered index rows are either a pointer to a row or are a clustered index key for a row, as described in the following:</span></span>  
  
-   <span data-ttu-id="2bb2c-358">Se la tabella è un heap, ovvero non include un indice cluster, l'indicatore di posizione è un puntatore riferito alla riga</span><span class="sxs-lookup"><span data-stu-id="2bb2c-358">If the table is a heap, which means it does not have a clustered index, the row locator is a pointer to the row.</span></span> <span data-ttu-id="2bb2c-359">e compilato in base all'ID del file, al numero della pagina e al numero della riga nella pagina.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-359">The pointer is built from the file identifier (ID), page number, and number of the row on the page.</span></span> <span data-ttu-id="2bb2c-360">L'intero puntatore è noto come ID di riga.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-360">The whole pointer is known as a Row ID (RID).</span></span>  
  
-   <span data-ttu-id="2bb2c-361">Se una tabella include un indice cluster oppure l'indice è riferito a una vista indicizzata, l'indicatore di posizione delle righe corrisponde alla chiave di indice cluster per la riga.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-361">If the table has a clustered index, or the index is on an indexed view, the row locator is the clustered index key for the row.</span></span>  
  
 <span data-ttu-id="2bb2c-362">Negli indici non cluster è inclusa una riga in [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql) con **index_id** >1 per ogni partizione usata dall'indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-362">Nonclustered indexes have one row in [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql) with **index_id** >1 for each partition used by the index.</span></span> <span data-ttu-id="2bb2c-363">Per impostazione predefinita, un indice non cluster include una singola partizione.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-363">By default, a nonclustered index has a single partition.</span></span> <span data-ttu-id="2bb2c-364">Quando in un indice non cluster sono incluse più partizioni, ogni partizione ha un albero B contenente le righe di indice per la partizione specifica.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-364">When a nonclustered index has multiple partitions, each partition has a B-tree structure that contains the index rows for that specific partition.</span></span> <span data-ttu-id="2bb2c-365">Se, ad esempio, un indice non cluster include quattro partizioni, vi sono quattro alberi B, una in ogni partizione.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-365">For example, if a nonclustered index has four partitions, there are four B-tree structures, with one in each partition.</span></span>  
  
 <span data-ttu-id="2bb2c-366">In base ai tipi di dati nell'indice non cluster, ogni struttura dell'indice non cluster avrà una o più unità di allocazione in cui archiviare e gestire i dati per una partizione specifica.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-366">Depending on the data types in the nonclustered index, each nonclustered index structure will have one or more allocation units in which to store and manage the data for a specific partition.</span></span> <span data-ttu-id="2bb2c-367">Ogni indice non cluster ha almeno un'unità di allocazione IN_ROW_DATA per partizione in cui sono archiviate le pagine relative all'albero B dell'indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-367">At a minimum, each nonclustered index will have one IN_ROW_DATA allocation unit per partition that stores the index B-tree pages.</span></span> <span data-ttu-id="2bb2c-368">L'indice non cluster includerà inoltre un'unità di allocazione LOB_DATA per partizione se contiene colonne LOB.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-368">The nonclustered index will also have one LOB_DATA allocation unit per partition if it contains large object (LOB) columns .</span></span> <span data-ttu-id="2bb2c-369">L'indice include inoltre un'unità di allocazione ROW_OVERFLOW_DATA per partizione se contiene colonne a lunghezza variabile che superano le dimensioni massime di 8.060 byte.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-369">Additionally, it will have one ROW_OVERFLOW_DATA allocation unit per partition if it contains variable length columns that exceed the 8,060 byte row size limit.</span></span>  
  
 <span data-ttu-id="2bb2c-370">Nella figura seguente viene illustrata la struttura di un indice non cluster in una singola partizione.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-370">The following illustration shows the structure of a nonclustered index in a single partition.</span></span>  
  
 <span data-ttu-id="2bb2c-371">![Livelli di un indice non cluster](media/bokind1.gif "Livelli di un indice non cluster")</span><span class="sxs-lookup"><span data-stu-id="2bb2c-371">![Levels of a nonclustered index](media/bokind1.gif "Levels of a nonclustered index")</span></span>  
  
### <a name="database-considerations"></a><span data-ttu-id="2bb2c-372">Considerazioni sui database</span><span class="sxs-lookup"><span data-stu-id="2bb2c-372">Database Considerations</span></span>  

 <span data-ttu-id="2bb2c-373">Quando si progettano indici non cluster, considerare le caratteristiche del database.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-373">Consider the characteristics of the database when designing nonclustered indexes.</span></span>  
  
-   <span data-ttu-id="2bb2c-374">In caso di database o tabelle che richiedono pochi aggiornamenti ma contengono grandi volumi di dati, l'utilizzo di molti indici non cluster può consentire di migliorare le prestazioni di esecuzione delle query.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-374">Databases or tables with low update requirements, but large volumes of data can benefit from many nonclustered indexes to improve query performance.</span></span> <span data-ttu-id="2bb2c-375">È consigliabile creare indici filtrati per subset ben definiti di dati per ottimizzare le prestazioni relative alle query e ridurre i costi di archiviazione e di manutenzione dell'indice rispetto agli indici non cluster di tabella completa.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-375">Consider creating filtered indexes for well-defined subsets of data to improve query performance, reduce index storage costs, and reduce index maintenance costs compared with full-table nonclustered indexes.</span></span>  
  
     <span data-ttu-id="2bb2c-376">In caso di applicazioni DSS (Decision Support System) e database che contengono principalmente dati di sola lettura è consigliabile l'utilizzo di molti indici non cluster.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-376">Decision Support System applications and databases that contain primarily read-only data can benefit from many nonclustered indexes.</span></span> <span data-ttu-id="2bb2c-377">In questo modo, saranno disponibili per Query Optimizer più indici tra cui scegliere per determinare il metodo di accesso più rapido e la bassa frequenza di aggiornamento del database significa che la manutenzione dell'indice non influirà negativamente sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-377">The query optimizer has more indexes to choose from to determine the fastest access method, and the low update characteristics of the database mean index maintenance will not impede performance.</span></span>  
  
-   <span data-ttu-id="2bb2c-378">In caso di applicazioni di elaborazione delle transazioni online (OLP) e database contenenti tabelle aggiornate di frequente, è consigliabile evitare di utilizzare un numero eccessivo di indici.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-378">Online Transaction Processing applications and databases that contain heavily updated tables should avoid over-indexing.</span></span> <span data-ttu-id="2bb2c-379">È inoltre necessario che gli indici siano limitati, ovvero con il minor numero possibile di colonne.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-379">Additionally, indexes should be narrow, that is, with as few columns as possible.</span></span>  
  
     <span data-ttu-id="2bb2c-380">Un numero elevato di indici in una tabella ha ripercussioni sulle prestazioni delle istruzioni INSERT, UPDATE, DELETE e MERGE perché, quando vengono modificati i dati nella tabella, tutti gli indici devono essere modificati di conseguenza.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-380">Large numbers of indexes on a table affect the performance of INSERT, UPDATE, DELETE, and MERGE  statements because all indexes must be adjusted appropriately as data in the table changes.</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="2bb2c-381">Considerazioni sulle query</span><span class="sxs-lookup"><span data-stu-id="2bb2c-381">Query Considerations</span></span>  

 <span data-ttu-id="2bb2c-382">Prima di creare indici non cluster, è consigliabile analizzare la modalità di accesso ai dati.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-382">Before you create nonclustered indexes, you should understand how your data will be accessed.</span></span> <span data-ttu-id="2bb2c-383">Utilizzare un indice non cluster per le query con gli attributi seguenti:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-383">Consider using a nonclustered index for queries that have the following attributes:</span></span>  
  
-   <span data-ttu-id="2bb2c-384">Query che utilizzano clausole JOIN o GROUP BY.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-384">Use JOIN or GROUP BY clauses.</span></span>  
  
     <span data-ttu-id="2bb2c-385">Creare più indici non cluster in colonne interessate da operazioni di join e raggruppamento e un indice cluster in ogni colonna chiave esterna.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-385">Create multiple nonclustered indexes on columns involved in join and grouping operations, and a clustered index on any foreign key columns.</span></span>  
  
-   <span data-ttu-id="2bb2c-386">Query che non restituiscono set di risultati estesi.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-386">Queries that do not return large result sets.</span></span>  
  
     <span data-ttu-id="2bb2c-387">Creare indici filtrati per coprire query che restituiscono un subset ben definito di righe da una tabella di elevate dimensioni.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-387">Create filtered indexes to cover queries that return a well-defined subset of rows from a large table.</span></span>  
  
-   <span data-ttu-id="2bb2c-388">Query che contengono colonne interessate di frequente da condizioni di ricerca di una query, ad esempio la clausola WHERE, che restituiscono corrispondenze esatte.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-388">Contain columns frequently involved in search conditions of a query, such as WHERE clause, that return exact matches.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="2bb2c-389">Considerazioni sulle colonne</span><span class="sxs-lookup"><span data-stu-id="2bb2c-389">Column Considerations</span></span>  

 <span data-ttu-id="2bb2c-390">Considerare le colonne con uno o più degli attributi seguenti:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-390">Consider columns that have one or more of these attributes:</span></span>  
  
-   <span data-ttu-id="2bb2c-391">Colonne che coprono la query.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-391">Cover the query.</span></span>  
  
     <span data-ttu-id="2bb2c-392">È possibile ottenere un miglioramento delle prestazioni quando l'indice contiene tutte le colonne nella query.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-392">Performance gains are achieved when the index contains all columns in the query.</span></span> <span data-ttu-id="2bb2c-393">Query Optimizer può individuare tutti i valori della colonna all'interno dell'indice. Poiché non viene effettuato l'accesso ai dati della tabella o dell'indice cluster, il numero di operazioni di I/O su disco risulta inferiore.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-393">The query optimizer can locate all the column values within the index; table or clustered index data is not accessed resulting in fewer disk I/O operations.</span></span> <span data-ttu-id="2bb2c-394">Utilizzare un indice con colonne per aggiungere colonne di copertura anziché creare una chiave di indice esteso.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-394">Use index with included columns to add covering columns instead of creating a wide index key.</span></span>  
  
     <span data-ttu-id="2bb2c-395">Se la tabella include un indice cluster, la colonna o le colonne definite in tale indice vengono automaticamente accodate alla fine di ogni indice non cluster nella tabella.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-395">If the table has a clustered index, the column or columns defined in the clustered index are automatically appended to the end of each nonclustered index on the table.</span></span> <span data-ttu-id="2bb2c-396">In questo modo, è possibile produrre una query coperta senza specificare le colonne dell'indice cluster nella definizione dell'indice non cluster.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-396">This can produce a covered query without specifying the clustered index columns in the definition of the nonclustered index.</span></span> <span data-ttu-id="2bb2c-397">Se, ad esempio, in una tabella sono inclusi un indice cluster nella colonna `C`, un indice non cluster nelle colonne `B` e `A` , le colonne `B`, `A`e `C`della tabella in questione rappresenteranno i relativi valori chiave.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-397">For example, if a table has a clustered index on column `C`, a nonclustered index on columns `B` and `A` will have as its key values columns `B`, `A`, and `C`.</span></span>  
  
-   <span data-ttu-id="2bb2c-398">Colonne che includono un numero elevato di valori distinct, ad esempio una combinazione di cognome e nome, se per le altre colonne viene utilizzato un indice cluster.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-398">Lots of distinct values, such as a combination of last name and first name, if a clustered index is used for other columns.</span></span>  
  
     <span data-ttu-id="2bb2c-399">Se sono presenti soltanto pochi valori distinct, ad esempio 1 e 0, la maggior parte delle query non utilizzerà l'indice in quanto una scansione della tabella risulta in genere più efficiente.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-399">If there are very few distinct values, such as only 1 and 0, most queries will not use the index because a table scan is generally more efficient.</span></span> <span data-ttu-id="2bb2c-400">Per questo tipo di dati, creare un indice filtrato su un valore distinto che presente solo in un numero ridotto di righe.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-400">For this type of data, consider creating a filtered index on a distinct value that only occurs in a small number of rows.</span></span> <span data-ttu-id="2bb2c-401">Se la maggior parte dei valori è impostata su 0, Query Optimizer potrebbe utilizzare un indice filtrato per le righe di dati che contengono il valore 1.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-401">For example, if most of the values are 0, the query optimizer might use a filtered index for the data rows that contain 1.</span></span>  
  
####  <a name="use-included-columns-to-extend-nonclustered-indexes"></a><a name="Included_Columns"></a> <span data-ttu-id="2bb2c-402">Utilizzare colonne incluse per estendere gli indici non cluster</span><span class="sxs-lookup"><span data-stu-id="2bb2c-402">Use Included Columns to Extend Nonclustered Indexes</span></span>  

 <span data-ttu-id="2bb2c-403">È possibile estendere le funzionalità degli indici non cluster aggiungendo colonne non chiave a livello foglia dell'indice non cluster.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-403">You can extend the functionality of nonclustered indexes by adding nonkey columns to the leaf level of the nonclustered index.</span></span> <span data-ttu-id="2bb2c-404">Con l'inclusione di colonne non chiave è possibile creare indici non cluster in grado di coprire più query.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-404">By including nonkey columns, you can create nonclustered indexes that cover more queries.</span></span> <span data-ttu-id="2bb2c-405">Ciò è possibile perché le colonne non chiave presentano i vantaggi seguenti:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-405">This is because the nonkey columns have the following benefits:</span></span>  
  
-   <span data-ttu-id="2bb2c-406">Possono essere tipi di dati che non sono consentiti come colonne chiave indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-406">They can be data types not allowed as index key columns.</span></span>  
  
-   <span data-ttu-id="2bb2c-407">Non vengono prese in esame dal [!INCLUDE[ssDE](../includes/ssde-md.md)] durante il calcolo del numero di colonne chiave indice o della dimensione delle chiavi di indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-407">They are not considered by the [!INCLUDE[ssDE](../includes/ssde-md.md)] when calculating the number of index key columns or index key size.</span></span>  
  
 <span data-ttu-id="2bb2c-408">Un indice con colonne non chiave incluse può aumentare significativamente le prestazioni delle query quando tutte le colonne della query sono incluse nell'indice come colonne chiave o non chiave.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-408">An index with included nonkey columns can significantly improve query performance when all columns in the query are included in the index either as key or nonkey columns.</span></span> <span data-ttu-id="2bb2c-409">I vantaggi nelle prestazioni si ottengono poiché Query Optimizer può individuare tutti i valori delle colonne all'interno dell'indice. In questo modo, la quantità di operazioni di I/O su disco è inferiore dato che non viene eseguito alcun accesso ai dati delle tabelle o degli indici cluster.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-409">Performance gains are achieved because the query optimizer can locate all the column values within the index; table or clustered index data is not accessed resulting in fewer disk I/O operations.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="2bb2c-410">Quando un indice contiene tutte le colonne a cui fa riferimento la query, viene generalmente indicato come indice di copertura.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-410">When an index contains all the columns referenced by the query it is typically referred to as covering the query.</span></span>  
  
 <span data-ttu-id="2bb2c-411">Mentre le colonne chiave sono archiviate a tutti i livelli dell'indice, le colonne non chiave sono archiviate solo al livello foglia.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-411">While key columns are stored at all levels of the index, nonkey columns are stored only at the leaf level.</span></span>  
  
##### <a name="using-included-columns-to-avoid-size-limits"></a><span data-ttu-id="2bb2c-412">Utilizzo di colonne incluse per aggirare i limiti alle dimensioni</span><span class="sxs-lookup"><span data-stu-id="2bb2c-412">Using Included Columns to Avoid Size Limits</span></span>  

 <span data-ttu-id="2bb2c-413">È possibile includere colonne non chiave in un indice non cluster per evitare il superamento delle limitazioni di dimensione correnti degli indici (numero massimo di colonne chiave pari a 16 e dimensione massima delle chiavi di indice pari a 900 byte).</span><span class="sxs-lookup"><span data-stu-id="2bb2c-413">You can include nonkey columns in a nonclustered index to avoid exceeding the current index size limitations of a maximum of 16 key columns and a maximum index key size of 900 bytes.</span></span> <span data-ttu-id="2bb2c-414">Il [!INCLUDE[ssDE](../includes/ssde-md.md)] non prende in esame le colonne non chiave durante il calcolo del numero di colonne chiave indice o della dimensione delle chiavi di indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-414">The [!INCLUDE[ssDE](../includes/ssde-md.md)] does not consider nonkey columns when calculating the number of index key columns or index key size.</span></span>  
  
 <span data-ttu-id="2bb2c-415">Si supponga, ad esempio, che si desideri indicizzare le colonne seguenti nella tabella `Document` :</span><span class="sxs-lookup"><span data-stu-id="2bb2c-415">For example, assume that you want to index the following columns in the `Document` table:</span></span>  
  
 `Title nvarchar(50)`  
  
 `Revision nchar(5)`  
  
 `FileName nvarchar(400)`  
  
 <span data-ttu-id="2bb2c-416">Dal momento che i tipi i dati `nchar` e `nvarchar` richiedono 2 byte per ogni carattere, un indice contenente queste tre colonne supererebbe di 10 byte la limitazione di dimensione di 900 byte (455 x 2).</span><span class="sxs-lookup"><span data-stu-id="2bb2c-416">Because the `nchar` and `nvarchar` data types require 2 bytes for each character, an index that contains these three columns would exceed the 900 byte size limitation by 10 bytes (455 \* 2).</span></span> <span data-ttu-id="2bb2c-417">Utilizzando la clausola `INCLUDE` dell'istruzione `CREATE INDEX` , è possibile definire la chiave dell'indice come (`Title, Revision`) e `FileName` come colonna non chiave.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-417">By using the `INCLUDE` clause of the `CREATE INDEX` statement, the index key could be defined as (`Title, Revision`) and `FileName` defined as a nonkey column.</span></span> <span data-ttu-id="2bb2c-418">In questo modo, la dimensione della chiave dell'indice sarebbe pari a 110 byte (55 \* 2) e l'indice conterrebbe ancora tutte le colonne necessarie.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-418">In this way, the index key size would be 110 bytes (55 \* 2), and the index would still contain all the required columns.</span></span> <span data-ttu-id="2bb2c-419">Nell'istruzione seguente viene creato un simile indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-419">The following statement creates such an index.</span></span>  
  
```sql
CREATE INDEX IX_Document_Title   
ON Production.Document (Title, Revision)   
INCLUDE (FileName);   
```  
  
##### <a name="index-with-included-columns-guidelines"></a><span data-ttu-id="2bb2c-420">Linee guida sull'utilizzo degli indici con colonne incluse</span><span class="sxs-lookup"><span data-stu-id="2bb2c-420">Index with Included Columns Guidelines</span></span>  

 <span data-ttu-id="2bb2c-421">Quando si progettano indici non cluster con colonne incluse è opportuno considerare le indicazioni generali seguenti:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-421">When you design nonclustered indexes with included columns consider the following guidelines:</span></span>  
  
-   <span data-ttu-id="2bb2c-422">Le colonne non chiave vengono definite nella clausola INCLUDE dell'istruzione CREATE INDEX.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-422">Nonkey columns are defined in the INCLUDE clause of the CREATE INDEX statement.</span></span>  
  
-   <span data-ttu-id="2bb2c-423">Le colonne non chiave possono essere definite solo su indici non cluster su tabelle o viste indicizzate.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-423">Nonkey columns can only be defined on nonclustered indexes on tables or indexed views.</span></span>  
  
-   <span data-ttu-id="2bb2c-424">È possibile utilizzare qualsiasi tipo di dati, ad eccezione di `text`, `ntext` e `image`.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-424">All data types are allowed except `text`, `ntext`, and `image`.</span></span>  
  
-   <span data-ttu-id="2bb2c-425">Come colonne incluse è possibile utilizzare colonne calcolate che sono deterministiche, sia precise che imprecise.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-425">Computed columns that are deterministic and either precise or imprecise can be included columns.</span></span> <span data-ttu-id="2bb2c-426">Per altre informazioni, vedere [Indici per le colonne calcolate](../relational-databases/indexes/indexes-on-computed-columns.md).</span><span class="sxs-lookup"><span data-stu-id="2bb2c-426">For more information, see [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).</span></span>  
  
-   <span data-ttu-id="2bb2c-427">In maniera simile alle colonne chiave, le colonne calcolate derivate dai tipi di dati `image`, `ntext` e `text` possono essere colonne non chiave (incluse) purché il tipo di dati della colonna calcolata sia consentito come colonna non chiave dell'indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-427">As with key columns, computed columns derived from `image`, `ntext`, and `text` data types can be nonkey (included) columns as long as the computed column data type is allowed as a nonkey index column.</span></span>  
  
-   <span data-ttu-id="2bb2c-428">Non è possibile specificare i nomi delle colonne sia nell'elenco INCLUDE che nell'elenco delle colonne chiave.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-428">Column names cannot be specified in both the INCLUDE list and in the key column list.</span></span>  
  
-   <span data-ttu-id="2bb2c-429">Non è possibile ripetere i nomi delle colonne nell'elenco INCLUDE.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-429">Column names cannot be repeated in the INCLUDE list.</span></span>  
  
##### <a name="column-size-guidelines"></a><span data-ttu-id="2bb2c-430">Linee guida sulle dimensioni delle colonne</span><span class="sxs-lookup"><span data-stu-id="2bb2c-430">Column Size Guidelines</span></span>  
  
-   <span data-ttu-id="2bb2c-431">È necessario definire almeno una colonna chiave.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-431">At least one key column must be defined.</span></span> <span data-ttu-id="2bb2c-432">Il numero massimo di colonne non chiave è 1023.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-432">The maximum number of nonkey columns is 1023 columns.</span></span> <span data-ttu-id="2bb2c-433">Questo limite è rappresentato dal numero massimo di colonne nelle tabelle meno 1.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-433">This is the maximum number of table columns minus 1.</span></span>  
  
-   <span data-ttu-id="2bb2c-434">Le colonne chiave non indice, escluse le colonne non chiave dell'indice, devono soddisfare le limitazioni di dimensione correnti degli indici (numero massimo di colonne chiave pari a 16 e dimensione totale delle chiavi di indice pari a 900 byte).</span><span class="sxs-lookup"><span data-stu-id="2bb2c-434">Index key columns, excluding nonkeys, must follow the existing index size restrictions of 16 key columns maximum, and a total index key size of 900 bytes.</span></span>  
  
-   <span data-ttu-id="2bb2c-435">La dimensione totale delle colonne non chiave è limitata solo dalle dimensioni delle colonne specificate nella clausola INCLUDE (ad esempio, le colonne `varchar(max)` sono limitate a 2 GB).</span><span class="sxs-lookup"><span data-stu-id="2bb2c-435">The total size of all nonkey columns is limited only by the size of the columns specified in the INCLUDE clause; for example, `varchar(max)` columns are limited to 2 GB.</span></span>  
  
##### <a name="column-modification-guidelines"></a><span data-ttu-id="2bb2c-436">Linee guida sulla modifica delle colonne</span><span class="sxs-lookup"><span data-stu-id="2bb2c-436">Column Modification Guidelines</span></span>  

 <span data-ttu-id="2bb2c-437">Quando si modifica una colonna di tabella che è stata definita come colonna inclusa, vengono applicate le limitazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-437">When you modify a table column that has been defined as an included column, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="2bb2c-438">Non è possibile eliminare dalla tabella le colonne non chiave se non si è prima eliminato l'indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-438">Nonkey columns cannot be dropped from the table unless the index is dropped first.</span></span>  
  
-   <span data-ttu-id="2bb2c-439">Non è possibile modificare le colonne non chiave se non per eseguire le operazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-439">Nonkey columns cannot be changed, except to do the following:</span></span>  
  
    -   <span data-ttu-id="2bb2c-440">Modifica del supporto di valori NULL della colonna da NOT NULL a NULL.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-440">Change the nullability of the column from NOT NULL to NULL.</span></span>  
  
    -   <span data-ttu-id="2bb2c-441">Aumento della lunghezza di colonne `varchar`, `nvarchar` o `varbinary`.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-441">Increase the length of `varchar`, `nvarchar`, or `varbinary` columns.</span></span>  
  
        > [!NOTE]  
        >  <span data-ttu-id="2bb2c-442">Tali restrizioni sulla modifica delle colonne sono valide anche per le colonne chiave indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-442">These column modification restrictions also apply to index key columns.</span></span>  
  
##### <a name="design-recommendations"></a><span data-ttu-id="2bb2c-443">Consigli sulla progettazione</span><span class="sxs-lookup"><span data-stu-id="2bb2c-443">Design Recommendations</span></span>  

 <span data-ttu-id="2bb2c-444">Progettare nuovamente gli indici non cluster con chiavi di indice dalle dimensioni elevate in modo da utilizzare come colonne chiave solo le colonne utilizzate per le ricerche.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-444">Redesign nonclustered indexes with a large index key size so that only columns used for searching and lookups are key columns.</span></span> <span data-ttu-id="2bb2c-445">Modificare in colonne non chiave incluse tutte le altre colonne che coprono la query.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-445">Make all other columns that cover the query included nonkey columns.</span></span> <span data-ttu-id="2bb2c-446">In questo modo si avranno tutte le colonne necessarie per coprire la query, contenendo al tempo stesso le dimensioni della chiave dell'indice e mantenendone l'efficienza.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-446">In this way, you will have all columns needed to cover the query, but the index key itself is small and efficient.</span></span>  
  
 <span data-ttu-id="2bb2c-447">Si supponga, ad esempio, che si desideri progettare un indice per coprire la query seguente.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-447">For example, assume that you want to design an index to cover the following query.</span></span>  
  
```sql
SELECT AddressLine1, AddressLine2, City, StateProvinceID, PostalCode  
FROM Person.Address  
WHERE PostalCode BETWEEN N'98000' and N'99999';  
```  
  
 <span data-ttu-id="2bb2c-448">Per coprire la query è necessario definire tutte le colonne nell'indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-448">To cover the query, each column must be defined in the index.</span></span> <span data-ttu-id="2bb2c-449">Sebbene sia possibile definire tutte le colonne come colonne chiave, la dimensione delle chiavi sarebbe di 334 byte.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-449">Although you could define all columns as key columns, the key size would be 334 bytes.</span></span> <span data-ttu-id="2bb2c-450">Dal momento che la sola colonna effettivamente utilizzata come criterio di ricerca è la colonna `PostalCode` , la quale ha una lunghezza pari a 30 byte, è possibile migliorare la progettazione degli indici definendo `PostalCode` come colonna chiave e includendo tutte le altre colonne come colonne non chiave.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-450">Because the only column actually used as search criteria is the `PostalCode` column, having a length of 30 bytes, a better index design would define `PostalCode` as the key column and include all other columns as nonkey columns.</span></span>  
  
 <span data-ttu-id="2bb2c-451">Nell'istruzione seguente viene creato un indice con colonne incluse per coprire la query.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-451">The following statement creates an index with included columns to cover the query.</span></span>  
  
```sql
CREATE INDEX IX_Address_PostalCode  
ON Person.Address (PostalCode)  
INCLUDE (AddressLine1, AddressLine2, City, StateProvinceID);  
```  
  
##### <a name="performance-considerations"></a><span data-ttu-id="2bb2c-452">Considerazioni sulle prestazioni</span><span class="sxs-lookup"><span data-stu-id="2bb2c-452">Performance Considerations</span></span>  

 <span data-ttu-id="2bb2c-453">Evitare di aggiungere colonne non necessarie.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-453">Avoid adding unnecessary columns.</span></span> <span data-ttu-id="2bb2c-454">L'aggiunta di troppe colonne indice, chiave o non chiave, può avere le implicazioni sulle prestazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-454">Adding too many index columns, key or nonkey, can have the following performance implications:</span></span>  
  
-   <span data-ttu-id="2bb2c-455">In una pagina rientreranno meno righe di indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-455">Fewer index rows will fit on a page.</span></span> <span data-ttu-id="2bb2c-456">Ciò potrebbe causare più operazioni di I/O e ridurre l'efficienza della cache.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-456">This could create I/O increases and reduced cache efficiency.</span></span>  
  
-   <span data-ttu-id="2bb2c-457">Sarà necessario più spazio su disco per archiviare l'indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-457">More disk space will be required to store the index.</span></span> <span data-ttu-id="2bb2c-458">In particolare, l'aggiunta di tipi di dati `varchar(max)`, `nvarchar(max)`, `varbinary(max)` o `xml` come colonne non chiave dell'indice potrebbe aumentare significativamente lo spazio su disco richiesto.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-458">In particular, adding `varchar(max)`, `nvarchar(max)`, `varbinary(max)`, or `xml` data types as nonkey index columns may significantly increase disk space requirements.</span></span> <span data-ttu-id="2bb2c-459">Ciò accade perché i valori delle colonne vengono copiati nel livello foglia dell'indice,</span><span class="sxs-lookup"><span data-stu-id="2bb2c-459">This is because the column values are copied into the index leaf level.</span></span> <span data-ttu-id="2bb2c-460">risiedendo in tal modo sia nell'indice che nella tabella di base.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-460">Therefore, they reside in both the index and the base table.</span></span>  
  
-   <span data-ttu-id="2bb2c-461">La manutenzione degli indici può aumentare il tempo necessario per eseguire modifiche, inserimenti, aggiornamenti o eliminazioni nella tabella sottostante o nella vista indicizzata.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-461">Index maintenance may increase the time that it takes to perform modifications, inserts, updates, or deletes, to the underlying table or indexed view.</span></span>  
  
 <span data-ttu-id="2bb2c-462">Sarà necessario determinare se i guadagni in termini di prestazioni delle query offrano maggiore vantaggio rispetto all'influenza sulle prestazioni durante la modifica dei dati e ai maggiori requisiti di spazio su disco.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-462">You will have to determine whether the gains in query performance outweigh the affect to performance during data modification and in additional disk space requirements.</span></span>  
  
 <span data-ttu-id="2bb2c-463">![Icona freccia usata con il collegamento Torna all'inizio](media/uparrow16x16.gif "Icona freccia usata con il collegamento Torna all'inizio") [in questa guida](#Top)</span><span class="sxs-lookup"><span data-stu-id="2bb2c-463">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="unique-index-design-guidelines"></a><a name="Unique"></a> <span data-ttu-id="2bb2c-464">Linee guida per la progettazione di indici univoci</span><span class="sxs-lookup"><span data-stu-id="2bb2c-464">Unique Index Design Guidelines</span></span>  

 <span data-ttu-id="2bb2c-465">Un indice univoco consente di garantire che nella chiave dell'indice non siano contenuti valori duplicati e che pertanto ogni riga della tabella sia univoca.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-465">A unique index guarantees that the index key contains no duplicate values and therefore every row in the table is in some way unique.</span></span> <span data-ttu-id="2bb2c-466">È consigliabile specificare un indice univoco solo se l'unicità è una caratteristica dei dati stessi.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-466">Specifying a unique index makes sense only when uniqueness is a characteristic of the data itself.</span></span> <span data-ttu-id="2bb2c-467">Per verificare, ad esempio, che i valori della colonna `NationalIDNumber` nella tabella `HumanResources.Employee` siano univoci quando la chiave primaria è `EmployeeID`, creare un vincolo UNIQUE nella colonna `NationalIDNumber` .</span><span class="sxs-lookup"><span data-stu-id="2bb2c-467">For example, if you want to make sure that the values in the `NationalIDNumber` column in the `HumanResources.Employee` table are unique, when the primary key is `EmployeeID`, create a UNIQUE constraint on the `NationalIDNumber` column.</span></span> <span data-ttu-id="2bb2c-468">Se l'utente tenta di inserire nella colonna lo stesso valore per più dipendenti, verrà visualizzato un messaggio di errore e il valore duplicato non verrà inserito.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-468">If the user tries to enter the same value in that column for more than one employee, an error message is displayed and the duplicate value is not entered.</span></span>  
  
 <span data-ttu-id="2bb2c-469">Per gli indici univoci a più colonne, l'indice garantisce che ogni combinazione di valori nella chiave dell'indice sia univoca.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-469">With multicolumn unique indexes, the index guarantees that each combination of values in the index key is unique.</span></span> <span data-ttu-id="2bb2c-470">Ad esempio, se si crea un indice univoco basato su una combinazione delle colonne `LastName`, `FirstName`e `MiddleName` , non è possibile che nella tabella siano incluse due righe in cui è presente la stessa combinazione di valori per queste colonne.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-470">For example, if a unique index is created on a combination of `LastName`, `FirstName`, and `MiddleName` columns, no two rows in the table could have the same combination of values for these columns.</span></span>  
  
 <span data-ttu-id="2bb2c-471">Sia gli indici cluster che non cluster possono essere univoci.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-471">Both clustered and nonclustered indexes can be unique.</span></span> <span data-ttu-id="2bb2c-472">Se i dati nella colonna sono univoci, nella stessa tabella è possibile creare sia un indice cluster univoco che più indici non cluster univoci.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-472">Provided that the data in the column is unique, you can create both a unique clustered index and multiple unique nonclustered indexes on the same table.</span></span>  
  
 <span data-ttu-id="2bb2c-473">Gli indici univoci offrono i vantaggi seguenti:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-473">The benefits of unique indexes include the following:</span></span>  
  
-   <span data-ttu-id="2bb2c-474">Garantiscono l'integrità dei dati delle colonne definite.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-474">Data integrity of the defined columns is ensured.</span></span>  
  
-   <span data-ttu-id="2bb2c-475">Forniscono informazioni aggiuntive utili per Query Optimizer.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-475">Additional information helpful to the query optimizer is provided.</span></span>  
  
 <span data-ttu-id="2bb2c-476">Se si crea un vincolo PRIMARY KEY o UNIQUE, viene creato automaticamente un indice univoco basato sulle colonne specificate.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-476">Creating a PRIMARY KEY or UNIQUE constraint automatically creates a unique index on the specified columns.</span></span> <span data-ttu-id="2bb2c-477">Non esistono differenze significative tra la creazione determinata da un vincolo UNIQUE e la creazione di un indice univoco indipendente da un vincolo.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-477">There are no significant differences between creating a UNIQUE constraint and creating a unique index independent of a constraint.</span></span> <span data-ttu-id="2bb2c-478">La convalida dei dati viene eseguita nello stesso modo e Query Optimizer non differenzia un indice univoco creato da un vincolo da un indice creato in modo manuale.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-478">Data validation occurs in the same manner and the query optimizer does not differentiate between a unique index created by a constraint or manually created.</span></span> <span data-ttu-id="2bb2c-479">Se l'obiettivo è l'integrità dei dati, è tuttavia consigliabile creare un vincolo UNIQUE o PRIMARY KEY sulla colonna,</span><span class="sxs-lookup"><span data-stu-id="2bb2c-479">However, you should create a UNIQUE or PRIMARY KEY constraint on the column when data integrity is the objective.</span></span> <span data-ttu-id="2bb2c-480">in modo tale che l'obiettivo dell'indice risulti chiaro.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-480">By doing this the objective of the index will be clear.</span></span>  
  
### <a name="considerations"></a><span data-ttu-id="2bb2c-481">Considerazioni</span><span class="sxs-lookup"><span data-stu-id="2bb2c-481">Considerations</span></span>  
  
-   <span data-ttu-id="2bb2c-482">Se nei dati sono presenti valori di chiave duplicati, non è possibile creare un indice univoco, un vincolo UNIQUE o un vincolo PRIMARY KEY.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-482">A unique index, UNIQUE constraint, or PRIMARY KEY constraint cannot be created if duplicate key values exist in the data.</span></span>  
  
-   <span data-ttu-id="2bb2c-483">Se i dati sono univoci e si desidera imporre l'unicità, la creazione di un indice univoco anziché di un indice non univoco per la stessa combinazione di colonne fornirà a Query Optimizer una maggiore quantità di informazioni che consentiranno di creare piani di esecuzione più efficienti.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-483">If the data is unique and you want uniqueness enforced, creating a unique index instead of a nonunique index on the same combination of columns provides additional information for the query optimizer that can produce more efficient execution plans.</span></span> <span data-ttu-id="2bb2c-484">In questo caso è consigliabile creare un indice univoco, preferibilmente tramite un vincolo UNIQUE.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-484">Creating a unique index (preferably by creating a UNIQUE constraint) is recommended in this case.</span></span>  
  
-   <span data-ttu-id="2bb2c-485">In un indice non cluster univoco possono essere contenute colonne non chiave.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-485">A unique nonclustered index can contain included nonkey columns.</span></span> <span data-ttu-id="2bb2c-486">Per altre informazioni, vedere [Indice con colonne incluse](#Included_Columns).</span><span class="sxs-lookup"><span data-stu-id="2bb2c-486">For more information, see [Index with Included Columns](#Included_Columns).</span></span>  
  
 <span data-ttu-id="2bb2c-487">![Icona freccia usata con il collegamento Torna all'inizio](media/uparrow16x16.gif "Icona freccia usata con il collegamento Torna all'inizio") [in questa guida](#Top)</span><span class="sxs-lookup"><span data-stu-id="2bb2c-487">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="filtered-index-design-guidelines"></a><a name="Filtered"></a> <span data-ttu-id="2bb2c-488">Linee guida per la progettazione di indici filtrati</span><span class="sxs-lookup"><span data-stu-id="2bb2c-488">Filtered Index Design Guidelines</span></span>  

 <span data-ttu-id="2bb2c-489">Un indice filtrato è un indice non cluster ottimizzato, particolarmente indicato per coprire query che selezionano dati da un subset ben definito.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-489">A filtered index is an optimized nonclustered index, especially suited to cover queries that select from a well-defined subset of data.</span></span> <span data-ttu-id="2bb2c-490">Un indice di questo tipo utilizza un predicato del filtro per indicizzare una parte di righe nella tabella.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-490">It uses a filter predicate to index a portion of rows in the table.</span></span> <span data-ttu-id="2bb2c-491">Se confrontato con indici di tabella completa, un indice filtrato progettato correttamente consente di migliorare le prestazioni di esecuzione delle query e di ridurre i costi di manutenzione e di archiviazione dell'indice stesso.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-491">A well-designed filtered index can improve query performance, reduce index maintenance costs, and reduce index storage costs compared with full-table indexes.</span></span>  
  
||  
|-|  
|<span data-ttu-id="2bb2c-492">**Si applica a**: [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] tramite [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span><span class="sxs-lookup"><span data-stu-id="2bb2c-492">**Applies to**: [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] through [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span>|  
  
 <span data-ttu-id="2bb2c-493">Rispetto agli indici di tabella completa, gli indici filtrati consentono di ottenere i vantaggi seguenti:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-493">Filtered indexes can provide the following advantages over full-table indexes:</span></span>  
  
-   <span data-ttu-id="2bb2c-494">**Prestazioni di esecuzione delle query e qualità del piano migliorate**</span><span class="sxs-lookup"><span data-stu-id="2bb2c-494">**Improved query performance and plan quality**</span></span>  
  
     <span data-ttu-id="2bb2c-495">Un indice filtrato progettato correttamente migliora le prestazioni di esecuzione delle query e la qualità del piano di esecuzione poiché è caratterizzato da dimensioni minori rispetto a un indice non cluster di tabella completa e dispone di statistiche filtrate.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-495">A well-designed filtered index improves query performance and execution plan quality because it is smaller than a full-table nonclustered index and has filtered statistics.</span></span> <span data-ttu-id="2bb2c-496">Queste ultime sono più accurate delle statistiche di tabella completa poiché coprono solo le righe nell'indice filtrato.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-496">The filtered statistics are more accurate than full-table statistics because they cover only the rows in the filtered index.</span></span>  
  
-   <span data-ttu-id="2bb2c-497">**Costi di manutenzione dell'indice ridotti**</span><span class="sxs-lookup"><span data-stu-id="2bb2c-497">**Reduced index maintenance costs**</span></span>  
  
     <span data-ttu-id="2bb2c-498">La manutenzione di un indice viene eseguita solo quando le istruzioni DML (Data Manipulation Language) influiscono sui dati relativi all'indice.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-498">An index is maintained only when data manipulation language (DML) statements affect the data in the index.</span></span> <span data-ttu-id="2bb2c-499">Un indice filtrato consente di ridurre i costi di manutenzione rispetto a un indice non cluster di tabella completa poiché è caratterizzato da dimensioni minori e viene gestito solo se i dati relativi sono interessati.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-499">A filtered index reduces index maintenance costs compared with a full-table nonclustered index because it is smaller and is only maintained when the data in the index is affected.</span></span> <span data-ttu-id="2bb2c-500">È possibile disporre di un numero elevato di indici filtrati, soprattutto quando questi ultimi contengono dati interessati raramente.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-500">It is possible to have a large number of filtered indexes, especially when they contain data that is affected infrequently.</span></span> <span data-ttu-id="2bb2c-501">In modo analogo, se un indice filtrato contiene dati interessati di frequente, la dimensione minore dell'indice consente di ridurre il costo di aggiornamento delle statistiche.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-501">Similarly, if a filtered index contains only the frequently affected data, the smaller size of the index reduces the cost of updating the statistics.</span></span>  
  
-   <span data-ttu-id="2bb2c-502">**Costi di archiviazione dell'indice ridotti**</span><span class="sxs-lookup"><span data-stu-id="2bb2c-502">**Reduced index storage costs**</span></span>  
  
     <span data-ttu-id="2bb2c-503">La creazione di un indice filtrato può ridurre lo spazio di archiviazione su disco per gli indici non cluster nel caso in cui non sia necessario un indice di tabella completa.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-503">Creating a filtered index can reduce disk storage for nonclustered indexes when a full-table index is not necessary.</span></span> <span data-ttu-id="2bb2c-504">È possibile sostituire un indice non cluster di tabella completa con più indici filtrati senza aumentare in modo significativo i requisiti di archiviazione.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-504">You can replace a full-table nonclustered index with multiple filtered indexes without significantly increasing the storage requirements.</span></span>  
  
 <span data-ttu-id="2bb2c-505">Gli indici filtrati risultano particolarmente utili quando le colonne contengono subset ben definiti di dati cui le query fanno riferimento nelle istruzioni SELECT.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-505">Filtered indexes are useful when columns contain well-defined subsets of data that queries reference in SELECT statements.</span></span> <span data-ttu-id="2bb2c-506">Alcuni esempi:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-506">Examples are:</span></span>  
  
-   <span data-ttu-id="2bb2c-507">Colonne di tipo sparse che contengono solo un numero limitato di valori non NULL.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-507">Sparse columns that contain only a few non-NULL values.</span></span>  
  
-   <span data-ttu-id="2bb2c-508">Colonne eterogenee che contengono categorie di dati.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-508">Heterogeneous columns that contain categories of data.</span></span>  
  
-   <span data-ttu-id="2bb2c-509">Colonne che contengono intervalli di valori diversi, ad esempio quantità di denaro, ore e date.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-509">Columns that contain ranges of values such as dollar amounts, time, and dates.</span></span>  
  
-   <span data-ttu-id="2bb2c-510">Partizioni di tabelle definite da logica di confronto semplice per i valori di colonna.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-510">Table partitions that are defined by simple comparison logic for column values.</span></span>  
  
 <span data-ttu-id="2bb2c-511">I costi di manutenzione ridotti ottenuti dall'utilizzo di indici filtrati sono più apprezzabili quando il numero di righe dell'indice non è elevato rispetto a quello di un indice di tabella completa.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-511">Reduced maintenance costs for filtered indexes are most noticeable when the number of rows in the index is small compared with a full-table index.</span></span> <span data-ttu-id="2bb2c-512">Se l'indice filtrato include la maggior parte delle righe della tabella, è possibile che i costi di manutenzione siano maggiori rispetto a quelli relativi a un indice di tabella completa.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-512">If the filtered index includes most of the rows in the table, it could cost more to maintain than a full-table index.</span></span> <span data-ttu-id="2bb2c-513">In questo caso è opportuno utilizzare un indice di tabella completa anziché un indice filtrato.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-513">In this case, you should use a full-table index instead of a filtered index.</span></span>  
  
 <span data-ttu-id="2bb2c-514">Gli indici filtrati sono definiti in una tabella e supportano solo operatori di confronto semplici.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-514">Filtered indexes are defined on one table and only support simple comparison operators.</span></span> <span data-ttu-id="2bb2c-515">Se è necessaria un'espressione di filtro in cui viene fatto riferimento a più tabelle o in cui è presente della logica complessa, è necessario creare una vista.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-515">If you need a filter expression that references multiple tables or has complex logic, you should create a view.</span></span>  
  
### <a name="design-considerations"></a><span data-ttu-id="2bb2c-516">Considerazioni sulla progettazione</span><span class="sxs-lookup"><span data-stu-id="2bb2c-516">Design Considerations</span></span>  

 <span data-ttu-id="2bb2c-517">Per progettare indici filtrati efficaci, è importante comprendere quali sono le query utilizzate dall'applicazione e il modo in cui sono correlate ai subset dei dati.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-517">In order to design effective filtered indexes, it is important to understand what queries your application uses and how they relate to subsets of your data.</span></span> <span data-ttu-id="2bb2c-518">Alcuni esempi di dati che dispongono di subset ben definiti sono costituiti da colonne con la maggior parte di valori NULL, colonne con categorie eterogenee di valori e colonne con intervalli di valori distinti.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-518">Some examples of data that have well-defined subsets are columns with mostly NULL values, columns with heterogeneous categories of values and columns with distinct ranges of values.</span></span> <span data-ttu-id="2bb2c-519">Nelle considerazioni sulla progettazione seguenti viene indicata una varietà di scenari in cui un indice filtrato può fornire vantaggi rispetto agli indici di tabella completa.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-519">The following design considerations give a variety of scenarios for when a filtered index can provide advantages over full-table indexes.</span></span>  
  
#### <a name="filtered-indexes-for-subsets-of-data"></a><span data-ttu-id="2bb2c-520">Indici filtrati per subset di dati</span><span class="sxs-lookup"><span data-stu-id="2bb2c-520">Filtered Indexes for Subsets of Data</span></span>  

 <span data-ttu-id="2bb2c-521">Quando una colonna dispone solo di un numero ridotto di valori rilevanti per le query, è possibile creare un indice filtrato sul subset di valori.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-521">When a column only has a small number of relevant values for queries, you can create a filtered index on the subset of values.</span></span> <span data-ttu-id="2bb2c-522">Ad esempio, quando la maggior parte dei valori di una colonna è costituita da valori NULL e la query esegue la selezione solo dai valori non NULL, è possibile creare un indice filtrato per le righe di dati non NULL.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-522">For example, when the values in a column are mostly NULL and the query selects only from the non-NULL values, you can create a filtered index for the non-NULL data rows.</span></span> <span data-ttu-id="2bb2c-523">L'indice risultante sarà minore e sarà possibile gestirlo con costi ridotti rispetto a un indice non cluster di tabella completa definito sulle stesse colonne chiave.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-523">The resulting index will be smaller and cost less to maintain than a full-table nonclustered index defined on the same key columns.</span></span>  
  
 <span data-ttu-id="2bb2c-524">Nel database `AdventureWorks2012` , ad esempio, è disponibile una tabella `Production.BillOfMaterials` con 2679 righe.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-524">For example, the `AdventureWorks2012` database has a `Production.BillOfMaterials` table with 2679 rows.</span></span> <span data-ttu-id="2bb2c-525">La colonna `EndDate` dispone solo di 199 righe che contengono un valore non NULL, mentre le altre 2480 righe contengono valori NULL.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-525">The `EndDate` column has only 199 rows that contain a non-NULL value and the other 2480 rows contain NULL.</span></span> <span data-ttu-id="2bb2c-526">L'indice filtrato seguente coprirà query che restituiscono le colonne definite nell'indice e che selezionano solo righe con un valore non NULL per `EndDate`.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-526">The following filtered index would cover queries that return the columns defined in the index and that select only rows with a non-NULL value for `EndDate`.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX FIBillOfMaterialsWithEndDate  
    ON Production.BillOfMaterials (ComponentID, StartDate)  
    WHERE EndDate IS NOT NULL ;  
GO  
```  
  
 <span data-ttu-id="2bb2c-527">L'indice filtrato `FIBillOfMaterialsWithEndDate` è valido per la query seguente.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-527">The filtered index `FIBillOfMaterialsWithEndDate` is valid for the following query.</span></span> <span data-ttu-id="2bb2c-528">È possibile visualizzare il piano di esecuzione della query per determinare se in Query Optimizer è stato utilizzato l'indice filtrato.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-528">You can display the query execution plan to determine if the query optimizer used the filtered index.</span></span>  
  
```sql
SELECT ProductAssemblyID, ComponentID, StartDate   
FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL   
    AND ComponentID = 5   
    AND StartDate > '20080101' ;  
```  
  
 <span data-ttu-id="2bb2c-529">Per altre informazioni sulla creazione di indici filtrati e sulla definizione dell'espressione del predicato dell'indice filtrato, vedere [Creare indici filtrati](../relational-databases/indexes/create-filtered-indexes.md).</span><span class="sxs-lookup"><span data-stu-id="2bb2c-529">For more information about how to create filtered indexes and how to define the filtered index predicate expression, see [Create Filtered Indexes](../relational-databases/indexes/create-filtered-indexes.md).</span></span>  
  
#### <a name="filtered-indexes-for-heterogeneous-data"></a><span data-ttu-id="2bb2c-530">Indici filtrati per dati eterogenei</span><span class="sxs-lookup"><span data-stu-id="2bb2c-530">Filtered Indexes for Heterogeneous Data</span></span>  

 <span data-ttu-id="2bb2c-531">Se in una tabella sono presenti righe di dati eterogenei, è possibile creare un indice filtrato per una o più categorie di dati.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-531">When a table has heterogeneous data rows, you can create a filtered index for one or more categories of data.</span></span>  
  
 <span data-ttu-id="2bb2c-532">Ogni prodotto elencato nella tabella `Production.Product` , ad esempio, è assegnato a un `ProductSubcategoryID`, associato a sua volta alle categorie di prodotti Bikes, Components, Clothing o Accessories.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-532">For example, the products listed in the `Production.Product` table are each assigned to a `ProductSubcategoryID`, which are in turn associated with the product categories Bikes, Components, Clothing, or Accessories.</span></span> <span data-ttu-id="2bb2c-533">Queste categorie sono eterogenee poiché i valori di colonna relativi nella tabella `Production.Product` non sono strettamente correlati.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-533">These categories are heterogeneous because their column values in the `Production.Product` table are not closely correlated.</span></span> <span data-ttu-id="2bb2c-534">Ad esempio, le colonne `Color`, `ReorderPoint`, `ListPrice`, `Weight`, `Class`e `Style` dispongono di caratteristiche univoche per ogni categoria di prodotti.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-534">For example, the columns `Color`, `ReorderPoint`, `ListPrice`, `Weight`, `Class`, and `Style` have unique characteristics for each product category.</span></span> <span data-ttu-id="2bb2c-535">Se vengono eseguite query frequenti sugli accessori con sottocategorie tra 27 e 36 inclusi,</span><span class="sxs-lookup"><span data-stu-id="2bb2c-535">Suppose that there are frequent queries for accessories which have subcategories between 27 and 36 inclusive.</span></span> <span data-ttu-id="2bb2c-536">è possibile migliorarne le prestazioni creando un indice filtrato nella sottocategoria degli accessori come mostrato nell'esempio riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-536">You can improve the performance of queries for accessories by creating a filtered index on the accessories subcategories as shown in the following example.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX FIProductAccessories  
    ON Production.Product (ProductSubcategoryID, ListPrice)   
        Include (Name)  
WHERE ProductSubcategoryID >= 27 AND ProductSubcategoryID <= 36;
```  
  
 <span data-ttu-id="2bb2c-537">L'indice filtrato `FIProductAccessories` si applica alla query seguente, in quanto i risultati</span><span class="sxs-lookup"><span data-stu-id="2bb2c-537">The filtered index `FIProductAccessories` covers the following query because the query</span></span>  
  
 <span data-ttu-id="2bb2c-538">della query sono contenuti nell'indice e il piano della query non include una ricerca nella tabella di base.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-538">results are contained in the index and the query plan does not include a base table lookup.</span></span> <span data-ttu-id="2bb2c-539">Ad esempio, l'espressione del predicato di query `ProductSubcategoryID = 33` è un subset del predicato dell'indice filtrato `ProductSubcategoryID >= 27` e `ProductSubcategoryID <= 36`, le colonne `ProductSubcategoryID` e `ListPrice` nel predicato di query sono entrambe colonne chiave nell'indice e il nome è archiviato al livello foglia dell'indice come colonna inclusa.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-539">For example, the query predicate expression `ProductSubcategoryID = 33` is a subset of the filtered index predicate `ProductSubcategoryID >= 27` and `ProductSubcategoryID <= 36`, the `ProductSubcategoryID` and `ListPrice` columns in the query predicate are both key columns in the index, and name is stored in the leaf level of the index as an included column.</span></span>  
  
```sql
SELECT Name, ProductSubcategoryID, ListPrice  
FROM Production.Product  
WHERE ProductSubcategoryID = 33 AND ListPrice > 25.00 ;  
```  
  
#### <a name="key-columns"></a><span data-ttu-id="2bb2c-540">Colonne chiave</span><span class="sxs-lookup"><span data-stu-id="2bb2c-540">Key Columns</span></span>  

 <span data-ttu-id="2bb2c-541">È consigliabile inserire un numero ridotto di colonne chiave o incluse in una definizione di indice filtrato e incorporare solo le colonne necessarie affinché Query Optimizer scelga l'indice filtrato per il piano di esecuzione della query.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-541">It is a best practice to include a small number of key or included columns in a filtered index definition, and to incorporate only the columns that are necessary for the query optimizer to choose the filtered index for the query execution plan.</span></span> <span data-ttu-id="2bb2c-542">Sebbene Query Optimizer possa scegliere un indice filtrato per la query indipendentemente dal fatto che la copra o meno,</span><span class="sxs-lookup"><span data-stu-id="2bb2c-542">The query optimizer can choose a filtered index for the query regardless of whether it does or does not cover the query.</span></span> <span data-ttu-id="2bb2c-543">tuttavia è più probabile che venga scelto un indice filtrato che copre la query.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-543">However, the query optimizer is more likely to choose a filtered index if it covers the query.</span></span>  
  
 <span data-ttu-id="2bb2c-544">In alcuni casi, un indice filtrato copre la query senza includere le colonne nell'espressione che lo definisce come colonne chiave o incluse nella definizione dell'indice stesso.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-544">In some cases, a filtered index covers the query without including the columns in the filtered index expression as key or included columns in the filtered index definition.</span></span> <span data-ttu-id="2bb2c-545">Le linee guida seguenti indicano quando una colonna nell'espressione che definisce l'indice filtrato deve essere una colonna chiave o inclusa nella definizione dell'indice filtrato stesso.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-545">The following guidelines explain when a column in the filtered index expression should be a key or included column in the filtered index definition.</span></span> <span data-ttu-id="2bb2c-546">Gli esempi si riferiscono all'indice filtrato `FIBillOfMaterialsWithEndDate` creato in precedenza.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-546">The examples refer to the filtered index, `FIBillOfMaterialsWithEndDate` that was created previously.</span></span>  
  
 <span data-ttu-id="2bb2c-547">Non è necessario che una colonna nell'espressione che definisce l'indice filtrato sia una colonna chiave o inclusa nella definizione dell'indice stesso se l'espressione che definisce l'indice filtrato è equivalente al predicato della query e la query non restituisce la colonna in tale espressione con i risultati della query.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-547">A column in the filtered index expression does not need to be a key or included column in the filtered index definition if the filtered index expression is equivalent to the query predicate and the query does not return the column in the filtered index expression with the query results.</span></span> <span data-ttu-id="2bb2c-548">L'indice `FIBillOfMaterialsWithEndDate` , ad esempio, copre la query seguente perché il predicato della query è equivalente all'espressione di filtro ed `EndDate` non viene restituito con i risultati della query.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-548">For example, `FIBillOfMaterialsWithEndDate` covers the following query because the query predicate is equivalent to the filter expression, and `EndDate` is not returned with the query results.</span></span> <span data-ttu-id="2bb2c-549">`FIBillOfMaterialsWithEndDate` non ha bisogno di `EndDate` come colonna chiave o inclusa nella definizione dell'indice filtrato.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-549">`FIBillOfMaterialsWithEndDate` does not need `EndDate` as a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL;   
```  
  
 <span data-ttu-id="2bb2c-550">Una colonna nell'espressione che definisce l'indice filtrato deve essere una colonna chiave o inclusa nella definizione dell'indice se il predicato della query la utilizza in un confronto non equivalente all'espressione che definisce l'indice filtrato.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-550">A column in the filtered index expression should be a key or included column in the filtered index definition if the query predicate uses the column in a comparison that is not equivalent to the filtered index expression.</span></span> <span data-ttu-id="2bb2c-551">L'indice `FIBillOfMaterialsWithEndDate` , ad esempio, è valido per la query seguente perché seleziona un subset di righe dall'indice filtrato.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-551">For example, `FIBillOfMaterialsWithEndDate` is valid for the following query because it selects a subset of rows from the filtered index.</span></span> <span data-ttu-id="2bb2c-552">Tale indice tuttavia non copre la query poiché `EndDate` viene utilizzato nel confronto `EndDate > '20040101'`, che non è equivalente all'espressione che definisce l'indice filtrato.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-552">However, it does not cover the following query because `EndDate` is used in the comparison `EndDate > '20040101'`, which is not equivalent to the filtered index expression.</span></span> <span data-ttu-id="2bb2c-553">Poiché Query Processor non è in grado di eseguire questa query senza cercare i valori di `EndDate`,</span><span class="sxs-lookup"><span data-stu-id="2bb2c-553">The query processor cannot execute this query without looking up the values of `EndDate`.</span></span> <span data-ttu-id="2bb2c-554">Di conseguenza, `EndDate` deve essere una colonna chiave o inclusa nella definizione dell'indice filtrato.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-554">Therefore, `EndDate` should be a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate FROM Production.BillOfMaterials  
WHERE EndDate > '20040101';   
```  
  
 <span data-ttu-id="2bb2c-555">Una colonna nell'espressione che definisce l'indice filtrato deve essere una colonna chiave o inclusa nella definizione dell'indice se è presente nel set di risultati della query.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-555">A column in the filtered index expression should be a key or included column in the filtered index definition if the column is in the query result set.</span></span> <span data-ttu-id="2bb2c-556">L'indice `FIBillOfMaterialsWithEndDate` , ad esempio, non copre la query seguente perché restituisce la colonna `EndDate` nei risultati della query.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-556">For example, `FIBillOfMaterialsWithEndDate` does not cover the following query because it returns the `EndDate` column in the query results.</span></span> <span data-ttu-id="2bb2c-557">Di conseguenza, `EndDate` deve essere una colonna chiave o inclusa nella definizione dell'indice filtrato.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-557">Therefore, `EndDate` should be a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate, EndDate FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL;  
```  
  
 <span data-ttu-id="2bb2c-558">Non è necessario che la chiave di indice cluster della tabella sia una colonna chiave o inclusa nella definizione dell'indice filtrato</span><span class="sxs-lookup"><span data-stu-id="2bb2c-558">The clustered index key of the table does not need to be a key or included column in the filtered index definition.</span></span> <span data-ttu-id="2bb2c-559">poiché viene inclusa automaticamente in tutti gli indici non cluster, inclusi quelli filtrati.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-559">The clustered index key is automatically included in all nonclustered indexes, including filtered indexes.</span></span>  
  
#### <a name="data-conversion-operators-in-the-filter-predicate"></a><span data-ttu-id="2bb2c-560">Operatori di conversione dei dati nel predicato del filtro</span><span class="sxs-lookup"><span data-stu-id="2bb2c-560">Data Conversion Operators in the Filter Predicate</span></span>  

 <span data-ttu-id="2bb2c-561">Se l'operatore di confronto specificato nell'espressione che definisce l'indice filtrato determina una conversione dei dati implicita o esplicita, si verificherà un errore se la conversione viene eseguita sul lato sinistro di un operatore di confronto.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-561">If the comparison operator specified in the filtered index expression of the filtered index results in an implicit or explicit data conversion, an error will occur if the conversion occurs on the left side of a comparison operator.</span></span> <span data-ttu-id="2bb2c-562">Una soluzione consiste nello scrivere l'espressione che definisce l'indice filtrato con l'operatore di conversione dei dati (CAST o CONVERT) sul lato destro dell'operatore di confronto.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-562">A solution is to write the filtered index expression with the data conversion operator (CAST or CONVERT) on the right side of the comparison operator.</span></span>  
  
 <span data-ttu-id="2bb2c-563">Nell'esempio seguente viene creata una tabella con tipi di dati diversi.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-563">The following example creates a table with a variety of data types.</span></span>  
  
```sql
USE AdventureWorks2012;  
GO  
CREATE TABLE dbo.TestTable (a int, b varbinary(4));  
```  
  
 <span data-ttu-id="2bb2c-564">Nella definizione dell'indice filtrato seguente la colonna `b` viene convertita implicitamente a un tipo di dati integer per eseguire il confronto con la costante 1.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-564">In the following filtered index definition, column `b` is implicitly converted to an integer data type for the purpose of comparing it to the constant 1.</span></span> <span data-ttu-id="2bb2c-565">Verrà generato un messaggio di errore 10611 poiché la conversione viene eseguita sul lato sinistro dell'operatore nel predicato filtrato.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-565">This generates error message 10611 because the conversion occurs on the left hand side of the operator in the filtered predicate.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX TestTabIndex ON dbo.TestTable(a,b)  
WHERE b = 1;  
```  
  
 <span data-ttu-id="2bb2c-566">La soluzione consiste nel convertire la costante sul lato destro in modo che sia dello stesso tipo della colonna `b`, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="2bb2c-566">The solution is to convert the constant on the right hand side to be of the same type as column `b`, as seen in the following example:</span></span>  
  
```sql
CREATE INDEX TestTabIndex ON dbo.TestTable(a,b)  
WHERE b = CONVERT(Varbinary(4), 1);  
```  
  
 <span data-ttu-id="2bb2c-567">Lo spostamento della conversione dei dati dal lato sinistro a quello destro di un operatore di confronto potrebbe modificare il significato della conversione.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-567">Moving the data conversion from the left side to the right side of a comparison operator might change the meaning of the conversion.</span></span> <span data-ttu-id="2bb2c-568">Nell'esempio precedente, quando l'operatore CONVERT è stato aggiunto al lato destro, il confronto è stato modificato da un confronto di un tipo integer in un confronto di tipo `varbinary`.</span><span class="sxs-lookup"><span data-stu-id="2bb2c-568">In the above example, when the CONVERT operator was added to the right side, the comparison changed from an integer comparison to a `varbinary` comparison.</span></span>  
  
 <span data-ttu-id="2bb2c-569">![Icona freccia usata con il collegamento Torna all'inizio](media/uparrow16x16.gif "Icona freccia usata con il collegamento Torna all'inizio") [in questa guida](#Top)</span><span class="sxs-lookup"><span data-stu-id="2bb2c-569">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="additional-reading"></a><a name="Additional_Reading"></a> <span data-ttu-id="2bb2c-570">Ulteriori informazioni</span><span class="sxs-lookup"><span data-stu-id="2bb2c-570">Additional Reading</span></span>  

 <span data-ttu-id="2bb2c-571">[Miglioramento delle prestazioni con le viste indicizzate di SQL Server 2008](https://msdn.microsoft.com/library/dd171921(v=sql.100).aspx)</span><span class="sxs-lookup"><span data-stu-id="2bb2c-571">[Improving Performance with SQL Server 2008 Indexed Views](https://msdn.microsoft.com/library/dd171921(v=sql.100).aspx)</span></span>  
  
 [<span data-ttu-id="2bb2c-572">Tabelle e indici partizionati</span><span class="sxs-lookup"><span data-stu-id="2bb2c-572">Partitioned Tables and Indexes</span></span>](../relational-databases/partitions/partitioned-tables-and-indexes.md)  
  
  
