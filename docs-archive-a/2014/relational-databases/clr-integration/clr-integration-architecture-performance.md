---
title: Prestazioni dell'integrazione con CLR | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: clr
ms.topic: reference
helpviewer_keywords:
- common language runtime [SQL Server], performance
- common language runtime [SQL Server], compilation process
- performance [CLR integration]
ms.assetid: 7ce2dfc0-4b1f-4dcb-a979-2c4f95b4cb15
author: rothja
ms.author: jroth
ms.openlocfilehash: 33e45039ed98ea3df607df1714b3c6108ec17c35
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/04/2020
ms.locfileid: "87720021"
---
# <a name="performance-of-clr-integration"></a><span data-ttu-id="7410e-102">Prestazioni dell'integrazione con CLR</span><span class="sxs-lookup"><span data-stu-id="7410e-102">Performance of CLR Integration</span></span>
  <span data-ttu-id="7410e-103">In questo argomento vengono illustrate alcune delle scelte di progettazione che migliorano le prestazioni dell' [!INCLUDE[msCoName](../../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] integrazione con il [!INCLUDE[msCoName](../../../includes/msconame-md.md)] .NET Framework Common Language Runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="7410e-103">This topic discusses some of the design choices that enhance the performance of [!INCLUDE[msCoName](../../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] integration with the [!INCLUDE[msCoName](../../../includes/msconame-md.md)] .NET Framework common language runtime (CLR).</span></span>  
  
## <a name="the-compilation-process"></a><span data-ttu-id="7410e-104">Processo di compilazione</span><span class="sxs-lookup"><span data-stu-id="7410e-104">The Compilation Process</span></span>  
 <span data-ttu-id="7410e-105">Durante la compilazione di espressioni SQL, quando viene rilevato un riferimento a una routine gestita, viene generato uno stub di [!INCLUDE[msCoName](../../../includes/msconame-md.md)] Intermediate Language (MSIL).</span><span class="sxs-lookup"><span data-stu-id="7410e-105">During compilation of SQL expressions, when a reference to a managed routine is encountered, a [!INCLUDE[msCoName](../../../includes/msconame-md.md)] intermediate language (MSIL) stub is generated.</span></span> <span data-ttu-id="7410e-106">Questo stub include il codice che consente di effettuare il marshalling dei parametri di routine da [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] a CLR, richiamare la funzione e restituire il risultato.</span><span class="sxs-lookup"><span data-stu-id="7410e-106">This stub includes code to marshal the routine parameters from [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to the CLR, invoke the function, and return the result.</span></span> <span data-ttu-id="7410e-107">Questo codice di "unione" si basa sul tipo di parametro e sulla direzione del parametro (interna, esterna o di riferimento).</span><span class="sxs-lookup"><span data-stu-id="7410e-107">This "glue" code is based on the type of parameter and on parameter direction (in, out, or reference).</span></span>  
  
 <span data-ttu-id="7410e-108">Il codice di "unione" consente di eseguire ottimizzazioni specifiche del tipo e assicura un'applicazione efficiente della semantica di [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], ad esempio il supporto di valori Null, i facet vincolanti e la gestione delle eccezioni standard e in base al valore.</span><span class="sxs-lookup"><span data-stu-id="7410e-108">The glue code enables type-specific optimizations and ensures efficient enforcement of [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] semantics, such as nullability, constraining facets, by-value, and standard exception handling.</span></span> <span data-ttu-id="7410e-109">La generazione di codice apposito per i tipi degli argomenti consente di evitare i costi legati all'assegnazione forzata o alla creazione di oggetti wrapper, chiamata "boxing", all'interno dei limiti della chiamata.</span><span class="sxs-lookup"><span data-stu-id="7410e-109">By generating code for the exact types of the arguments, you avoid type coercion or wrapper object creation costs (called "boxing") across the invocation boundary.</span></span>  
  
 <span data-ttu-id="7410e-110">Lo stub generato viene quindi compilato nel codice nativo e ottimizzato per l'architettura hardware specifica su cui viene eseguito [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], utilizzando i servizi di compilazione JIT (Just-In-Time) di CLR.</span><span class="sxs-lookup"><span data-stu-id="7410e-110">The generated stub is then compiled to native code and optimized for the particular hardware architecture on which [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] executes, using the JIT (just-in-time) compilation services of the CLR.</span></span> <span data-ttu-id="7410e-111">I servizi JIT sono richiamati a livello di metodo e consentono all'ambiente host di [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] di creare una sola unità di compilazione che comprende sia [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] che l'esecuzione di CLR.</span><span class="sxs-lookup"><span data-stu-id="7410e-111">The JIT services are invoked at the method level and allow the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] hosting environment to create a single compilation unit that spans both [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and CLR execution.</span></span> <span data-ttu-id="7410e-112">Dopo aver compilato lo stub, il puntatore a funzione risultante diventa l'implementazione in fase di esecuzione della funzione.</span><span class="sxs-lookup"><span data-stu-id="7410e-112">Once the stub is compiled, the resulting function pointer becomes the run-time implementation of the function.</span></span> <span data-ttu-id="7410e-113">Questo approccio che prevede la generazione di codice consente di evitare i costi di chiamata aggiuntivi relativi alla riflessione o all'accesso ai metadati in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="7410e-113">This code generation approach ensures that there are no additional invocation costs related to reflection or metadata access at run time.</span></span>  
  
### <a name="fast-transitions-between-sql-server-and-clr"></a><span data-ttu-id="7410e-114">Transizioni veloci tra SQL Server e CLR</span><span class="sxs-lookup"><span data-stu-id="7410e-114">Fast Transitions Between SQL Server and CLR</span></span>  
 <span data-ttu-id="7410e-115">Il processo di compilazione restituisce un puntatore a funzione che può essere chiamato in fase di esecuzione dal codice nativo.</span><span class="sxs-lookup"><span data-stu-id="7410e-115">The compilation process yields a function pointer that can be called at run time from native code.</span></span> <span data-ttu-id="7410e-116">Nel caso di funzioni definite dall'utente a valori scalari, questa chiamata alla funzione avviene su ogni riga.</span><span class="sxs-lookup"><span data-stu-id="7410e-116">In the case of scalar-valued user-defined functions, this function invocation happens on a per-row basis.</span></span> <span data-ttu-id="7410e-117">Per ridurre al minimo il costo della transizione tra [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] e CLR, le istruzioni che contengono chiamate gestite prevedono un passaggio di avvio per identificare il dominio dell'applicazione di destinazione.</span><span class="sxs-lookup"><span data-stu-id="7410e-117">To minimize the cost of transitioning between [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and the CLR, statements that contain any managed invocation have a startup step to identify the target application domain.</span></span> <span data-ttu-id="7410e-118">Questo passaggio di identificazione riduce il costo della transizione per ogni riga.</span><span class="sxs-lookup"><span data-stu-id="7410e-118">This identification step reduces the cost of transitioning for each row.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="7410e-119">Considerazioni sulle prestazioni</span><span class="sxs-lookup"><span data-stu-id="7410e-119">Performance Considerations</span></span>  
 <span data-ttu-id="7410e-120">Nelle sezioni che seguono vengono riepilogate le considerazioni relative alle prestazioni specifiche dell'integrazione con CLR in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="7410e-120">The following summarizes performance considerations specific to CLR integration in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="7410e-121">Per informazioni più dettagliate, vedere l'argomento relativo all'[uso dell'integrazione con CLR in SQL Server 2005](https://go.microsoft.com/fwlink/?LinkId=50332)sul sito Web MSDN.</span><span class="sxs-lookup"><span data-stu-id="7410e-121">More detailed information can be found in "[Using CLR Integration in SQL Server 2005](https://go.microsoft.com/fwlink/?LinkId=50332)" on the MSDN Web site.</span></span> <span data-ttu-id="7410e-122">Informazioni generali sulle prestazioni del codice gestito sono disponibili in "[miglioramento delle prestazioni e della scalabilità delle applicazioni .NET](https://go.microsoft.com/fwlink/?LinkId=50333)" sul sito Web MSDN.</span><span class="sxs-lookup"><span data-stu-id="7410e-122">General information regarding managed code performance can be found in "[Improving .NET Application Performance and Scalability](https://go.microsoft.com/fwlink/?LinkId=50333)" on the MSDN Web site.</span></span>  
  
### <a name="user-defined-functions"></a><span data-ttu-id="7410e-123">Funzioni definite dall'utente</span><span class="sxs-lookup"><span data-stu-id="7410e-123">User-Defined Functions</span></span>  
 <span data-ttu-id="7410e-124">Il percorso di chiamata per le funzioni CLR risulta più veloce di quello delle funzioni definite dall'utente [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="7410e-124">CLR functions benefit from a quicker invocation path than that of [!INCLUDE[tsql](../../../includes/tsql-md.md)] user-defined functions.</span></span> <span data-ttu-id="7410e-125">Il codice gestito dispone inoltre di un vantaggio in termini di prestazioni decisamente superiore rispetto a [!INCLUDE[tsql](../../../includes/tsql-md.md)] per quanto riguarda il codice procedurale, il calcolo e la manipolazione delle stringhe.</span><span class="sxs-lookup"><span data-stu-id="7410e-125">Additionally, managed code has a decisive performance advantage over [!INCLUDE[tsql](../../../includes/tsql-md.md)] in terms of procedural code, computation, and string manipulation.</span></span> <span data-ttu-id="7410e-126">Le funzioni CLR che prevedono intense attività di calcolo e che non eseguono l'accesso ai dati vengono scritte meglio in codice gestito.</span><span class="sxs-lookup"><span data-stu-id="7410e-126">CLR functions that are computing-intensive and that do not perform data access are better written in managed code.</span></span> <span data-ttu-id="7410e-127">Le funzioni [!INCLUDE[tsql](../../../includes/tsql-md.md)] tuttavia, eseguono l'accesso ai dati più efficientemente rispetto all'integrazione CLR.</span><span class="sxs-lookup"><span data-stu-id="7410e-127">[!INCLUDE[tsql](../../../includes/tsql-md.md)] functions do, however, perform data access more efficiently than CLR integration.</span></span>  
  
### <a name="user-defined-aggregates"></a><span data-ttu-id="7410e-128">Funzioni di aggregazione definite dall'utente</span><span class="sxs-lookup"><span data-stu-id="7410e-128">User-Defined Aggregates</span></span>  
 <span data-ttu-id="7410e-129">Il codice gestito può determinare prestazioni notevolmente superiori rispetto all'aggregazione basata sul cursore.</span><span class="sxs-lookup"><span data-stu-id="7410e-129">Managed code can significantly outperform cursor-based aggregation.</span></span> <span data-ttu-id="7410e-130">Il codice gestito generalmente risulta leggermente più lento rispetto alle funzioni di aggregazione di [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] incorporate.</span><span class="sxs-lookup"><span data-stu-id="7410e-130">Managed code generally performs slightly slower than built-in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] aggregate functions.</span></span> <span data-ttu-id="7410e-131">Se esiste una funzione di aggregazione predefinita nativa, è consigliabile utilizzarla.</span><span class="sxs-lookup"><span data-stu-id="7410e-131">We recommend that if a native built-in aggregate function exists, you should use it.</span></span> <span data-ttu-id="7410e-132">Nei casi in cui l'aggregazione necessaria non è supportata a livello nativo, è opportuno utilizzare un'aggregazione definita dall'utente CLR su un'implementazione basata sul cursore per migliorare le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="7410e-132">In cases in which the needed aggregation is not natively supported, consider a CLR user-defined aggregate over a cursor-based implementation for performance reasons.</span></span>  
  
### <a name="streaming-table-valued-functions"></a><span data-ttu-id="7410e-133">STVF (Streaming Table-Valued Function, Funzioni di flusso con valori di tabella)</span><span class="sxs-lookup"><span data-stu-id="7410e-133">Streaming Table-Valued Functions</span></span>  
 <span data-ttu-id="7410e-134">Le applicazioni spesso devono restituire una tabella come risultato della chiamata di una funzione.</span><span class="sxs-lookup"><span data-stu-id="7410e-134">Applications often need to return a table as a result of invoking a function.</span></span> <span data-ttu-id="7410e-135">Gli esempi includono la lettura di dati tabulari da un file nell'ambito di un'operazione di importazione e la conversione di valori delimitati da virgole in una rappresentazione relazionale.</span><span class="sxs-lookup"><span data-stu-id="7410e-135">Examples include reading tabular data from a file as part of an import operation, and converting comma-separated-values to a relational representation.</span></span> <span data-ttu-id="7410e-136">Per effettuare queste operazioni in genere è necessario materializzare e popolare la tabella dei risultati prima che possa essere utilizzata dal chiamante.</span><span class="sxs-lookup"><span data-stu-id="7410e-136">Typically, you can accomplish this by materializing and populating the result table before it can be consumed by the caller.</span></span> <span data-ttu-id="7410e-137">L'integrazione di CLR in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] introduce un nuovo meccanismo di extensibility definito tabella di streaming con valori di tabella (STVF, streaming table-valued function).</span><span class="sxs-lookup"><span data-stu-id="7410e-137">The integration of the CLR into [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] introduces a new extensibility mechanism called a streaming table-valued function (STVF).</span></span> <span data-ttu-id="7410e-138">Le funzioni di flusso con valori di tabella offrono prestazioni migliori rispetto alle implementazioni delle stored procedure estese confrontabili.</span><span class="sxs-lookup"><span data-stu-id="7410e-138">Managed STVFs perform better than comparable extended stored procedure implementations.</span></span>  
  
 <span data-ttu-id="7410e-139">Le funzioni di flusso con valori di tabella sono funzioni gestite che restituiscono un'interfaccia `IEnumerable`.</span><span class="sxs-lookup"><span data-stu-id="7410e-139">STVFs are managed functions that return an `IEnumerable` interface.</span></span> <span data-ttu-id="7410e-140">`IEnumerable` dispone di metodi per spostarsi all'interno del set di risultati restituito da STVF.</span><span class="sxs-lookup"><span data-stu-id="7410e-140">`IEnumerable` has methods to navigate the result set returned by the STVF.</span></span> <span data-ttu-id="7410e-141">Quando viene richiamata la funzione, l'interfaccia `IEnumerable` restituita viene connessa direttamente al piano di query.</span><span class="sxs-lookup"><span data-stu-id="7410e-141">When the STVF is invoked, the returned `IEnumerable` is directly connected to the query plan.</span></span> <span data-ttu-id="7410e-142">Il piano di query chiama quindi i metodi `IEnumerable` qualora sia necessario recuperare righe.</span><span class="sxs-lookup"><span data-stu-id="7410e-142">The query plan calls `IEnumerable` methods when it needs to fetch rows.</span></span> <span data-ttu-id="7410e-143">Questo modello di iterazione consente di utilizzare immediatamente i risultati subito dopo la produzione della prima riga, anziché dover attendere che venga popolata l'intera tabella.</span><span class="sxs-lookup"><span data-stu-id="7410e-143">This iteration model allows results to be consumed immediately after the first row is produced, instead of waiting until the entire table is populated.</span></span> <span data-ttu-id="7410e-144">Riduce inoltre significativamente la quantità di memoria utilizzata quando si richiama la funzione.</span><span class="sxs-lookup"><span data-stu-id="7410e-144">It also significantly reduces the memory consumed by invoking the function.</span></span>  
  
### <a name="arrays-vs-cursors"></a><span data-ttu-id="7410e-145">Confronto tra matrici e cursori</span><span class="sxs-lookup"><span data-stu-id="7410e-145">Arrays vs. Cursors</span></span>  
 <span data-ttu-id="7410e-146">Quando i cursori [!INCLUDE[tsql](../../../includes/tsql-md.md)] devono attraversare i dati che sono espressi più facilmente come una matrice, è possibile utilizzare il codice gestito per ottenere prestazioni di gran lunga superiori.</span><span class="sxs-lookup"><span data-stu-id="7410e-146">When [!INCLUDE[tsql](../../../includes/tsql-md.md)] cursors must traverse data that is more easily expressed as an array, managed code can be used with significant performance gains.</span></span>  
  
### <a name="string-data"></a><span data-ttu-id="7410e-147">Dati di tipo stringa</span><span class="sxs-lookup"><span data-stu-id="7410e-147">String Data</span></span>  
 <span data-ttu-id="7410e-148">I dati di tipo carattere [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], ad esempio `varchar`, possono appartenere al tipo SqlString o SqlChars nelle funzioni gestite.</span><span class="sxs-lookup"><span data-stu-id="7410e-148">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] character data, such as `varchar`, can be of the type SqlString or SqlChars in managed functions.</span></span> <span data-ttu-id="7410e-149">Le variabili SqlString creano un'istanza dell'intero valore in memoria.</span><span class="sxs-lookup"><span data-stu-id="7410e-149">SqlString variables create an instance of the entire value into memory.</span></span> <span data-ttu-id="7410e-150">Le variabili SqlChars forniscono un'interfaccia di flusso che può essere utilizzata per ottenere prestazioni migliori e una maggiore scalabilità creando un'istanza dell'intero valore in memoria.</span><span class="sxs-lookup"><span data-stu-id="7410e-150">SqlChars variables provide a streaming interface that can be used to achieve better performance and scalability by not creating an instance of the entire value into memory.</span></span> <span data-ttu-id="7410e-151">Questo diventa particolarmente importante per i dati di tipo LOB.</span><span class="sxs-lookup"><span data-stu-id="7410e-151">This becomes particularly important for large object (LOB) data.</span></span> <span data-ttu-id="7410e-152">È inoltre possibile accedere ai dati XML del server tramite un'interfaccia di flusso restituita da `SqlXml.CreateReader()`.</span><span class="sxs-lookup"><span data-stu-id="7410e-152">Additionally, server XML data can be accessed through a streaming interface returned by `SqlXml.CreateReader()`.</span></span>  
  
### <a name="clr-vs-extended-stored-procedures"></a><span data-ttu-id="7410e-153">Confronto tra CLR e stored procedure estese</span><span class="sxs-lookup"><span data-stu-id="7410e-153">CLR vs. Extended Stored Procedures</span></span>  
 <span data-ttu-id="7410e-154">Le API Microsoft.SqlServer.Server che consentono alle procedure gestite di inviare di nuovo i set di risultati al client offrono prestazioni migliori rispetto alle API ODS (Open Data Services) utilizzate dalle stored procedure estese.</span><span class="sxs-lookup"><span data-stu-id="7410e-154">The Microsoft.SqlServer.Server application programming interfaces (APIs) that allow managed procedures to send result sets back to the client perform better than the Open Data Services (ODS) APIs used by extended stored procedures.</span></span> <span data-ttu-id="7410e-155">Inoltre, le API System.Data.SqlServer supportano tipi di dati come `xml`, `varchar(max)`, `nvarchar(max)`e `varbinary(max)`, introdotti in [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)], mentre le API ODS non sono state estese per supportare i nuovi tipi di dati.</span><span class="sxs-lookup"><span data-stu-id="7410e-155">Furthermore, the System.Data.SqlServer APIs support data types such as `xml`, `varchar(max)`, `nvarchar(max)`, and `varbinary(max)`, introduced in [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)], while the ODS APIs have not been extended to support the new data types.</span></span>  
  
 <span data-ttu-id="7410e-156">Con il codice gestito, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] gestisce l'utilizzo di risorse come la memoria, i thread e la sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="7410e-156">With managed code, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] manages use of resources such as memory, threads, and synchronization.</span></span> <span data-ttu-id="7410e-157">Questo accade in quanto le API gestite che espongono queste risorse vengono implementate nello strumento di gestione delle risorse di [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="7410e-157">This is because the managed APIs that expose these resources are implemented on top of the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] resource manager.</span></span> <span data-ttu-id="7410e-158">Viceversa, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] non dispone di una vista o di un controllo sull'utilizzo delle risorse della stored procedure estesa.</span><span class="sxs-lookup"><span data-stu-id="7410e-158">Conversely, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] has no view or control over the resource usage of the extended stored procedure.</span></span> <span data-ttu-id="7410e-159">Se, ad esempio, un stored procedure esteso utilizza una quantità eccessiva di risorse di CPU o di memoria, non è possibile rilevare o controllare questa operazione con [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="7410e-159">For example, if an extended stored procedure consumes too much CPU or memory resources, there is no way to detect or control this with [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="7410e-160">Il codice gestito consente tuttavia a [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] di rilevare che un determinato thread non è stato prodotto per un lungo periodo di tempo e quindi imporre l'esecuzione dell'attività in modo da poter pianificare altro lavoro.</span><span class="sxs-lookup"><span data-stu-id="7410e-160">With managed code, however, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can detect that a given thread has not yielded for a long period of time, and then force the task to yield so that other work can be scheduled.</span></span> <span data-ttu-id="7410e-161">Di conseguenza, l'utilizzo di codice gestito offre una maggiore scalabilità e un miglior utilizzo delle risorse di sistema.</span><span class="sxs-lookup"><span data-stu-id="7410e-161">Consequently, using managed code provides for better scalability and system resource usage.</span></span>  
  
 <span data-ttu-id="7410e-162">Il codice gestito può determinare un overhead aggiuntivo, necessario per gestire l'ambiente di esecuzione ed eseguire controlli di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="7410e-162">Managed code may incur additional overhead necessary to maintain the execution environment and perform security checks.</span></span> <span data-ttu-id="7410e-163">Ciò avviene, ad esempio, qualora siano necessarie l'esecuzione all'interno di [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] e numerose transizioni da codice gestito a codice nativo. [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] richiede infatti l'esecuzione di una manutenzione aggiuntiva sulle impostazioni specifiche del thread se si passa dal codice nativo a un altro tipo di codice, quindi si utilizza di nuovo il codice nativo.</span><span class="sxs-lookup"><span data-stu-id="7410e-163">This is the case, for example, when running inside [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and numerous transitions from managed to native code are required (because [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] needs to do additional maintenance on thread-specific settings when moving out to native code and back).</span></span> <span data-ttu-id="7410e-164">Di conseguenza, le stored procedure estese possono offrire prestazioni nettamente superiori rispetto al codice gestito in esecuzione all'interno di [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] nelle situazioni in cui le transizioni tra codice gestito e codice nativo sono frequenti.</span><span class="sxs-lookup"><span data-stu-id="7410e-164">Consequently, extended stored procedures can significantly outperform managed code running inside [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for cases in which there are frequent transitions between managed and native code.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="7410e-165">È consigliabile non sviluppare nuove stored procedure estese, in quanto questa caratteristica è deprecata.</span><span class="sxs-lookup"><span data-stu-id="7410e-165">It is recommended that you do not develop new extended stored procedures, because this feature has been deprecated.</span></span>  
  
### <a name="native-serialization-for-user-defined-types"></a><span data-ttu-id="7410e-166">Serializzazione nativa per i tipi definiti dall'utente</span><span class="sxs-lookup"><span data-stu-id="7410e-166">Native Serialization for User-Defined Types</span></span>  
 <span data-ttu-id="7410e-167">I tipi definiti dall'utente sono progettati come un meccanismo di extensibility per il sistema di tipo scalare.</span><span class="sxs-lookup"><span data-stu-id="7410e-167">User-defined types (UDTs) are designed as an extensibility mechanism for the scalar type system.</span></span> <span data-ttu-id="7410e-168">In [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] è implementato un formato di serializzazione per i tipi definiti dall'utente denominati `Format.Native`.</span><span class="sxs-lookup"><span data-stu-id="7410e-168">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] implements a serialization format for UDTs called `Format.Native`.</span></span> <span data-ttu-id="7410e-169">Durante la compilazione, la struttura del tipo viene esaminata per generare un codice MSIL personalizzato per la definizione del tipo specifico.</span><span class="sxs-lookup"><span data-stu-id="7410e-169">During compilation, the structure of the type is examined to generate MSIL that is customized for that particular type definition.</span></span>  
  
 <span data-ttu-id="7410e-170">La serializzazione nativa è l'implementazione predefinita per [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="7410e-170">Native serialization is the default implementation for [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="7410e-171">La serializzazione definita dall'utente richiama un metodo definito dall'autore del tipo per eseguire la serializzazione.</span><span class="sxs-lookup"><span data-stu-id="7410e-171">User-defined serialization invokes a method defined by the type author to do the serialization.</span></span> <span data-ttu-id="7410e-172">La serializzazione `Format.Native` deve essere utilizzata quando possibile per ottenere prestazioni ottimali.</span><span class="sxs-lookup"><span data-stu-id="7410e-172">`Format.Native` serialization should be used when possible for best performance.</span></span>  
  
### <a name="normalization-of-comparable-udts"></a><span data-ttu-id="7410e-173">Normalizzazione dei tipi definiti dall'utente confrontabili</span><span class="sxs-lookup"><span data-stu-id="7410e-173">Normalization of Comparable UDTs</span></span>  
 <span data-ttu-id="7410e-174">Le operazioni relazionali, ad esempio l'ordinamento e il confronto dei tipi definiti dall'utente, agiscono direttamente sulla rappresentazione binaria del valore.</span><span class="sxs-lookup"><span data-stu-id="7410e-174">Relational operations, such as sorting and comparing UDTs, operate directly on the binary representation of the value.</span></span> <span data-ttu-id="7410e-175">A tale scopo, è necessario archiviare una rappresentazione normalizzata (con ordinamento binario) dello stato del tipo definito dall'utente su disco.</span><span class="sxs-lookup"><span data-stu-id="7410e-175">This is accomplished by storing a normalized (binary ordered) representation of the state of the UDT on disk.</span></span>  
  
 <span data-ttu-id="7410e-176">La normalizzazione presenta due vantaggi: rende l'operazione di confronto molto meno costosa evitando la costruzione dell'istanza del tipo e l'overhead della chiamata al metodo e crea un dominio binario per il tipo definito dall'utente, consentendo la costruzione di istogrammi, indici e istogrammi per i valori del tipo.</span><span class="sxs-lookup"><span data-stu-id="7410e-176">Normalization has two benefits: it makes the comparison operation considerably less expensive by avoiding the construction of the type instance and the method invocation overhead; and it creates a binary domain for the UDT, enabling the construction of histograms, indexes, and histograms for values of the type.</span></span> <span data-ttu-id="7410e-177">Di conseguenza, i tipi definiti dall'utente normalizzati offrono prestazioni molto simili ai tipi predefiniti nativi per operazioni che non comportano chiamate al metodo.</span><span class="sxs-lookup"><span data-stu-id="7410e-177">Consequently, normalized UDTs have a very similar performance profile to the native built-in types for operations that do not involve method invocation.</span></span>  
  
### <a name="scalable-memory-usage"></a><span data-ttu-id="7410e-178">Utilizzo della memoria scalabile</span><span class="sxs-lookup"><span data-stu-id="7410e-178">Scalable Memory Usage</span></span>  
 <span data-ttu-id="7410e-179">Per ottenere prestazioni e scalabilità soddisfacenti del processo di Garbage Collection gestito in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], evitare una singola allocazione di grandi dimensioni.</span><span class="sxs-lookup"><span data-stu-id="7410e-179">In order for managed garbage collection to perform and scale well in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], avoid large, single allocation.</span></span> <span data-ttu-id="7410e-180">Le allocazioni di dimensioni maggiori di 88 kilobyte (KB) vengono inserite nell'heap oggetti grandi che determina prestazioni e scalabilità nettamente inferiori rispetto ad allocazioni più piccole.</span><span class="sxs-lookup"><span data-stu-id="7410e-180">Allocations greater than 88 kilobytes (KB) in size will be placed on the Large Object Heap, which will cause garbage collection to perform and scale much worse than many smaller allocations.</span></span> <span data-ttu-id="7410e-181">Se ad esempio è necessario allocare una matrice multidimensionale di dimensioni elevate, è preferibile allocare una matrice di matrici (a dispersione).</span><span class="sxs-lookup"><span data-stu-id="7410e-181">For example, if you need to allocate a large multi-dimensional array, it is better to allocate a jagged (scattered) array.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="7410e-182">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="7410e-182">See Also</span></span>  
 [<span data-ttu-id="7410e-183">Tipi definiti dall'utente CLR</span><span class="sxs-lookup"><span data-stu-id="7410e-183">CLR User-Defined Types</span></span>](../clr-integration-database-objects-user-defined-types/clr-user-defined-types.md)  
  
  
