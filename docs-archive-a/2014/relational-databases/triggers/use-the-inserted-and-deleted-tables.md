---
title: Usare le tabelle inserite ed eliminate | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
helpviewer_keywords:
- inserted tables
- UPDATE statement [SQL Server], DML triggers
- DELETE statement [SQL Server], DML triggers
- INSTEAD OF triggers
- deleted tables
- INSERT statement [SQL Server], DML triggers
- DML triggers, deleted or inserted tables
ms.assetid: ed84567f-7b91-4b44-b5b2-c400bda4590d
author: rothja
ms.author: jroth
ms.openlocfilehash: facc534177113bd93e56e50fca3ae14c3e6b2cfc
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/04/2020
ms.locfileid: "87637123"
---
# <a name="use-the-inserted-and-deleted-tables"></a><span data-ttu-id="70374-102">Utilizzo delle tabelle inserite ed eliminate</span><span class="sxs-lookup"><span data-stu-id="70374-102">Use the inserted and deleted Tables</span></span>
  <span data-ttu-id="70374-103">Nelle istruzioni dei trigger DML vengono usate due tabelle speciali, ovvero la tabella inserted e la tabella deleted.</span><span class="sxs-lookup"><span data-stu-id="70374-103">DML trigger statements use two special tables: the deleted table and the inserted tables.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="70374-104">crea e gestisce queste tabelle automaticamente.</span><span class="sxs-lookup"><span data-stu-id="70374-104">automatically creates and manages these tables.</span></span> <span data-ttu-id="70374-105">È possibile utilizzare queste tabelle temporanee residenti in memoria per verificare gli effetti di determinate modifiche apportate ai dati e impostare le condizioni per le azioni dei trigger DML.</span><span class="sxs-lookup"><span data-stu-id="70374-105">You can use these temporary, memory-resident tables to test the effects of certain data modifications and to set conditions for DML trigger actions.</span></span> <span data-ttu-id="70374-106">Non è possibile modificare i dati o eseguire operazioni DDL (Data Definition Language), quale CREATE INDEX, direttamente nelle tabelle.</span><span class="sxs-lookup"><span data-stu-id="70374-106">You cannot directly modify the data in the tables or perform data definition language (DDL) operations on the tables, such as CREATE INDEX.</span></span>  
  
 <span data-ttu-id="70374-107">Nei trigger DML le tabelle inserted e deleted vengono principalmente utilizzate per eseguire le operazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="70374-107">In DML triggers, the inserted and deleted tables are primarily used to perform the following:</span></span>  
  
-   <span data-ttu-id="70374-108">Estendere l'integrità referenziale tra le tabelle.</span><span class="sxs-lookup"><span data-stu-id="70374-108">Extend referential integrity between tables.</span></span>  
  
-   <span data-ttu-id="70374-109">Inserire o aggiornare i dati in tabelle di base sottostanti alla vista.</span><span class="sxs-lookup"><span data-stu-id="70374-109">Insert or update data in base tables underlying a view.</span></span>  
  
-   <span data-ttu-id="70374-110">Verificare la presenza di errori ed eseguire le azioni appropriate sulla base dell'errore rilevato.</span><span class="sxs-lookup"><span data-stu-id="70374-110">Test for errors and take action based on the error.</span></span>  
  
-   <span data-ttu-id="70374-111">Individuare le differenze tra lo stato di una tabella prima della modifica dei dati e lo stato della tabella stessa dopo la modifica, per eseguire le azioni appropriate sulla base di tali differenze.</span><span class="sxs-lookup"><span data-stu-id="70374-111">Find the difference between the state of a table before and after a data modification and take actions based on that difference.</span></span>  
  
 <span data-ttu-id="70374-112">Nella tabella deleted vengono archiviate copie delle righe interessate dall'esecuzione delle istruzioni DELETE e UPDATE.</span><span class="sxs-lookup"><span data-stu-id="70374-112">The deleted table stores copies of the affected rows during DELETE and UPDATE statements.</span></span> <span data-ttu-id="70374-113">Durante l'esecuzione di un'istruzione DELETE o UPDATE, le righe vengono eliminate dalla tabella di trigger e trasferite nella tabella deleted.</span><span class="sxs-lookup"><span data-stu-id="70374-113">During the execution of a DELETE or UPDATE statement, rows are deleted from the trigger table and transferred to the deleted table.</span></span> <span data-ttu-id="70374-114">In genere, la tabella deleted e la tabella di trigger non hanno righe in comune.</span><span class="sxs-lookup"><span data-stu-id="70374-114">The deleted table and the trigger table ordinarily have no rows in common.</span></span>  
  
 <span data-ttu-id="70374-115">Nella tabella inserted vengono archiviate copie delle righe interessate dall'esecuzione delle istruzioni INSERT e UPDATE.</span><span class="sxs-lookup"><span data-stu-id="70374-115">The inserted table stores copies of the affected rows during INSERT and UPDATE statements.</span></span> <span data-ttu-id="70374-116">Durante una transazione INSERT o UPDATE, le nuove righe vengono aggiunte sia alla tabella inserted che alla tabella di trigger.</span><span class="sxs-lookup"><span data-stu-id="70374-116">During an insert or update transaction, new rows are added to both the inserted table and the trigger table.</span></span> <span data-ttu-id="70374-117">Le righe della tabella inserted sono copie delle nuove righe della tabella di trigger.</span><span class="sxs-lookup"><span data-stu-id="70374-117">The rows in the inserted table are copies of the new rows in the trigger table.</span></span>  
  
 <span data-ttu-id="70374-118">Una transazione UPDATE corrisponde a un'eliminazione seguita da un inserimento. Per prima cosa le righe precedenti vengono copiate nella tabella deleted e quindi le nuove righe vengono copiate nella tabella inserted.</span><span class="sxs-lookup"><span data-stu-id="70374-118">An update transaction is similar to a delete operation followed by an insert operation; the old rows are copied to the deleted table first, and then the new rows are copied to the trigger table and to the inserted table.</span></span>  
  
 <span data-ttu-id="70374-119">Quando si impostano le condizioni di trigger, utilizzare correttamente le tabelle inserted e deleted in base all'azione che ha attivato il trigger.</span><span class="sxs-lookup"><span data-stu-id="70374-119">When you set trigger conditions, use the inserted and deleted tables appropriately for the action that fired the trigger.</span></span> <span data-ttu-id="70374-120">Sebbene il riferimento alla tabella deleted durante la verifica di un'istruzione INSERT o alla tabella inserted durante la verifica di un'istruzione DELETE non causi alcun errore, in questi casi le tabelle di verifica dei trigger non conterranno alcuna riga.</span><span class="sxs-lookup"><span data-stu-id="70374-120">Although referencing the deleted table when testing an INSERT or the inserted table when testing a DELETE does not cause any errors, these trigger test tables do not contain any rows in these cases.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="70374-121">Se le azioni dei trigger dipendono dal numero di righe interessate dalle modifiche apportate ai dati, usare le verifiche (ad esempio un esame di @@ROWCOUNT) nel caso di modifiche apportate ai dati di più righe (un'istruzione INSERT, DELETE o UPDATE basata su un'istruzione SELECT) ed eseguire le azioni appropriate.</span><span class="sxs-lookup"><span data-stu-id="70374-121">If trigger actions depend on the number of rows a data modification effects, use tests (such as an examination of @@ROWCOUNT) for multirow data modifications (an INSERT, DELETE, or UPDATE based on a SELECT statement), and take appropriate actions.</span></span>  
  
 [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] <span data-ttu-id="70374-122">non è possibile utilizzare i riferimenti di colonna di tipo `text`, `ntext` o `image` nelle tabelle inserted e deleted per i trigger AFTER.</span><span class="sxs-lookup"><span data-stu-id="70374-122">does not allow for `text`, `ntext`, or `image` column references in the inserted and deleted tables for AFTER triggers.</span></span> <span data-ttu-id="70374-123">Questi tipi di dati sono tuttavia disponibili per garantire la compatibilità con le versioni precedenti.</span><span class="sxs-lookup"><span data-stu-id="70374-123">However, these data types are included for backward compatibility purposes only.</span></span> <span data-ttu-id="70374-124">La modalità di archiviazione ottimale per dati di grandi dimensioni consiste nell'utilizzare i tipi di dati `varchar(max)`, `nvarchar(max)` e `varbinary(max)`.</span><span class="sxs-lookup"><span data-stu-id="70374-124">The preferred storage for large data is to use the `varchar(max)`, `nvarchar(max)`, and `varbinary(max)` data types.</span></span> <span data-ttu-id="70374-125">I trigger AFTER e INSTEAD OF supportano entrambi dati di tipo `varchar(max)`, `nvarchar(max)` e `varbinary(max)` nelle tabelle inserted e deleted.</span><span class="sxs-lookup"><span data-stu-id="70374-125">Both AFTER and INSTEAD OF triggers support `varchar(max)`, `nvarchar(max)`, and `varbinary(max)` data in the inserted and deleted tables.</span></span> <span data-ttu-id="70374-126">Per altre informazioni, vedere [CREATE TRIGGER &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-trigger-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="70374-126">For more information, see [CREATE TRIGGER &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-trigger-transact-sql).</span></span>  
  
 <span data-ttu-id="70374-127">**Esempio di utilizzo della tabella inserted in un trigger per l'applicazione delle regole business**</span><span class="sxs-lookup"><span data-stu-id="70374-127">**An Example of Using the inserted Table in a Trigger to Enforce Business Rules**</span></span>  
  
 <span data-ttu-id="70374-128">Poiché i vincoli CHECK possono fare riferimento solo alle colonne in cui è definito il vincolo a livello di colonna o di tabella, è necessario definire come trigger qualsiasi vincolo tra tabelle, in questo caso le regole business.</span><span class="sxs-lookup"><span data-stu-id="70374-128">Because CHECK constraints can reference only the columns on which the column-level or table-level constraint is defined, any cross-table constraints (in this case, business rules) must be defined as triggers.</span></span>  
  
 <span data-ttu-id="70374-129">Nell'esempio seguente viene creato un trigger DML.</span><span class="sxs-lookup"><span data-stu-id="70374-129">The following example creates a DML trigger.</span></span> <span data-ttu-id="70374-130">Questo trigger verifica che la posizione creditizia del fornitore sia buona quando viene eseguito un tentativo di inserimento di un nuovo ordine di acquisto nella tabella `PurchaseOrderHeader` .</span><span class="sxs-lookup"><span data-stu-id="70374-130">This trigger checks to make sure the credit rating for the vendor is good when an attempt is made to insert a new purchase order into the `PurchaseOrderHeader` table.</span></span> <span data-ttu-id="70374-131">Per ottenere la posizione creditizia del fornitore corrispondente all'ordine di acquisto inserito, la tabella `Vendor` deve essere una tabella con riferimenti e deve essere unita in join alla tabella inserted.</span><span class="sxs-lookup"><span data-stu-id="70374-131">To obtain the credit rating of the vendor corresponding to the purchase order that was just inserted, the `Vendor` table must be referenced and joined with the inserted table.</span></span> <span data-ttu-id="70374-132">Se la posizione creditizia è troppo bassa, viene visualizzato un messaggio e l'operazione di inserimento non viene eseguita.</span><span class="sxs-lookup"><span data-stu-id="70374-132">If the credit rating is too low, a message is displayed and the insertion does not execute.</span></span> <span data-ttu-id="70374-133">Si noti che questo esempio non consente modifiche ai dati a riga multipla.</span><span class="sxs-lookup"><span data-stu-id="70374-133">Note that this example does not allow for multirow data modifications.</span></span> <span data-ttu-id="70374-134">Per altre informazioni, vedere [Creazione di trigger DML per gestire più righe di dati](../triggers/create-dml-triggers-to-handle-multiple-rows-of-data.md).</span><span class="sxs-lookup"><span data-stu-id="70374-134">For more information, see [Create DML Triggers to Handle Multiple Rows of Data](../triggers/create-dml-triggers-to-handle-multiple-rows-of-data.md).</span></span>  
  
 [!code-sql[TriggerDDL#CreateTrigger3](../../snippets/tsql/SQL14/tsql/triggerddl/transact-sql/snippet_create_alter_drop_trigger.sql#createtrigger3)]  
  
## <a name="using-the-inserted-and-deleted-tables-in-instead-of-triggers"></a><span data-ttu-id="70374-135">Utilizzo delle tabelle inserted e deleted nei trigger INSTEAD OF</span><span class="sxs-lookup"><span data-stu-id="70374-135">Using the inserted and deleted Tables in INSTEAD OF Triggers</span></span>  
 <span data-ttu-id="70374-136">Alle tabelle inserted e deleted passate ai trigger INSTEAD OF definiti nelle tabelle vengono applicate le stesse regole valide per le tabelle inserted e deleted passate ai trigger AFTER.</span><span class="sxs-lookup"><span data-stu-id="70374-136">The inserted and deleted tables passed to INSTEAD OF triggers defined on tables follow the same rules as the inserted and deleted tables passed to AFTER triggers.</span></span> <span data-ttu-id="70374-137">Il formato delle tabelle inserted e deleted è uguale a quello della tabella in cui è stato definito il trigger INSTEAD OF.</span><span class="sxs-lookup"><span data-stu-id="70374-137">The format of the inserted and deleted tables is the same as the format of the table on which the INSTEAD OF trigger is defined.</span></span> <span data-ttu-id="70374-138">Ogni colonna delle tabelle inserted e deleted è mappata direttamente a una colonna della tabella di base.</span><span class="sxs-lookup"><span data-stu-id="70374-138">Each column in the inserted and deleted tables maps directly to a column in the base table.</span></span>  
  
 <span data-ttu-id="70374-139">Le regole seguenti relative al fatto che un'istruzione INSERT o UPDATE che fa riferimento a una tabella con un trigger INSTEAD OF debba fornire valori per le colonne sono applicabili anche alle tabelle senza trigger INSTEAD OF:</span><span class="sxs-lookup"><span data-stu-id="70374-139">The following rules regarding when an INSERT or UPDATE statement referencing a table with an INSTEAD OF trigger must supply values for columns are the same as if the table did not have an INSTEAD OF trigger:</span></span>  
  
-   <span data-ttu-id="70374-140">Non è possibile specificare valori per colonne calcolate o colonne con tipo di dati `timestamp`.</span><span class="sxs-lookup"><span data-stu-id="70374-140">Values cannot be specified for computed columns or columns with a `timestamp` data type.</span></span>  
  
-   <span data-ttu-id="70374-141">Non è possibile specificare valori per colonne con proprietà IDENTITY, a meno che IDENTITY_INSERT non sia impostata su ON per la tabella.</span><span class="sxs-lookup"><span data-stu-id="70374-141">Values cannot be specified for columns with an IDENTITY property, unless IDENTITY_INSERT is ON for that table.</span></span> <span data-ttu-id="70374-142">Se IDENTITY_INSERT è impostata su ON, le istruzioni INSERT devono fornire un valore.</span><span class="sxs-lookup"><span data-stu-id="70374-142">When IDENTITY_INSERT is ON, INSERT statements must supply a value.</span></span>  
  
-   <span data-ttu-id="70374-143">Le istruzioni INSERT devono fornire valori per tutte le colonne NOT NULL a cui sono applicati vincoli DEFAULT.</span><span class="sxs-lookup"><span data-stu-id="70374-143">INSERT statements must supply values for all NOT NULL columns that do not have DEFAULT constraints.</span></span>  
  
-   <span data-ttu-id="70374-144">Ad eccezione delle colonne calcolate, identity o `timestamp`, i valori sono facoltativi per tutte le colonne che supportano valori Null, o per le colonne NOT NULL con definizione DEFAULT.</span><span class="sxs-lookup"><span data-stu-id="70374-144">For any columns except computed, identity, or `timestamp` columns, values are optional for any column that allows nulls, or any NOT NULL column that has a DEFAULT definition.</span></span>  
  
 <span data-ttu-id="70374-145">Quando un'istruzione INSERT, UPDATE o DELETE fa riferimento a una vista con trigger INSTEAD OF, il [!INCLUDE[ssDE](../../includes/ssde-md.md)] esegue una chiamata al trigger invece di eseguire azioni sulle tabelle.</span><span class="sxs-lookup"><span data-stu-id="70374-145">When an INSERT, UPDATE, or DELETE statement references a view that has an INSTEAD OF trigger, the [!INCLUDE[ssDE](../../includes/ssde-md.md)] calls the trigger instead of taking any direct action against any table.</span></span> <span data-ttu-id="70374-146">Il trigger deve utilizzare le informazioni visualizzate nelle tabelle inserted e deleted per compilare le istruzioni necessarie per implementare l'azione richiesta nelle tabelle di base, anche nel caso in cui il formato delle informazioni nelle tabelle inserted e deleted compilate per la vista sia diverso dal formato dei dati delle tabelle di base.</span><span class="sxs-lookup"><span data-stu-id="70374-146">The trigger must use the information presented in the inserted and deleted tables to build any statements required to implement the requested action in the base tables, even when the format of the information in the inserted and deleted tables built for the view is different from the format of the data in the base tables.</span></span>  
  
 <span data-ttu-id="70374-147">Il formato delle tabelle inserted e deleted passate a un trigger INSTEAD OF definito in una vista corrisponde all'elenco di selezione dell'istruzione SELECT definita per la vista.</span><span class="sxs-lookup"><span data-stu-id="70374-147">The format of the inserted and deleted tables passed to an INSTEAD OF trigger defined on a view matches the select list of the SELECT statement defined for the view.</span></span> <span data-ttu-id="70374-148">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="70374-148">For example:</span></span>  
  
```  
USE AdventureWorks2012;  
GO  
CREATE VIEW dbo.EmployeeNames (BusinessEntityID, LName, FName)  
AS  
SELECT e.BusinessEntityID, p.LastName, p.FirstName  
FROM HumanResources.Employee AS e   
JOIN Person.Person AS p  
ON e.BusinessEntityID = p.BusinessEntityID;  
```  
  
 <span data-ttu-id="70374-149">Il set di risultati di questa vista ha tre colonne, ovvero una colonna `int` e due colonne `nvarchar`.</span><span class="sxs-lookup"><span data-stu-id="70374-149">The result set for this view has three columns: an `int` column and two `nvarchar` columns.</span></span> <span data-ttu-id="70374-150">Le tabelle inserted e deleted passate a un trigger INSTEAD OF definito nella vista hanno a loro volta una colonna `int` chiamata `BusinessEntityID`, una colonna `nvarchar` chiamata `LName` e una colonna `nvarchar` chiamata `FName`.</span><span class="sxs-lookup"><span data-stu-id="70374-150">The inserted and deleted tables passed to an INSTEAD OF trigger defined on the view also have an `int` column named `BusinessEntityID`, an `nvarchar` column named `LName`, and an `nvarchar` column named `FName`.</span></span>  
  
 <span data-ttu-id="70374-151">L'elenco di selezione di una vista può inoltre includere espressioni di cui non è stato eseguito il mapping diretto a una singola colonna della tabella di base.</span><span class="sxs-lookup"><span data-stu-id="70374-151">The select list of a view can also contain expressions that do not directly map to a single base-table column.</span></span> <span data-ttu-id="70374-152">È possibile che alcune espressioni di vista, ad esempio una chiamata di funzione o costante, non facciano riferimento ad alcuna colonna e vengano pertanto ignorate.</span><span class="sxs-lookup"><span data-stu-id="70374-152">Some view expressions, such as a constant or function invocation, may not reference any columns and can be ignored.</span></span> <span data-ttu-id="70374-153">Le espressioni complesse possono fare riferimento a più colonne, ma nelle tabelle inserted e deleted è disponibile un solo valore per ogni riga inserita.</span><span class="sxs-lookup"><span data-stu-id="70374-153">Complex expressions can reference multiple columns, yet the inserted and deleted tables have only one value for each inserted row.</span></span> <span data-ttu-id="70374-154">Lo stesso vale per le espressioni semplici di una vista che fanno riferimento a una colonna calcolata con un'espressione complessa.</span><span class="sxs-lookup"><span data-stu-id="70374-154">The same issues apply to simple expressions in a view if they reference a computed column that has a complex expression.</span></span> <span data-ttu-id="70374-155">Un trigger INSTEAD OF nella vista deve essere in grado di gestire questo tipo di espressioni.</span><span class="sxs-lookup"><span data-stu-id="70374-155">An INSTEAD OF trigger on the view must handle these types of expressions.</span></span>  
  
  
