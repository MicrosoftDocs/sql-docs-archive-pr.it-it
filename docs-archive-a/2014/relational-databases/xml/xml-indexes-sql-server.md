---
title: Indici XML (SQL Server) | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: conceptual
helpviewer_keywords:
- removing indexes
- deleting indexes
- secondary indexes [XML in SQL Server]
- xml data type [SQL Server], indexes
- dropping indexes
- PATH index
- DROP_EXISTING clause
- XML [SQL Server], indexes
- primary indexes [XML in SQL Server]
- indexes [SQL Server], XML
- XML indexes [SQL Server], secondary
- BLOBs, XML indexes
- disabling indexes
- XML indexes [SQL Server], modifying
- XML indexes [SQL Server]
- XML indexes [SQL Server], primary
- modifying indexes
- XML indexes [SQL Server], dropping
- VALUE index
- XML indexes [SQL Server], xml data type
- PROPERTY index
- XML indexes [SQL Server], creating
ms.assetid: f5c9209d-b3f3-4543-b30b-01365a5e7333
author: rothja
ms.author: jroth
ms.openlocfilehash: bf9a33bc18790bf8821d778746a708f78bbb3d8f
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/04/2020
ms.locfileid: "87630381"
---
# <a name="xml-indexes-sql-server"></a><span data-ttu-id="11a12-102">Indici XML (SQL Server)</span><span class="sxs-lookup"><span data-stu-id="11a12-102">XML Indexes (SQL Server)</span></span>
  <span data-ttu-id="11a12-103">È possibile creare indici XML sulle colonne con tipo di dati `xml`.</span><span class="sxs-lookup"><span data-stu-id="11a12-103">XML indexes can be created on `xml` data type columns.</span></span> <span data-ttu-id="11a12-104">Tutti i tag, i valori e i percorsi delle istanze XML presenti nella colonna vengono indicizzati, migliorando le prestazioni delle query.</span><span class="sxs-lookup"><span data-stu-id="11a12-104">They index all tags, values and paths over the XML instances in the column and benefit query performance.</span></span> <span data-ttu-id="11a12-105">Per le applicazioni in uso l'utilizzo di un indice XML può risultare vantaggioso nelle situazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="11a12-105">Your application may benefit from an XML index in the following situations:</span></span>  
  
-   <span data-ttu-id="11a12-106">Le query sulle colonne XML sono frequenti nel carico di lavoro.</span><span class="sxs-lookup"><span data-stu-id="11a12-106">Queries on XML columns are common in your workload.</span></span> <span data-ttu-id="11a12-107">È necessario tenere in considerazione il costo di manutenzione dell'indice XML durante la modifica dei dati.</span><span class="sxs-lookup"><span data-stu-id="11a12-107">XML index maintenance cost during data modification must be considered.</span></span>  
  
-   <span data-ttu-id="11a12-108">I valori XML sono di grandi dimensioni mentre le parti recuperate sono relativamente piccole.</span><span class="sxs-lookup"><span data-stu-id="11a12-108">Your XML values are relatively large and the retrieved parts are relatively small.</span></span> <span data-ttu-id="11a12-109">Compilando un indice sarà possibile evitare l'analisi completa dei dati in fase di esecuzione ed eseguire ricerche basate sull'indice per una efficiente elaborazione delle query.</span><span class="sxs-lookup"><span data-stu-id="11a12-109">Building the index avoids parsing the whole data at run time and benefits index lookups for efficient query processing.</span></span>  
  
 <span data-ttu-id="11a12-110">Gli indici XML rientrano nelle categorie seguenti:</span><span class="sxs-lookup"><span data-stu-id="11a12-110">XML indexes fall into the following categories:</span></span>  
  
-   <span data-ttu-id="11a12-111">Indice XML primario</span><span class="sxs-lookup"><span data-stu-id="11a12-111">Primary XML index</span></span>  
  
-   <span data-ttu-id="11a12-112">Indice XML secondario</span><span class="sxs-lookup"><span data-stu-id="11a12-112">Secondary XML index</span></span>  
  
 <span data-ttu-id="11a12-113">Il primo indice nella colonna di tipo `xml` deve essere l'indice XML primario,</span><span class="sxs-lookup"><span data-stu-id="11a12-113">The first index on the `xml` type column must be the primary XML index.</span></span> <span data-ttu-id="11a12-114">il cui utilizzo consente di supportare i tipi di indici secondari seguenti: PATH, VALUE e PROPERTY.</span><span class="sxs-lookup"><span data-stu-id="11a12-114">Using the primary XML index, the following types of secondary indexes are supported: PATH, VALUE, and PROPERTY.</span></span> <span data-ttu-id="11a12-115">In base al tipo di query, questi indici secondari possono facilitare il miglioramento delle prestazioni delle query.</span><span class="sxs-lookup"><span data-stu-id="11a12-115">Depending on the type of queries, these secondary indexes might help improve query performance.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="11a12-116">Non è possibile creare o modificare un indice XML a meno che le opzioni del database siano correttamente impostate per l'utilizzo del tipo di dati `xml`.</span><span class="sxs-lookup"><span data-stu-id="11a12-116">You cannot create or modify an XML index unless the database options are set correctly for working with the `xml` data type.</span></span> <span data-ttu-id="11a12-117">Per altre informazioni, vedere [Utilizzo della ricerca full-text con colonne XML](use-full-text-search-with-xml-columns.md).</span><span class="sxs-lookup"><span data-stu-id="11a12-117">For more information, see [Use Full-Text Search with XML Columns](use-full-text-search-with-xml-columns.md).</span></span>  
  
 <span data-ttu-id="11a12-118">Le istanze XML vengono archiviate nelle colonne di tipo `xml` come oggetti BLOB (Binary Large Object).</span><span class="sxs-lookup"><span data-stu-id="11a12-118">XML instances are stored in `xml` type columns as large binary objects (BLOBs).</span></span> <span data-ttu-id="11a12-119">Tali istanze XML possono essere di grandi dimensioni e la rappresentazione binaria archiviata delle istanze del tipo di dati `xml` può raggiungere dimensioni massime di 2 GB.</span><span class="sxs-lookup"><span data-stu-id="11a12-119">These XML instances can be large, and the stored binary representation of `xml` data type instances can be up to 2 GB.</span></span> <span data-ttu-id="11a12-120">Senza un indice, questi oggetti BLOB vengono suddivisi in fase di esecuzione per valutare una query.</span><span class="sxs-lookup"><span data-stu-id="11a12-120">Without an index, these binary large objects are shredded at run time to evaluate a query.</span></span> <span data-ttu-id="11a12-121">Questa suddivisione può richiedere molto tempo.</span><span class="sxs-lookup"><span data-stu-id="11a12-121">This shredding can be time-consuming.</span></span> <span data-ttu-id="11a12-122">Si consideri ad esempio la query seguente:</span><span class="sxs-lookup"><span data-stu-id="11a12-122">For example, consider the following query:</span></span>  
  
```  
WITH XMLNAMESPACES ('https://schemas.microsoft.com/sqlserver/2004/07/adventure-works/ProductModelDescription' AS "PD")  
  
SELECT CatalogDescription.query('  
  /PD:ProductDescription/PD:Summary  
') as Result  
FROM Production.ProductModel  
WHERE CatalogDescription.exist ('/PD:ProductDescription/@ProductModelID[.="19"]') = 1  
```  
  
 <span data-ttu-id="11a12-123">Per selezionare le istanze XML che soddisfano la condizione della clausola `WHERE` , gli oggetti BLOB XML in ogni riga della tabella `Production.ProductModel` vengono suddivisi in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="11a12-123">To select the XML instances that satisfy the condition in the `WHERE` clause, the XML binary large object (BLOB) in each row of table `Production.ProductModel` is shredded at run time.</span></span> <span data-ttu-id="11a12-124">In seguito, viene valutata l'espressione `(/PD:ProductDescription/@ProductModelID[.="19"]`) nel metodo `exist()` .</span><span class="sxs-lookup"><span data-stu-id="11a12-124">Then, the expression `(/PD:ProductDescription/@ProductModelID[.="19"]`) in the `exist()` method is evaluated.</span></span> <span data-ttu-id="11a12-125">La suddivisione in fase di esecuzione può essere costosa, a seconda delle dimensioni e del numero di istanze archiviate nella colonna.</span><span class="sxs-lookup"><span data-stu-id="11a12-125">This run-time shredding can be costly, depending on the size and number of instances stored in the column.</span></span>  
  
 <span data-ttu-id="11a12-126">Se l'esecuzione di query sugli oggetti BLOB XML è un processo comune nell'ambiente di lavoro specifico, può facilitare l'indicizzazione delle colonne di tipo `xml`.</span><span class="sxs-lookup"><span data-stu-id="11a12-126">If querying XML binary large objects (BLOBs) is common in your application environment, it helps to index the `xml` type columns.</span></span> <span data-ttu-id="11a12-127">Tuttavia, la manutenzione dell'indice durante la modifica dei dati presuppone un costo associato.</span><span class="sxs-lookup"><span data-stu-id="11a12-127">However, there is a cost associated with maintaining the index during data modification.</span></span>  
  
## <a name="primary-xml-index"></a><span data-ttu-id="11a12-128">Indice XML primario</span><span class="sxs-lookup"><span data-stu-id="11a12-128">Primary XML Index</span></span>  
 <span data-ttu-id="11a12-129">L'indice XML primario consente di indicizzare tutti i tag, i valori e i percorsi contenuti nelle istanze XML di una colonna XML.</span><span class="sxs-lookup"><span data-stu-id="11a12-129">The primary XML index indexes all tags, values, and paths within the XML instances in an XML column.</span></span> <span data-ttu-id="11a12-130">Per creare un indice XML primario, è necessario che la tabella contenente la colonna XML da indicizzare includa un indice cluster nella chiave primaria.</span><span class="sxs-lookup"><span data-stu-id="11a12-130">To create a primary XML index, the table in which the XML column occurs must have a clustered index on the primary key of the table.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="11a12-131">usa questa chiave primaria per correlare righe nell'indice XML primario con le righe nella tabella che contiene la colonna XML.</span><span class="sxs-lookup"><span data-stu-id="11a12-131">uses this primary key to correlate rows in the primary XML index with rows in the table that contains the XML column.</span></span>  
  
 <span data-ttu-id="11a12-132">L'indice XML primario è una rappresentazione suddivisa e persistente degli oggetti BLOB XML contenuti nella colonna con tipo di dati `xml`.</span><span class="sxs-lookup"><span data-stu-id="11a12-132">The primary XML index is a shredded and persisted representation of the XML BLOBs in the `xml` data type column.</span></span> <span data-ttu-id="11a12-133">Per ogni BLOB XML contenuto nella colonna, l'indice crea diverse righe di dati.</span><span class="sxs-lookup"><span data-stu-id="11a12-133">For each XML binary large object (BLOB) in the column, the index creates several rows of data.</span></span> <span data-ttu-id="11a12-134">Il numero di righe dell'indice corrisponde approssimativamente al numero di nodi del BLOB XML.</span><span class="sxs-lookup"><span data-stu-id="11a12-134">The number of rows in the index is approximately equal to the number of nodes in the XML binary large object.</span></span> <span data-ttu-id="11a12-135">Quando una query recupera l'istanza XML completa [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] fornisce l'istanza dalla colonna XML.</span><span class="sxs-lookup"><span data-stu-id="11a12-135">When a query retrieves the full XML instance, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] provides the instance from the XML column.</span></span> <span data-ttu-id="11a12-136">Le query all'interno delle istanze XML utilizzano l'indice XML primario e possono restituire valori scalari o sottoalberi XML utilizzando l'indice stesso.</span><span class="sxs-lookup"><span data-stu-id="11a12-136">Queries within XML instances use the primary XML index, and can return scalar values or XML subtrees by using the index itself.</span></span>  
  
 <span data-ttu-id="11a12-137">In ogni riga vengono archiviate le informazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="11a12-137">Each row stores the following node information:</span></span>  
  
-   <span data-ttu-id="11a12-138">Nome di tag, ad esempio un nome di elemento o di attributo.</span><span class="sxs-lookup"><span data-stu-id="11a12-138">Tag name such as an element or attribute name.</span></span>  
  
-   <span data-ttu-id="11a12-139">Valore di nodo.</span><span class="sxs-lookup"><span data-stu-id="11a12-139">Node value.</span></span>  
  
-   <span data-ttu-id="11a12-140">Tipo di nodo, ad esempio un nodo elemento, un nodo attributo o un nodo testo.</span><span class="sxs-lookup"><span data-stu-id="11a12-140">Node type such as an element node, attribute node, or text node.</span></span>  
  
-   <span data-ttu-id="11a12-141">Informazioni sull'ordine dei dati nel documento, rappresentate da un identificatore di nodo interno.</span><span class="sxs-lookup"><span data-stu-id="11a12-141">Document order information, represented by an internal node identifier.</span></span>  
  
-   <span data-ttu-id="11a12-142">Percorso da ogni nodo al nodo radice dell'albero XML.</span><span class="sxs-lookup"><span data-stu-id="11a12-142">Path from each node to the root of the XML tree.</span></span> <span data-ttu-id="11a12-143">In questa colonna viene eseguita la ricerca delle espressioni di percorso della query.</span><span class="sxs-lookup"><span data-stu-id="11a12-143">This column is searched for path expressions in the query.</span></span>  
  
-   <span data-ttu-id="11a12-144">Chiave primaria della tabella di base.</span><span class="sxs-lookup"><span data-stu-id="11a12-144">Primary key of the base table.</span></span> <span data-ttu-id="11a12-145">La chiave primaria della tabella di base viene duplicata nell'indice XML primario per eseguire un join all'indietro con la tabella di base e il numero massimo di colonne nella chiave primaria della tabella di base è limitato a 15.</span><span class="sxs-lookup"><span data-stu-id="11a12-145">The primary key of the base table is duplicated in the primary XML index for a back join with the base table, and the maximum number of columns in the primary key of the base table is limited to 15.</span></span>  
  
 <span data-ttu-id="11a12-146">Le informazioni sul nodo vengono utilizzate per valutare e costruire i risultati XML di una query specificata.</span><span class="sxs-lookup"><span data-stu-id="11a12-146">This node information is used to evaluate and construct XML results for a specified query.</span></span> <span data-ttu-id="11a12-147">A scopo di ottimizzazione, il nome di tag e le informazioni sul tipo di nodo vengono codificati come valori integer e per la colonna Path viene utilizzata la stessa codifica.</span><span class="sxs-lookup"><span data-stu-id="11a12-147">For optimization purposes, the tag name and the node type information are encoded as integer values, and the Path column uses the same encoding.</span></span> <span data-ttu-id="11a12-148">Inoltre, i percorsi vengono archiviati in ordine inverso per consentirne la corrispondenza quando è noto solo il relativo suffisso.</span><span class="sxs-lookup"><span data-stu-id="11a12-148">Also, paths are stored in reverse order to allow matching paths when only the path suffix is known.</span></span> <span data-ttu-id="11a12-149">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="11a12-149">For example:</span></span>  
  
-   <span data-ttu-id="11a12-150">`//ContactRecord/PhoneNumber` in cui sono noti solo gli ultimi due passaggi</span><span class="sxs-lookup"><span data-stu-id="11a12-150">`//ContactRecord/PhoneNumber` where only the last two steps are known</span></span>  
  
 <span data-ttu-id="11a12-151">OR</span><span class="sxs-lookup"><span data-stu-id="11a12-151">OR</span></span>  
  
-   <span data-ttu-id="11a12-152">`/Book/*/Title` in cui il carattere jolly (`*`) viene specificato nella parte centrale dell'espressione.</span><span class="sxs-lookup"><span data-stu-id="11a12-152">`/Book/*/Title` where the wildcard character (`*`) is specified in the middle of the expression.</span></span>  
  
 <span data-ttu-id="11a12-153">Query Processor usa l'indice XML primario per le query che implicano [metodi con tipo di dati XML](/sql/t-sql/xml/xml-data-type-methods) e restituisce valori scalari o sottoalberi XML dall'indice primario stesso.</span><span class="sxs-lookup"><span data-stu-id="11a12-153">The query processor uses the primary XML index for queries that involve [xml Data Type Methods](/sql/t-sql/xml/xml-data-type-methods) and returns either scalar values or the XML subtrees from the primary index itself.</span></span> <span data-ttu-id="11a12-154">In tale indice vengono archiviate tutte le informazioni necessarie per ricostruire l'istanza XML.</span><span class="sxs-lookup"><span data-stu-id="11a12-154">(This index stores all the necessary information to reconstruct the XML instance.)</span></span>  
  
 <span data-ttu-id="11a12-155">Ad esempio, la query seguente restituisce informazioni di riepilogo archiviate nella `CatalogDescription``xml` colonna Type della `ProductModel` tabella.</span><span class="sxs-lookup"><span data-stu-id="11a12-155">For example, the following query returns summary information stored in the `CatalogDescription``xml` type column in the `ProductModel` table.</span></span> <span data-ttu-id="11a12-156">La query restituisce informazioni <`Summary`> solo per modelli di prodotti la cui descrizione di catalogo contiene inoltre la descrizione <`Features`>.</span><span class="sxs-lookup"><span data-stu-id="11a12-156">The query returns <`Summary`> information only for product models whose catalog description also stores the <`Features`> description.</span></span>  
  
```  
WITH XMLNAMESPACES ('https://schemas.microsoft.com/sqlserver/2004/07/adventure-works/ProductModelDescription' AS "PD")SELECT CatalogDescription.query('  /PD:ProductDescription/PD:Summary') as ResultFROM Production.ProductModelWHERE CatalogDescription.exist ('/PD:ProductDescription/PD:Features') = 1  
```  
  
 <span data-ttu-id="11a12-157">In relazione all'indice XML primario, anziché suddividere ogni istanza degli oggetti BLOB XML nella tabella di base, nelle righe dell'indice che corrispondono a ogni oggetto BLOB XML viene eseguita la ricerca sequenziale dell'espressione specificata nel metodo `exist()` .</span><span class="sxs-lookup"><span data-stu-id="11a12-157">With regard to the primary XML index, instead of shredding each XML binary large object instance in the base table, the rows in the index that correspond to each XML binary large object are searched sequentially for the expression specified in the `exist()` method.</span></span> <span data-ttu-id="11a12-158">Se il percorso viene individuato nella colonna Path dell'indice, l'elemento <`Summary`> e i relativi sottoalberi vengono recuperati dall'indice XML primario e convertiti in un oggetto BLOB XML come risultato del metodo `query()`.</span><span class="sxs-lookup"><span data-stu-id="11a12-158">If the path is found in the Path column in the index, the <`Summary`> element together with its subtrees is retrieved from the primary XML index and converted into an XML binary large object as the result of the `query()` method.</span></span>  
  
 <span data-ttu-id="11a12-159">Si noti che l'indice XML primario non viene utilizzato per il recupero di un'istanza XML completa.</span><span class="sxs-lookup"><span data-stu-id="11a12-159">Note that the primary XML index is not used when retrieving a full XML instance.</span></span> <span data-ttu-id="11a12-160">Ad esempio, la query seguente recupera dalla tabella l'intera istanza XML che descrive le istruzioni di produzione per un modello di prodotto specifico.</span><span class="sxs-lookup"><span data-stu-id="11a12-160">For example, the following query retrieves from the table the whole XML instance that describes the manufacturing instructions for a specific product model.</span></span>  
  
```  
USE AdventureWorks2012;SELECT InstructionsFROM Production.ProductModel WHERE ProductModelID=7;  
```  
  
## <a name="secondary-xml-indexes"></a><span data-ttu-id="11a12-161">Indici XML secondari</span><span class="sxs-lookup"><span data-stu-id="11a12-161">Secondary XML Indexes</span></span>  
 <span data-ttu-id="11a12-162">Per migliorare le prestazioni di ricerca, è possibile creare indici XML secondari.</span><span class="sxs-lookup"><span data-stu-id="11a12-162">To enhance search performance, you can create secondary XML indexes.</span></span> <span data-ttu-id="11a12-163">A tale scopo, deve esistere innanzitutto un indice XML primario, prima di poterne creare di secondari.</span><span class="sxs-lookup"><span data-stu-id="11a12-163">A primary XML index must first exist before you can create secondary indexes.</span></span> <span data-ttu-id="11a12-164">Tipi di indici secondari:</span><span class="sxs-lookup"><span data-stu-id="11a12-164">These are the types:</span></span>  
  
-   <span data-ttu-id="11a12-165">Indice XML secondario PATH</span><span class="sxs-lookup"><span data-stu-id="11a12-165">PATH secondary XML index</span></span>  
  
-   <span data-ttu-id="11a12-166">Indice XML secondario VALUE</span><span class="sxs-lookup"><span data-stu-id="11a12-166">VALUE secondary XML index</span></span>  
  
-   <span data-ttu-id="11a12-167">Indice XML secondario PROPERTY</span><span class="sxs-lookup"><span data-stu-id="11a12-167">PROPERTY secondary XML index</span></span>  
  
 <span data-ttu-id="11a12-168">Di seguito sono riportate alcune linee guida per la creazione di uno o più indici di questo tipo:</span><span class="sxs-lookup"><span data-stu-id="11a12-168">Following are some guidelines for creating one or more secondary indexes:</span></span>  
  
-   <span data-ttu-id="11a12-169">Se nel carico di lavoro viene fatto un utilizzo significativo di espressioni di percorso sulle colonne XML, per migliorare le prestazioni di lavoro è possibile utilizzare l'indice XML secondario PATH.</span><span class="sxs-lookup"><span data-stu-id="11a12-169">If your workload uses path expressions significantly on XML columns, the PATH secondary XML index is likely to speed up your workload.</span></span> <span data-ttu-id="11a12-170">Il caso più comune è rappresentato dall'uso del metodo **exist()** sulle colonne XML nella clausola WHERE di Transact-SQL.</span><span class="sxs-lookup"><span data-stu-id="11a12-170">The most common case is the use of the **exist()** method on XML columns in the WHERE clause of Transact-SQL.</span></span>  
  
-   <span data-ttu-id="11a12-171">Se il carico di lavoro recupera più valori da singole istanze XML utilizzando espressioni di percorso, può essere utile eseguire il clustering dei percorsi nell'ambito di ogni istanza XML nell'indice PROPERTY.</span><span class="sxs-lookup"><span data-stu-id="11a12-171">If your workload retrieves multiple values from individual XML instances by using path expressions, clustering paths within each XML instance in the PROPERTY index may be helpful.</span></span> <span data-ttu-id="11a12-172">Questa situazione si presenta in genere negli scenari che prevedono l'utilizzo di contenitori di proprietà, quando vengono recuperate le proprietà di un oggetto di cui è noto il valore della chiave primaria.</span><span class="sxs-lookup"><span data-stu-id="11a12-172">This scenario typically occurs in a property bag scenario when properties of an object are fetched and its primary key value is known.</span></span>  
  
-   <span data-ttu-id="11a12-173">Se il carico di lavoro richiede l'esecuzione di query per il recupero di valori nelle istanze XML, senza conoscere i nomi degli elementi o attributi che contengono tali valori, sarà possibile creare l'indice VALUE.</span><span class="sxs-lookup"><span data-stu-id="11a12-173">If your workload involves querying for values within XML instances without knowing the element or attribute names that contain those values, you may want to create the VALUE index.</span></span> <span data-ttu-id="11a12-174">Questa situazione si verifica in genere nelle ricerche su assi discendenti, ad esempio //author[last-name="Howard"], in cui gli elementi \<author> possono essere presenti a ogni livello della gerarchia.</span><span class="sxs-lookup"><span data-stu-id="11a12-174">This typically occurs with descendant axes lookups, such as //author[last-name="Howard"], where \<author> elements can occur at any level of the hierarchy.</span></span> <span data-ttu-id="11a12-175">Si verifica anche nelle query che usano caratteri jolly, ad esempio /book [@\* = "novel"], in cui la query cerca elementi \<book> contenenti un attributo con valore "novel".</span><span class="sxs-lookup"><span data-stu-id="11a12-175">It also occurs in wildcard queries, such as /book [@\* = "novel"], where the query looks for \<book> elements that have some attribute having the value "novel".</span></span>  
  
### <a name="path-secondary-xml-index"></a><span data-ttu-id="11a12-176">Indice XML secondario PATH</span><span class="sxs-lookup"><span data-stu-id="11a12-176">PATH Secondary XML Index</span></span>  
 <span data-ttu-id="11a12-177">Se in genere le query specificano espressioni di percorso nelle colonne di tipo `xml`, un indice secondario PATH potrebbe velocizzare la ricerca.</span><span class="sxs-lookup"><span data-stu-id="11a12-177">If your queries generally specify path expressions on `xml` type columns, a PATH secondary index may be able to speed up the search.</span></span> <span data-ttu-id="11a12-178">Come precedentemente descritto in questo argomento, l'indice primario è utile nel caso di query che specificano il metodo **exist()** nella clausola WHERE.</span><span class="sxs-lookup"><span data-stu-id="11a12-178">As described earlier in this topic, the primary index is helpful when you have queries that specify **exist()** method in the WHERE clause.</span></span> <span data-ttu-id="11a12-179">Se si aggiunge un indice secondario PATH, è possibile migliorare le prestazioni della ricerca in tali query.</span><span class="sxs-lookup"><span data-stu-id="11a12-179">If you add a PATH secondary index, you may also improve the search performance in such queries.</span></span>  
  
 <span data-ttu-id="11a12-180">Sebbene un indice XML primario consenta di evitare la suddivisione dei BLOB XML in fase di esecuzione, potrebbe non garantire prestazioni ottimali per le query basate su espressioni di percorso.</span><span class="sxs-lookup"><span data-stu-id="11a12-180">Although a primary XML index avoids having to shred the XML binary large objects at run time, it may not provide the best performance for queries based on path expressions.</span></span> <span data-ttu-id="11a12-181">Poiché in tutte le righe dell'indice XML primario corrispondenti a un BLOB XML viene eseguita la ricerca sequenziale di istanze XML di grandi dimensioni, tale ricerca potrebbe risultare lenta.</span><span class="sxs-lookup"><span data-stu-id="11a12-181">Because all rows in the primary XML index corresponding to an XML binary large object are searched sequentially for large XML instances, the sequential search may be slow.</span></span> <span data-ttu-id="11a12-182">In tal caso, l'utilizzo di un indice secondario basato sui valori di percorso e di nodo dell'indice primario può velocizzare in modo significativo la ricerca nell'indice.</span><span class="sxs-lookup"><span data-stu-id="11a12-182">In this case, having a secondary index built on the path values and node values in the primary index can significantly speed up the index search.</span></span> <span data-ttu-id="11a12-183">Nell'indice secondario PATH, i valori di percorso e di nodo sono colonne chiave che consentono ricerche di percorsi più efficienti.</span><span class="sxs-lookup"><span data-stu-id="11a12-183">In the PATH secondary index, the path and node values are key columns that allow for more efficient seeks when searching for paths.</span></span> <span data-ttu-id="11a12-184">Query Optimizer può utilizzare l'indice PATH per espressioni analoghe alle seguenti:</span><span class="sxs-lookup"><span data-stu-id="11a12-184">The query optimizer may use the PATH index for expressions such as those shown in the following:</span></span>  
  
-   <span data-ttu-id="11a12-185">`/root/Location` che specifica solo un percorso</span><span class="sxs-lookup"><span data-stu-id="11a12-185">`/root/Location` which specify only a path</span></span>  
  
 <span data-ttu-id="11a12-186">OR</span><span class="sxs-lookup"><span data-stu-id="11a12-186">OR</span></span>  
  
-   <span data-ttu-id="11a12-187">`/root/Location/@LocationID[.="10"]` in cui vengono specificati sia il valore di percorso che il valore di nodo.</span><span class="sxs-lookup"><span data-stu-id="11a12-187">`/root/Location/@LocationID[.="10"]` where both the path and the node value are specified.</span></span>  
  
 <span data-ttu-id="11a12-188">Nella query seguente viene illustrato il caso in cui è utile l'indice PATH:</span><span class="sxs-lookup"><span data-stu-id="11a12-188">The following query shows where the PATH index is helpful:</span></span>  
  
```  
WITH XMLNAMESPACES ('https://schemas.microsoft.com/sqlserver/2004/07/adventure-works/ProductModelDescription' AS "PD")  
  
SELECT CatalogDescription.query('  
  /PD:ProductDescription/PD:Summary  
') AS Result  
FROM Production.ProductModel  
WHERE CatalogDescription.exist ('/PD:ProductDescription/@ProductModelID[.="19"]') = 1  
```  
  
 <span data-ttu-id="11a12-189">Nella query l'espressione di percorso `/PD:ProductDescription/@ProductModelID` e il valore `"19"` nel metodo `exist()` corrispondono ai campi chiave dell'indice PATH.</span><span class="sxs-lookup"><span data-stu-id="11a12-189">In the query, the path expression `/PD:ProductDescription/@ProductModelID` and value `"19"` in the `exist()` method correspond to the key fields of the PATH index.</span></span> <span data-ttu-id="11a12-190">In tal modo, è possibile eseguire una ricerca diretta nell'indice PATH e ottenere prestazioni di ricerca migliori rispetto a quelle della ricerca sequenziale di valori di percorso nell'indice primario.</span><span class="sxs-lookup"><span data-stu-id="11a12-190">This allows for direct seek in the PATH index and provides better search performance than the sequential search for path values in the primary index.</span></span>  
  
### <a name="value-secondary-xml-index"></a><span data-ttu-id="11a12-191">Indice XML secondario VALUE</span><span class="sxs-lookup"><span data-stu-id="11a12-191">VALUE Secondary XML Index</span></span>  
 <span data-ttu-id="11a12-192">Se le query sono basate su valori, come ad esempio nel caso di `/Root/ProductDescription/@*[. = "Mountain Bike"]` o `//ProductDescription[@Name = "Mountain Bike"]`, e il percorso specificato non è completo o include un carattere jolly, è possibile velocizzare la ricerca compilando un indice XML secondario basato sui valori di nodo dell'indice XML primario.</span><span class="sxs-lookup"><span data-stu-id="11a12-192">If queries are value based, for example, `/Root/ProductDescription/@*[. = "Mountain Bike"]` or `//ProductDescription[@Name = "Mountain Bike"]`, and the path is not fully specified or it includes a wildcard, you might obtain faster results by building a secondary XML index that is built on node values in the primary XML index.</span></span>  
  
 <span data-ttu-id="11a12-193">Le colonne chiave dell'indice VALUE sono il valore di nodo e il percorso dell'indice XML primario.</span><span class="sxs-lookup"><span data-stu-id="11a12-193">The key columns of the VALUE index are (node value and path) of the primary XML index.</span></span> <span data-ttu-id="11a12-194">Se il carico di lavoro implica l'esecuzione di query per valori da istanze XML senza conoscere i nomi di elemento o di attributo che contengono tali valori, un indice VALUE può risultare utile.</span><span class="sxs-lookup"><span data-stu-id="11a12-194">If your workload involves querying for values from XML instances without knowing the element or attribute names that contain the values, a VALUE index may be useful.</span></span> <span data-ttu-id="11a12-195">Ad esempio, un indice VALUE risulta vantaggioso per l'espressione seguente:</span><span class="sxs-lookup"><span data-stu-id="11a12-195">For example, the following expression will benefit from having a VALUE index:</span></span>  
  
-   <span data-ttu-id="11a12-196">`//author[LastName="someName"]` dove si conosce il valore dell'elemento <`LastName`> ma l'elemento padre <`author`> può trovarsi ovunque.</span><span class="sxs-lookup"><span data-stu-id="11a12-196">`//author[LastName="someName"]` where you know the value of the <`LastName`> element, but the <`author`> parent can occur anywhere.</span></span>  
  
-   <span data-ttu-id="11a12-197">`/book[@* = "someValue"]` dove la query cerca l'elemento <`book`> che dispone di un qualche attributo con valore `"someValue"`.</span><span class="sxs-lookup"><span data-stu-id="11a12-197">`/book[@* = "someValue"]` where the query looks for the <`book`> element that has some attribute having the value `"someValue"`.</span></span>  
  
 <span data-ttu-id="11a12-198">La query seguente restituisce `ContactID` dalla tabella `Contact` .</span><span class="sxs-lookup"><span data-stu-id="11a12-198">The following query returns `ContactID` from the `Contact` table.</span></span> <span data-ttu-id="11a12-199">La `WHERE` clausola specifica un filtro che cerca valori nella `AdditionalContactInfo``xml` colonna tipo.</span><span class="sxs-lookup"><span data-stu-id="11a12-199">The `WHERE` clause specifies a filter that looks for values in the `AdditionalContactInfo``xml` type column.</span></span> <span data-ttu-id="11a12-200">Gli ID dei contatti vengono restituiti solo se il BLOB XML con le informazioni aggiuntive corrispondenti include un numero di telefono specifico.</span><span class="sxs-lookup"><span data-stu-id="11a12-200">The contact IDs are returned only if the corresponding additional contact information XML binary large object includes a specific telephone number.</span></span> <span data-ttu-id="11a12-201">Poiché l'elemento <`telephoneNumber`> può trovarsi ovunque nell'XML, l'espressione del percorso specifica l'asse discendente o stesso.</span><span class="sxs-lookup"><span data-stu-id="11a12-201">Because the <`telephoneNumber`> element may appear anywhere in the XML, the path expression specifies the descendent-or-self axis.</span></span>  
  
```  
WITH XMLNAMESPACES (  
  'https://schemas.microsoft.com/sqlserver/2004/07/adventure-works/ContactInfo' AS CI,  
  'https://schemas.microsoft.com/sqlserver/2004/07/adventure-works/ContactTypes' AS ACT)  
  
SELECT ContactID   
FROM   Person.Contact  
WHERE  AdditionalContactInfo.exist('//ACT:telephoneNumber/ACT:number[.="111-111-1111"]') = 1  
```  
  
 <span data-ttu-id="11a12-202">In questo caso, il valore di ricerca di <`number`> è noto ma può trovarsi ovunque nell'istanza XML come figlio dell'elemento <`telephoneNumber`>.</span><span class="sxs-lookup"><span data-stu-id="11a12-202">In this situation, the search value for <`number`> is known, but it can appear anywhere in the XML instance as a child of the <`telephoneNumber`> element.</span></span> <span data-ttu-id="11a12-203">Per questo tipo di query può risultare utile eseguire una ricerca nell'indice basata su un valore specifico.</span><span class="sxs-lookup"><span data-stu-id="11a12-203">This kind of query might benefit from an index lookup based on a specific value.</span></span>  
  
### <a name="property-secondary-index"></a><span data-ttu-id="11a12-204">Indice secondario PROPERTY</span><span class="sxs-lookup"><span data-stu-id="11a12-204">PROPERTY Secondary Index</span></span>  
 <span data-ttu-id="11a12-205">Per le query che recuperano uno o più valori da singole istanze XML può essere utile un indice PROPERTY.</span><span class="sxs-lookup"><span data-stu-id="11a12-205">Queries that retrieve one or more values from individual XML instances might benefit from a PROPERTY index.</span></span> <span data-ttu-id="11a12-206">Questo scenario si verifica quando si recuperano le proprietà dell'oggetto utilizzando il metodo **value ()** del `xml` tipo e quando il valore della chiave primaria dell'oggetto è noto.</span><span class="sxs-lookup"><span data-stu-id="11a12-206">This scenario occurs when you retrieve object properties by using the **value()** method of the `xml` type and when the primary key value of the object is known.</span></span>  
  
 <span data-ttu-id="11a12-207">L'indice PROPERTY viene compilato in base alle colonne PK e Path e al valore di nodo dell'indice XML primario, in cui PK è la chiave primaria della tabella di base.</span><span class="sxs-lookup"><span data-stu-id="11a12-207">The PROPERTY index is built on columns (PK, Path and node value) of the primary XML index where PK is the primary key of the base table.</span></span>  
  
 <span data-ttu-id="11a12-208">Ad esempio, per il modello di prodotto `19`, la query seguente recupera i valori degli attributi `ProductModelID` e `ProductModelName` tramite il metodo `value()` .</span><span class="sxs-lookup"><span data-stu-id="11a12-208">For example, for product model `19`, the following query retrieves the `ProductModelID` and `ProductModelName` attribute values using the `value()` method.</span></span> <span data-ttu-id="11a12-209">Anziché utilizzare l'indice XML primario o gli altri indici XML secondari, l'indice PROPERTY consente di velocizzare l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="11a12-209">Instead of using the primary XML index or the other secondary XML indexes, the PROPERTY index may provide faster execution.</span></span>  
  
```  
WITH XMLNAMESPACES ('https://schemas.microsoft.com/sqlserver/2004/07/adventure-works/ProductModelDescription' AS "PD")  
  
SELECT CatalogDescription.value('(/PD:ProductDescription/@ProductModelID)[1]', 'int') as ModelID,  
       CatalogDescription.value('(/PD:ProductDescription/@ProductModelName)[1]', 'varchar(30)') as ModelName          
FROM Production.ProductModel     
WHERE ProductModelID = 19  
```  
  
 <span data-ttu-id="11a12-210">Ad eccezione delle differenze descritte più avanti in questo argomento, la creazione di un indice XML in una `xml` colonna di tipo è simile alla creazione di un indice in una colonna non di `xml` tipo.</span><span class="sxs-lookup"><span data-stu-id="11a12-210">Except for the differences described later in this topic, creating an XML index on an`xml` type column is similar to creating an index on a non-`xml` type column.</span></span> <span data-ttu-id="11a12-211">Per la creazione e la gestione di indici XML, è possibile utilizzare le istruzioni DDL [!INCLUDE[tsql](../../includes/tsql-md.md)] seguenti:</span><span class="sxs-lookup"><span data-stu-id="11a12-211">The following [!INCLUDE[tsql](../../includes/tsql-md.md)] DDL statements can be used to create and manage XML indexes:</span></span>  
  
-   [<span data-ttu-id="11a12-212">CREATE INDEX &#40;Transact-SQL&#41;</span><span class="sxs-lookup"><span data-stu-id="11a12-212">CREATE INDEX &#40;Transact-SQL&#41;</span></span>](/sql/t-sql/statements/create-index-transact-sql)  
  
-   [<span data-ttu-id="11a12-213">ALTER INDEX &#40;Transact-SQL&#41;</span><span class="sxs-lookup"><span data-stu-id="11a12-213">ALTER INDEX &#40;Transact-SQL&#41;</span></span>](/sql/t-sql/statements/alter-index-transact-sql)  
  
-   [<span data-ttu-id="11a12-214">DROP INDEX &#40;Transact-SQL&#41;</span><span class="sxs-lookup"><span data-stu-id="11a12-214">DROP INDEX &#40;Transact-SQL&#41;</span></span>](/sql/t-sql/statements/drop-index-transact-sql)  
  
## <a name="getting-information-about-xml-indexes"></a><span data-ttu-id="11a12-215">Informazioni sugli indici XML</span><span class="sxs-lookup"><span data-stu-id="11a12-215">Getting Information about XML Indexes</span></span>  
 <span data-ttu-id="11a12-216">Le voci di un indice XML compaiono nella vista del catalogo sys.indexes con tipo di indice 3.</span><span class="sxs-lookup"><span data-stu-id="11a12-216">XML index entries appear in the catalog view, sys.indexes, with the index "type" 3.</span></span> <span data-ttu-id="11a12-217">La colonna del nome contiene il nome dell'indice XML.</span><span class="sxs-lookup"><span data-stu-id="11a12-217">The name column contains the name of the XML index.</span></span>  
  
 <span data-ttu-id="11a12-218">Gli indici XML vengono registrati anche nella vista del catalogo sys.xml_indexes,</span><span class="sxs-lookup"><span data-stu-id="11a12-218">XML indexes are also recorded in the catalog view, sys.xml_indexes.</span></span> <span data-ttu-id="11a12-219">che contiene tutte le colonne della vista sys.indexes e alcune colonne specifiche, utili per gli indici XML.</span><span class="sxs-lookup"><span data-stu-id="11a12-219">This contains all the columns of sys.indexes and some specific ones that are useful for XML indexes.</span></span> <span data-ttu-id="11a12-220">Il valore NULL nella colonna secondary_type indica un indice XML primario, mentre i valori 'P', 'R' e 'V' indicano, rispettivamente, indici XML secondari di tipo PATH, PROPERTY e VALUE.</span><span class="sxs-lookup"><span data-stu-id="11a12-220">The value NULL in the column, secondary_type, indicates a primary XML index; the values 'P', 'R' and 'V' stand for PATH, PROPERTY, and VALUE secondary XML indexes, respectively.</span></span>  
  
 <span data-ttu-id="11a12-221">Per ottenere informazioni sullo spazio usato dagli indici XML è possibile usare la funzione con valori di tabella [sys.dm_db_index_physical_stats](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-index-physical-stats-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="11a12-221">The space use of XML indexes can be found in the table-valued function [sys.dm_db_index_physical_stats](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-index-physical-stats-transact-sql).</span></span> <span data-ttu-id="11a12-222">che restituisce informazioni come il numero di pagine del disco occupate, le dimensioni medie delle righe in byte e il numero dei record, per tutti i tipi di indici,</span><span class="sxs-lookup"><span data-stu-id="11a12-222">It provides information, such as the number of disk pages occupied, average row size in bytes, and number of records, for all index types..</span></span> <span data-ttu-id="11a12-223">inclusi gli indici XML.</span><span class="sxs-lookup"><span data-stu-id="11a12-223">This also includes XML indexes.</span></span> <span data-ttu-id="11a12-224">Tali informazioni sono disponibili per ogni partizione del database.</span><span class="sxs-lookup"><span data-stu-id="11a12-224">This information is available for each database partition.</span></span> <span data-ttu-id="11a12-225">Gli indici XML utilizzano lo stesso schema di partizionamento e la stessa funzione di partizionamento della tabella di base.</span><span class="sxs-lookup"><span data-stu-id="11a12-225">XML indexes use the same partitioning scheme and partitioning function of the base table.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="11a12-226">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="11a12-226">See Also</span></span>  
 <span data-ttu-id="11a12-227">[sys.dm_db_index_physical_stats &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-index-physical-stats-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="11a12-227">[sys.dm_db_index_physical_stats &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-index-physical-stats-transact-sql) </span></span>  
 [<span data-ttu-id="11a12-228">Dati XML &#40;SQL Server&#41;</span><span class="sxs-lookup"><span data-stu-id="11a12-228">XML Data &#40;SQL Server&#41;</span></span>](../xml/xml-data-sql-server.md)  
  
  
