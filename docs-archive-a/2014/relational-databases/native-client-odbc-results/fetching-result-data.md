---
title: Recupero dei dati dei risultati | Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- SQLFetchScroll function
- SQL Server Native Client ODBC driver, result sets
- ODBC applications, result sets
- data types [ODBC], fetching
- SQLBindCol function
- result sets [ODBC], fetching
- fetching [ODBC]
- ODBC data types, fetching
- SQLFetch function
- SQL Server Native Client ODBC driver, data types
- SQLGetData function
ms.assetid: b289c7fb-5017-4d7e-a2d3-19401e9fc4cd
author: rothja
ms.author: jroth
ms.openlocfilehash: 7eb038d431dd7f733c36e5913d72cdc6a161acad
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/04/2020
ms.locfileid: "87725652"
---
# <a name="fetching-result-data"></a><span data-ttu-id="3885a-102">Recupero di dati dei risultati</span><span class="sxs-lookup"><span data-stu-id="3885a-102">Fetching Result Data</span></span>
  <span data-ttu-id="3885a-103">Un'applicazione ODBC dispone di tre opzioni per il recupero dei dati dei risultati.</span><span class="sxs-lookup"><span data-stu-id="3885a-103">An ODBC application has three options for fetching result data.</span></span>  
  
 <span data-ttu-id="3885a-104">La prima opzione è basata su [SQLBindCol](../native-client-odbc-api/sqlbindcol.md).</span><span class="sxs-lookup"><span data-stu-id="3885a-104">The first option is based on [SQLBindCol](../native-client-odbc-api/sqlbindcol.md).</span></span> <span data-ttu-id="3885a-105">Prima di recuperare il set di risultati, l'applicazione utilizza **SQLBindCol** per associare ogni colonna del set di risultati a una variabile di programma.</span><span class="sxs-lookup"><span data-stu-id="3885a-105">Before fetching the result set, the application uses **SQLBindCol** to bind each column in the result set to a program variable.</span></span> <span data-ttu-id="3885a-106">Dopo aver associato le colonne, il driver trasferisce i dati della riga corrente alle variabili associato alle colonne del set di risultati ogni volta che l'applicazione chiama **SQLFetch** o [SQLFetchScroll](../native-client-odbc-api/sqlfetchscroll.md).</span><span class="sxs-lookup"><span data-stu-id="3885a-106">After the columns have been bound, the driver transfers the data of the current row into the variables bound to the result set columns each time the application calls **SQLFetch** or [SQLFetchScroll](../native-client-odbc-api/sqlfetchscroll.md).</span></span> <span data-ttu-id="3885a-107">Il driver gestisce le conversioni di dati se la colonna del set di risultati e la variabile di programma hanno tipi di dati diversi.</span><span class="sxs-lookup"><span data-stu-id="3885a-107">The driver handles data conversions if the result set column and program variable have different data types.</span></span> <span data-ttu-id="3885a-108">Se l'applicazione dispone di SQL_ATTR_ROW_ARRAY_SIZE impostato su un valore maggiore di 1, può associare le colonne dei risultati a matrici di variabili, che verranno tutte riempite a ogni chiamata a **SQLFetchScroll**.</span><span class="sxs-lookup"><span data-stu-id="3885a-108">If the application has SQL_ATTR_ROW_ARRAY_SIZE set greater than 1, it can bind result columns to arrays of variables, which will all be filled on each call to **SQLFetchScroll**.</span></span>  
  
 <span data-ttu-id="3885a-109">La seconda opzione è basata su [SQLGetData](../native-client-odbc-api/sqlgetdata.md).</span><span class="sxs-lookup"><span data-stu-id="3885a-109">The second option is based on [SQLGetData](../native-client-odbc-api/sqlgetdata.md).</span></span> <span data-ttu-id="3885a-110">L'applicazione non utilizza **SQLBindCol** per associare le colonne del set di risultati alle variabili di programma.</span><span class="sxs-lookup"><span data-stu-id="3885a-110">The application does not use **SQLBindCol** to bind result set columns to program variables.</span></span> <span data-ttu-id="3885a-111">Dopo ogni chiamata a **SQLFetch**, l'applicazione chiama **SQLGetData** una volta per ogni colonna del set di risultati.</span><span class="sxs-lookup"><span data-stu-id="3885a-111">After each call to **SQLFetch**, the application calls **SQLGetData** once for each column in the result set.</span></span> <span data-ttu-id="3885a-112">**SQLGetData** indica al driver di trasferire i dati da una colonna del set di risultati specifica a una variabile di programma specifica e specifica i tipi di dati della colonna e della variabile.</span><span class="sxs-lookup"><span data-stu-id="3885a-112">**SQLGetData** instructs the driver to transfer data from a specific result set column to a specific program variable and specifies the data types of the column and variable.</span></span> <span data-ttu-id="3885a-113">In questo modo il driver può convertire dati se la colonna dei risultati e la variabile di programma hanno tipi di dati diversi.</span><span class="sxs-lookup"><span data-stu-id="3885a-113">This allows the driver to convert data if the result column and program variable have different data types.</span></span> <span data-ttu-id="3885a-114">Le colonne di tipo **Text**, **ntext**e **Image** sono in genere troppo grandi per adattarsi a una variabile di programma, ma possono comunque essere recuperate tramite **SQLGetData**.</span><span class="sxs-lookup"><span data-stu-id="3885a-114">**Text**, **ntext**, and **image** columns are typically too large to fit into a program variable but can still be retrieved using **SQLGetData**.</span></span> <span data-ttu-id="3885a-115">Se i dati di tipo **Text**, **ntext**o **Image** nella colonna risultato sono maggiori della variabile di programma, **SQLGetData** restituisce SQL_SUCCESS_WITH_INFO e SQLSTATE 01004 (dati stringa, troncati a destra).</span><span class="sxs-lookup"><span data-stu-id="3885a-115">If the **text**, **ntext**, or **image** data in the result column is larger than the program variable, **SQLGetData** returns SQL_SUCCESS_WITH_INFO and SQLSTATE 01004 (string data, right truncated).</span></span> <span data-ttu-id="3885a-116">Le chiamate successive a **SQLGetData** restituiscono blocchi successivi dei dati di **testo** o di **immagine** .</span><span class="sxs-lookup"><span data-stu-id="3885a-116">Successive calls to **SQLGetData** return successive chunks of the **text** or **image** data.</span></span> <span data-ttu-id="3885a-117">Quando viene raggiunta la fine dei dati, **SQLGetData** restituisce SQL_SUCCESS.</span><span class="sxs-lookup"><span data-stu-id="3885a-117">When the end of the data is reached, **SQLGetData** returns SQL_SUCCESS.</span></span> <span data-ttu-id="3885a-118">Ciascun recupero restituisce un set di righe se SQL_ATTR_ROW_ARRAY_SIZE è maggiore di 1.</span><span class="sxs-lookup"><span data-stu-id="3885a-118">Each fetch returns a set of rows, or rowset, if SQL_ATTR_ROW_ARRAY_SIZE is greater than 1.</span></span> <span data-ttu-id="3885a-119">Prima di utilizzare **SQLGetData**, è necessario innanzitutto utilizzare **SQLSetPos** per specificare una riga specifica all'interno del set di righe come riga corrente.</span><span class="sxs-lookup"><span data-stu-id="3885a-119">Before using **SQLGetData**, you must first use **SQLSetPos** to specify a specific row within the rowset as the current row.</span></span>  
  
 <span data-ttu-id="3885a-120">La terza opzione prevede l'uso di una combinazione di **SQLBindCol** e **SQLGetData**.</span><span class="sxs-lookup"><span data-stu-id="3885a-120">The third option is to use a mix of **SQLBindCol** and **SQLGetData**.</span></span> <span data-ttu-id="3885a-121">Un'applicazione potrebbe, ad esempio, associare le prime dieci colonne di un set di risultati e quindi, a ogni recupero, chiamare **SQLGetData** tre volte per recuperare i dati da tre colonne non associate.</span><span class="sxs-lookup"><span data-stu-id="3885a-121">An application could, for example, bind the first ten columns of a result set and then, on each fetch, call **SQLGetData** three times to retrieve the data from three unbound columns.</span></span> <span data-ttu-id="3885a-122">Questa operazione viene in genere utilizzata quando un set di risultati contiene una o più colonne di **testo** o di **immagine** .</span><span class="sxs-lookup"><span data-stu-id="3885a-122">This would typically be used when a result set contains one or more **text** or **image** columns.</span></span>  
  
 <span data-ttu-id="3885a-123">A seconda delle opzioni del cursore impostate per il set di risultati, un'applicazione può utilizzare anche le opzioni di scorrimento di **SQLFetchScroll** per scorrere intorno al set di risultati.</span><span class="sxs-lookup"><span data-stu-id="3885a-123">Depending on the cursor options set for the result set, an application can also use the scrolling options of **SQLFetchScroll** to scroll around the result set.</span></span>  
  
 <span data-ttu-id="3885a-124">Un utilizzo eccessivo di **SQLBindCol** per associare una colonna del set di risultati a una variabile di programma è costoso perché **SQLBindCol** comporta l'allocazione della memoria da un driver ODBC.</span><span class="sxs-lookup"><span data-stu-id="3885a-124">Excess use of **SQLBindCol** to bind a result set column to a program variable is expensive because **SQLBindCol** causes an ODBC driver to allocate memory.</span></span> <span data-ttu-id="3885a-125">Quando si associa una colonna risultato a una variabile, tale binding rimane attivo fino a quando non si chiama [SQLFreeHandle](../native-client-odbc-api/sqlfreehandle.md) per liberare l'handle di istruzione oppure si chiama [SQLFreeStmt](../native-client-odbc-api/sqlfreestmt.md) con *fOption* impostato su SQL_UNBIND.</span><span class="sxs-lookup"><span data-stu-id="3885a-125">When you bind a result column to a variable, that binding remains in effect until you either call [SQLFreeHandle](../native-client-odbc-api/sqlfreehandle.md) to free the statement handle or call [SQLFreeStmt](../native-client-odbc-api/sqlfreestmt.md) with *fOption* set to SQL_UNBIND.</span></span> <span data-ttu-id="3885a-126">Le associazioni non vengono annullate automaticamente al termine dell'istruzione.</span><span class="sxs-lookup"><span data-stu-id="3885a-126">The bindings are not automatically undone when the statement completes.</span></span>  
  
 <span data-ttu-id="3885a-127">Questa logica consente di gestire in modo efficace l'esecuzione della stessa istruzione SELECT più volte con parametri diversi.</span><span class="sxs-lookup"><span data-stu-id="3885a-127">This logic allows you to effectively deal with executing the same SELECT statement several times with different parameters.</span></span> <span data-ttu-id="3885a-128">Poiché il set di risultati mantiene la stessa struttura, è possibile associare il set di risultati una sola volta, elaborare tutte le istruzioni SELECT, quindi chiamare **SQLFreeStmt** con *fOption* impostato su SQL_UNBIND dopo l'ultima esecuzione.</span><span class="sxs-lookup"><span data-stu-id="3885a-128">Because the result set keeps the same structure, you can bind the result set once, process all the SELECT statements, then call **SQLFreeStmt** with *fOption* set to SQL_UNBIND after the last execution.</span></span> <span data-ttu-id="3885a-129">Non chiamare **SQLBindCol** per associare le colonne in un set di risultati senza prima chiamare **SQLFreeStmt** con *fOption* impostato su SQL_UNBIND per liberare le associazioni precedenti.</span><span class="sxs-lookup"><span data-stu-id="3885a-129">You should not call **SQLBindCol** to bind the columns in a result set without first calling **SQLFreeStmt** with *fOption* set to SQL_UNBIND to free any previous bindings.</span></span>  
  
 <span data-ttu-id="3885a-130">Quando si usa **SQLBindCol**, è possibile eseguire l'associazione per riga o per colonna.</span><span class="sxs-lookup"><span data-stu-id="3885a-130">When using **SQLBindCol**, you can either do row-wise or column-wise binding.</span></span> <span data-ttu-id="3885a-131">L'associazione per riga è leggermente più veloce dell'associazione per colonna.</span><span class="sxs-lookup"><span data-stu-id="3885a-131">Row-wise binding is somewhat faster than column-wise binding.</span></span>  
  
 <span data-ttu-id="3885a-132">È possibile utilizzare **SQLGetData** per recuperare i dati in base a una colonna, anziché associare le colonne del set di risultati utilizzando **SQLBindCol**.</span><span class="sxs-lookup"><span data-stu-id="3885a-132">You can use **SQLGetData** to retrieve data on a column-by-column basis instead of binding result set columns using **SQLBindCol**.</span></span> <span data-ttu-id="3885a-133">Se un set di risultati contiene solo poche righe, l'utilizzo di **SQLGetData** invece di **SQLBindCol** è più veloce; in caso contrario, **SQLBindCol** offre le migliori prestazioni.</span><span class="sxs-lookup"><span data-stu-id="3885a-133">If a result set contains only a few rows, using **SQLGetData** instead of **SQLBindCol** is faster; otherwise, **SQLBindCol** gives the best performance.</span></span> <span data-ttu-id="3885a-134">Se non si inseriscono sempre i dati nello stesso set di variabili, è consigliabile utilizzare **SQLGetData** anziché riassociarlo costantemente.</span><span class="sxs-lookup"><span data-stu-id="3885a-134">If you do not always put the data in the same set of variables, you should use **SQLGetData** instead of constantly rebinding.</span></span> <span data-ttu-id="3885a-135">È possibile utilizzare **SQLGetData** solo nelle colonne presenti nell'elenco di selezione dopo che tutte le colonne sono associate a **SQLBindCol**.</span><span class="sxs-lookup"><span data-stu-id="3885a-135">You can only use **SQLGetData** on columns that are in the select list after all columns are bound with **SQLBindCol**.</span></span> <span data-ttu-id="3885a-136">La colonna deve essere visualizzata anche dopo tutte le colonne in cui è già stato utilizzato **SQLGetData**.</span><span class="sxs-lookup"><span data-stu-id="3885a-136">The column must also appear after any columns on which you have already used **SQLGetData**.</span></span>  
  
 <span data-ttu-id="3885a-137">Le funzioni ODBC che gestiscono lo stato di trasferimento dei dati all'interno o all'esterno delle variabili di programma, ad esempio **SQLGetData**, **SQLBindCol**e [SQLBindParameter](../native-client-odbc-api/sqlbindparameter.md), supportano la conversione implicita dei tipi di dati.</span><span class="sxs-lookup"><span data-stu-id="3885a-137">The ODBC functions that deal with moving data into or out of program variables, such as **SQLGetData**, **SQLBindCol**, and [SQLBindParameter](../native-client-odbc-api/sqlbindparameter.md), support implicit data type conversion.</span></span> <span data-ttu-id="3885a-138">Se, ad esempio, un'applicazione associa una colonna integer a una variabile di programma stringa di caratteri, il driver converte automaticamente i dati da integer in carattere prima di inserirli nella variabile di programma.</span><span class="sxs-lookup"><span data-stu-id="3885a-138">For example, if an application binds an integer column to a character string program variable, the driver automatically converts the data from integer to character before placing it into the program variable.</span></span>  
  
 <span data-ttu-id="3885a-139">La conversione dei dati nelle applicazioni deve essere ridotta al minimo.</span><span class="sxs-lookup"><span data-stu-id="3885a-139">Data conversion in applications should be minimized.</span></span> <span data-ttu-id="3885a-140">A meno che la conversione dei dati non sia necessaria per l'elaborazione eseguita dall'applicazione, è preferibile che le applicazioni non associno colonne e parametri a variabili di programma dello stesso tipo di dati.</span><span class="sxs-lookup"><span data-stu-id="3885a-140">Unless data conversion is required for the processing done by the application, applications should bind columns and parameters to program variables of the same data type.</span></span> <span data-ttu-id="3885a-141">Se i dati devono essere convertiti da un tipo a un altro, tuttavia, è più efficiente fare in modo che il driver esegua la conversione anziché lasciare che la conversione venga eseguita nell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="3885a-141">If the data must be converted from one type to another, however, it is more efficient to have the driver do the conversion than doing it in the application.</span></span> <span data-ttu-id="3885a-142">Il driver ODBC di [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client trasferisce in genere i dati direttamente dai buffer di rete alle variabili dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="3885a-142">The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver normally just transfers data directly from the network buffers to the variables of the application.</span></span> <span data-ttu-id="3885a-143">La richiesta al driver di convertire i dati forza il driver a eseguire il buffer dei dati e a utilizzare cicli della CPU per la conversione dei dati.</span><span class="sxs-lookup"><span data-stu-id="3885a-143">Requesting the driver to do data conversion forces the driver to buffer the data and use CPU cycles to convert the data.</span></span>  
  
 <span data-ttu-id="3885a-144">Le variabili di programma devono essere sufficientemente grandi da contenere i dati trasferiti da una colonna, ad eccezione dei dati di tipo **Text**, **ntext**e **Image** .</span><span class="sxs-lookup"><span data-stu-id="3885a-144">Program variables should be large enough to hold data transferred in from a column, except for **text**, **ntext**, and **image** data.</span></span> <span data-ttu-id="3885a-145">Se un'applicazione tenta di recuperare dati del set di risultati e di inserirli in una variabile di dimensioni troppo piccole per contenerli, il driver genera un avviso.</span><span class="sxs-lookup"><span data-stu-id="3885a-145">If an application attempts to retrieve result set data and place it into a variable that is too small to hold it, the driver generates a warning.</span></span> <span data-ttu-id="3885a-146">Ciò forza il driver ad allocare memoria per il messaggio e il driver e l'applicazione devono entrambi impiegare cicli della CPU per l'elaborazione del messaggio e per la gestione degli errori.</span><span class="sxs-lookup"><span data-stu-id="3885a-146">This forces the driver to allocate memory for the message, and the driver and application both have to spend CPU cycles processing the message and doing error handling.</span></span> <span data-ttu-id="3885a-147">L'applicazione deve allocare una variabile sufficientemente grande per contenere i dati recuperati oppure utilizzare la funzione SUBSTRING nell'elenco di selezione per ridurre le dimensioni della colonna nel set di risultati.</span><span class="sxs-lookup"><span data-stu-id="3885a-147">The application should either allocate a variable large enough to hold the data being retrieved or use the SUBSTRING function in the select list to reduce the size of the column in the result set.</span></span>  
  
 <span data-ttu-id="3885a-148">Quando si utilizza SQL_C_DEFAULT per specificare il tipo della variabile C, è necessario procedere con cautela.</span><span class="sxs-lookup"><span data-stu-id="3885a-148">Care must be taken when using SQL_C_DEFAULT to specify the type of the C variable.</span></span> <span data-ttu-id="3885a-149">SQL_C_DEFAULT specifica che il tipo della variabile C corrisponde al tipo di dati SQL della colonna o del parametro.</span><span class="sxs-lookup"><span data-stu-id="3885a-149">SQL_C_DEFAULT specifies that the type of the C variable matches the SQL data type of the column or parameter.</span></span> <span data-ttu-id="3885a-150">Se SQL_C_DEFAULT viene specificato per una colonna **ntext**, **nchar**o **nvarchar** , i dati Unicode vengono restituiti all'applicazione.</span><span class="sxs-lookup"><span data-stu-id="3885a-150">If SQL_C_DEFAULT is specified for an **ntext**, **nchar**, or **nvarchar** column, Unicode data is returned to the application.</span></span> <span data-ttu-id="3885a-151">Ciò può provocare diversi problemi se l'applicazione non è stata codificata per la gestione di dati Unicode.</span><span class="sxs-lookup"><span data-stu-id="3885a-151">This can cause various problems if the application has not been coded to handle Unicode data.</span></span> <span data-ttu-id="3885a-152">È possibile che si verifichino gli stessi tipi di problemi con il tipo di dati **uniqueidentifier** (SQL_GUID).</span><span class="sxs-lookup"><span data-stu-id="3885a-152">The same types of problems can occur with the **uniqueidentifier** (SQL_GUID) data type.</span></span>  
  
 <span data-ttu-id="3885a-153">i dati di tipo **Text**, **ntext**e **Image** sono in genere troppo grandi per essere contenuti in una singola variabile di programma e vengono in genere elaborati con **SQLGetData** anziché con **SQLBindCol**.</span><span class="sxs-lookup"><span data-stu-id="3885a-153">**text**, **ntext**, and **image** data is typically too large to fit into a single program variable, and is usually processed with **SQLGetData** instead of **SQLBindCol**.</span></span> <span data-ttu-id="3885a-154">Quando si utilizzano i cursori server, il [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] driver ODBC di Native Client è ottimizzato per non trasmettere i dati per le colonne di tipo **Text**, **ntext**o **Image** non associato al momento del recupero della riga.</span><span class="sxs-lookup"><span data-stu-id="3885a-154">When using server cursors, the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver is optimized to not transmit the data for unbound **text**, **ntext**, or **image** columns at the time the row is fetched.</span></span> <span data-ttu-id="3885a-155">I dati di tipo **Text**, **ntext**o **Image** non vengono effettivamente recuperati dal server fino a quando l'applicazione non rilascia **SQLGetData** per la colonna.</span><span class="sxs-lookup"><span data-stu-id="3885a-155">The **text**, **ntext**, or **image** data is not actually retrieved from the server until the application issues **SQLGetData** for the column.</span></span>  
  
 <span data-ttu-id="3885a-156">Questa ottimizzazione può essere applicata alle applicazioni in modo che non vengano visualizzati dati di tipo **Text**, **ntext**o **Image** quando un utente scorre verso l'alto e verso il basso di un cursore.</span><span class="sxs-lookup"><span data-stu-id="3885a-156">This optimization can be applied to applications so that no **text**, **ntext**, or **image** data is displayed while a user is scrolling up and down a cursor.</span></span> <span data-ttu-id="3885a-157">Dopo che l'utente ha selezionato una riga, l'applicazione può chiamare **SQLGetData** per recuperare i dati di tipo **Text**, **ntext**o **Image** .</span><span class="sxs-lookup"><span data-stu-id="3885a-157">After the user selects a row, the application can call **SQLGetData** to retrieve the **text**, **ntext**, or **image** data.</span></span> <span data-ttu-id="3885a-158">In questo modo viene salvata la trasmissione dei dati di tipo **Text**, **ntext**o **Image** per tutte le righe che l'utente non seleziona e che può salvare la trasmissione di quantità molto elevate di dati.</span><span class="sxs-lookup"><span data-stu-id="3885a-158">This saves transmitting the **text**, **ntext**, or **image** data for any of the rows the user does not select and can save the transmission of very large amounts of data.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3885a-159">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="3885a-159">See Also</span></span>  
 [<span data-ttu-id="3885a-160">Elaborazione dei risultati &#40;&#41;ODBC</span><span class="sxs-lookup"><span data-stu-id="3885a-160">Processing Results &#40;ODBC&#41;</span></span>](processing-results-odbc.md)  
  
  
