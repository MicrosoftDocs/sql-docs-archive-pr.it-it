---
title: Guida all'elaborazione delle query per le tabelle con ottimizzazione per la memoria | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 065296fe-6711-4837-965e-252ef6c13a0f
author: rothja
ms.author: jroth
ms.openlocfilehash: 93489e5dea295964826005e081bcffe889cb7586
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/04/2020
ms.locfileid: "87636085"
---
# <a name="a-guide-to-query-processing-for-memory-optimized-tables"></a><span data-ttu-id="d4052-102">Guida all'elaborazione delle query per le tabelle con ottimizzazione per la memoria</span><span class="sxs-lookup"><span data-stu-id="d4052-102">A Guide to Query Processing for Memory-Optimized Tables</span></span>
  <span data-ttu-id="d4052-103">Con OLTP in memoria sono state introdotte le tabelle ottimizzate per la memoria e le stored procedure compilate in modo nativo in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="d4052-103">In-Memory OLTP introduces memory-optimized tables and natively compiled stored procedures in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="d4052-104">In questo articolo viene fornita una panoramica sull'elaborazione delle query per le tabelle ottimizzate per la memoria e le stored procedure compilate in modo nativo.</span><span class="sxs-lookup"><span data-stu-id="d4052-104">This article gives an overview of query processing for both memory-optimized tables and natively compiled stored procedures.</span></span>  
  
 <span data-ttu-id="d4052-105">Nel documento viene illustrato come compilare ed eseguire query sulle tabelle ottimizzate per la memoria, tra cui:</span><span class="sxs-lookup"><span data-stu-id="d4052-105">The document explains how queries on memory-optimized tables are compiled and executed, including:</span></span>  
  
-   <span data-ttu-id="d4052-106">La pipeline di elaborazione delle query in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] per le tabelle basate su disco.</span><span class="sxs-lookup"><span data-stu-id="d4052-106">The query processing pipeline in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for disk-based tables.</span></span>  
  
-   <span data-ttu-id="d4052-107">Ottimizzazione query; il ruolo delle statistiche sulle tabelle ottimizzate per la memoria e linee guida per la risoluzione dei problemi relativi a piani di query errati.</span><span class="sxs-lookup"><span data-stu-id="d4052-107">Query optimization; the role of statistics on memory-optimized tables as well as guidelines for troubleshooting bad query plans.</span></span>  
  
-   <span data-ttu-id="d4052-108">L'uso del codice [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretato per accedere alle tabelle ottimizzate per la memoria.</span><span class="sxs-lookup"><span data-stu-id="d4052-108">The use of interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] to access memory-optimized tables.</span></span>  
  
-   <span data-ttu-id="d4052-109">Considerazioni sull'ottimizzazione query per l'accesso alle tabelle ottimizzate per la memoria.</span><span class="sxs-lookup"><span data-stu-id="d4052-109">Considerations about query optimization for memory-optimized table access.</span></span>  
  
-   <span data-ttu-id="d4052-110">Compilazione ed elaborazione di stored procedure compilate in modo nativo.</span><span class="sxs-lookup"><span data-stu-id="d4052-110">Natively compiled stored procedure compilation and processing.</span></span>  
  
-   <span data-ttu-id="d4052-111">Statistiche utilizzate per la stima dei costi in Query Optimizer.</span><span class="sxs-lookup"><span data-stu-id="d4052-111">Statistics that are used for cost estimation by the optimizer.</span></span>  
  
-   <span data-ttu-id="d4052-112">Modi per correggere piani di query errati.</span><span class="sxs-lookup"><span data-stu-id="d4052-112">Ways to fix bad query plans.</span></span>  
  
## <a name="example-query"></a><span data-ttu-id="d4052-113">Query di esempio</span><span class="sxs-lookup"><span data-stu-id="d4052-113">Example Query</span></span>  
 <span data-ttu-id="d4052-114">L'esempio seguente verrà utilizzato per illustrare i concetti di elaborazione delle query descritti in questo articolo.</span><span class="sxs-lookup"><span data-stu-id="d4052-114">The following example will be used to illustrate the query processing concepts discussed in this article.</span></span>  
  
 <span data-ttu-id="d4052-115">Vengono considerate due tabelle, Customer e Order.</span><span class="sxs-lookup"><span data-stu-id="d4052-115">We consider two tables, Customer and Order.</span></span> <span data-ttu-id="d4052-116">Il seguente script di [!INCLUDE[tsql](../../../includes/tsql-md.md)] contiene le definizioni di queste due tabelle e gli indici associati, nel formato basato su disco (tradizionale):</span><span class="sxs-lookup"><span data-stu-id="d4052-116">The following [!INCLUDE[tsql](../../../includes/tsql-md.md)] script contains the definitions for these two tables and associated indexes, in their (traditional) disk-based form:</span></span>  
  
```sql  
CREATE TABLE dbo.[Customer] (  
  CustomerID nchar (5) NOT NULL PRIMARY KEY,  
  ContactName nvarchar (30) NOT NULL   
)  
GO  
  
CREATE TABLE dbo.[Order] (  
  OrderID int NOT NULL PRIMARY KEY,  
  CustomerID nchar (5) NOT NULL,  
  OrderDate date NOT NULL  
)  
GO  
CREATE INDEX IX_CustomerID ON dbo.[Order](CustomerID)  
GO  
CREATE INDEX IX_OrderDate ON dbo.[Order](OrderDate)  
GO  
```  
  
 <span data-ttu-id="d4052-117">Per la creazione dei piani di query illustrati in questo articolo, le due tabelle sono state popolate con dati del database di esempio Northwind, che è possibile scaricare da [Northwind and pubs Sample Databases for SQL Server 2000](https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/northwind-pubs)(Database di esempio Northwind e pubs per SQL Server 2000).</span><span class="sxs-lookup"><span data-stu-id="d4052-117">For constructing the query plans shown in this article, the two tables were populated with sample data from the Northwind sample database, which you can download from [Northwind and pubs Sample Databases for SQL Server 2000](https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/northwind-pubs).</span></span>  
  
 <span data-ttu-id="d4052-118">Si consideri la query seguente, che crea un join tra le tabelle Customer e Order e restituisce l'ID dell'ordine e le informazioni sul cliente associato:</span><span class="sxs-lookup"><span data-stu-id="d4052-118">Consider the following query, which joins the tables Customer and Order and returns the ID of the order and the associated customer information:</span></span>  
  
```sql  
SELECT o.OrderID, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="d4052-119">Il piano di esecuzione stimato visualizzato in [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)] è illustrato di seguito:</span><span class="sxs-lookup"><span data-stu-id="d4052-119">The estimated execution plan as displayed by [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)] is as follows</span></span>  
  
 <span data-ttu-id="d4052-120">![Piano di query per il join di tabelle basate su disco.](../../database-engine/media/hekaton-query-plan-1.gif "Piano di query per il join di tabelle basate su disco.")</span><span class="sxs-lookup"><span data-stu-id="d4052-120">![Query plan for join of disk-based tables.](../../database-engine/media/hekaton-query-plan-1.gif "Query plan for join of disk-based tables.")</span></span>  
<span data-ttu-id="d4052-121">Piano di query per il join di tabelle basate su disco.</span><span class="sxs-lookup"><span data-stu-id="d4052-121">Query plan for join of disk-based tables.</span></span>  
  
 <span data-ttu-id="d4052-122">Informazioni su questo piano di query:</span><span class="sxs-lookup"><span data-stu-id="d4052-122">About this query plan:</span></span>  
  
-   <span data-ttu-id="d4052-123">Le righe della tabella Customer vengono recuperate dall'indice cluster, che è la struttura dei dati primaria e contiene i dati completi della tabella.</span><span class="sxs-lookup"><span data-stu-id="d4052-123">The rows from the Customer table are retrieved from the clustered index, which is the primary data structure and has the full table data.</span></span>  
  
-   <span data-ttu-id="d4052-124">I dati della tabella Order vengono recuperati usando l'indice non cluster della colonna CustomerID.</span><span class="sxs-lookup"><span data-stu-id="d4052-124">Data from the Order table is retrieved using the nonclustered index on the CustomerID column.</span></span> <span data-ttu-id="d4052-125">L'indice contiene sia la colonna CustomerID, utilizzata per il join, sia la colonna chiave primaria OrderID, che viene restituita all'utente.</span><span class="sxs-lookup"><span data-stu-id="d4052-125">This index contains both the CustomerID column, which is used for the join, and the primary key column OrderID, which is returned to the user.</span></span> <span data-ttu-id="d4052-126">La restituzione di colonne aggiuntive dalla tabella Order richiederebbe ricerche nell'indice cluster della tabella stessa.</span><span class="sxs-lookup"><span data-stu-id="d4052-126">Returning additional columns from the Order table would require lookups in the clustered index for the Order table.</span></span>  
  
-   <span data-ttu-id="d4052-127">L'operatore logico `Inner Join` viene implementato dall'operatore fisico `Merge Join`.</span><span class="sxs-lookup"><span data-stu-id="d4052-127">The logical operator `Inner Join` is implemented by the physical operator `Merge Join`.</span></span> <span data-ttu-id="d4052-128">Gli altri tipi di join fisico sono `Nested Loops` e `Hash Join`.</span><span class="sxs-lookup"><span data-stu-id="d4052-128">The other physical join types are `Nested Loops` and `Hash Join`.</span></span> <span data-ttu-id="d4052-129">L'operatore `Merge Join` consente di sfruttare il fatto che entrambi gli indici sono ordinati in base alla colonna di join CustomerID.</span><span class="sxs-lookup"><span data-stu-id="d4052-129">The `Merge Join` operator takes advantage of the fact that both indexes are sorted on the join column CustomerID.</span></span>  
  
 <span data-ttu-id="d4052-130">Si consideri una leggera variazione in questa query, con la restituzione di tutte le righe della tabella Order e non solo di OrderID, come illustrato di seguito:</span><span class="sxs-lookup"><span data-stu-id="d4052-130">Consider a slight variation on this query, which returns all rows from the Order table, not only OrderID:</span></span>  
  
```sql  
SELECT o.*, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="d4052-131">Il piano stimato per la query è il seguente:</span><span class="sxs-lookup"><span data-stu-id="d4052-131">The estimated plan for this query is:</span></span>  
  
 <span data-ttu-id="d4052-132">![Piano di query per un hash join di tabelle basate su disco.](../../database-engine/media/hekaton-query-plan-2.gif "Piano di query per un hash join di tabelle basate su disco.")</span><span class="sxs-lookup"><span data-stu-id="d4052-132">![Query plan for a hash join of disk-based tables.](../../database-engine/media/hekaton-query-plan-2.gif "Query plan for a hash join of disk-based tables.")</span></span>  
<span data-ttu-id="d4052-133">Piano di query per un hash join di tabelle basate su disco.</span><span class="sxs-lookup"><span data-stu-id="d4052-133">Query plan for a hash join of disk-based tables.</span></span>  
  
 <span data-ttu-id="d4052-134">In questa query le righe della tabella Order vengono recuperate utilizzando l'indice cluster.</span><span class="sxs-lookup"><span data-stu-id="d4052-134">In this query, rows from the Order table are retrieved using the clustered index.</span></span> <span data-ttu-id="d4052-135">L'operatore fisico `Hash Match` viene ora utilizzato per l'`Inner Join`.</span><span class="sxs-lookup"><span data-stu-id="d4052-135">The `Hash Match` physical operator is now used for the `Inner Join`.</span></span> <span data-ttu-id="d4052-136">L'indice cluster di Order non è ordinato in base a CustomerID, pertanto per un `Merge Join` sarebbe necessario un operatore di ordinamento, che influirebbe sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="d4052-136">The clustered index on Order is not sorted on CustomerID, and so a `Merge Join` would require a sort operator, which would affect performance.</span></span> <span data-ttu-id="d4052-137">Si noti il costo relativo dell'operatore `Hash Match` (75%) rispetto al costo dell'operatore `Merge Join` nell'esempio precedente (46%).</span><span class="sxs-lookup"><span data-stu-id="d4052-137">Note the relative cost of the `Hash Match` operator (75%) compared with the cost of the `Merge Join` operator in the previous example (46%).</span></span> <span data-ttu-id="d4052-138">In Query Optimizer l'operatore `Hash Match` è stato preso in considerazione anche nell'esempio precedente, con la conclusione, tuttavia, che l'operatore `Merge Join` avrebbe offerto prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="d4052-138">The optimizer would have considered the `Hash Match` operator also in the previous example, but concluded that the `Merge Join` operator gave better performance.</span></span>  
  
## <a name="ssnoversion-query-processing-for-disk-based-tables"></a>[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="d4052-139">Elaborazione delle query per tabelle basate su disco</span><span class="sxs-lookup"><span data-stu-id="d4052-139">Query Processing for Disk-Based Tables</span></span>  
 <span data-ttu-id="d4052-140">Nel diagramma seguente viene illustrato il flusso di elaborazione delle query ad hoc in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] :</span><span class="sxs-lookup"><span data-stu-id="d4052-140">The following diagram outlines the query processing flow in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for ad hoc queries:</span></span>  
  
 <span data-ttu-id="d4052-141">![Pipeline di elaborazione delle query di SQL Server.](../../database-engine/media/hekaton-query-plan-3.gif "Pipeline di elaborazione delle query di SQL Server.")</span><span class="sxs-lookup"><span data-stu-id="d4052-141">![SQL Server query processing pipeline.](../../database-engine/media/hekaton-query-plan-3.gif "SQL Server query processing pipeline.")</span></span>  
<span data-ttu-id="d4052-142">Pipeline di elaborazione delle query di SQL Server.</span><span class="sxs-lookup"><span data-stu-id="d4052-142">SQL Server query processing pipeline.</span></span>  
  
 <span data-ttu-id="d4052-143">In questo scenario:</span><span class="sxs-lookup"><span data-stu-id="d4052-143">In this scenario:</span></span>  
  
1.  <span data-ttu-id="d4052-144">L'utente esegue una query.</span><span class="sxs-lookup"><span data-stu-id="d4052-144">The user issues a query.</span></span>  
  
2.  <span data-ttu-id="d4052-145">Il parser e il normalizzatore creano un albero della query con operatori logici basati sul testo [!INCLUDE[tsql](../../../includes/tsql-md.md)] inviato dall'utente.</span><span class="sxs-lookup"><span data-stu-id="d4052-145">The parser and algebrizer construct a query tree with logical operators based on the [!INCLUDE[tsql](../../../includes/tsql-md.md)] text submitted by the user.</span></span>  
  
3.  <span data-ttu-id="d4052-146">Query Optimizer crea un piano di query ottimizzato che contiene operatori fisici, ad esempio join a cicli annidati.</span><span class="sxs-lookup"><span data-stu-id="d4052-146">The optimizer creates an optimized query plan containing physical operators (for example, nested-loops join).</span></span> <span data-ttu-id="d4052-147">Dopo l'ottimizzazione, il piano può essere archiviato nella cache dei piani.</span><span class="sxs-lookup"><span data-stu-id="d4052-147">After optimization, the plan may be stored in the plan cache.</span></span> <span data-ttu-id="d4052-148">Questo passaggio viene ignorato se la cache dei piani già contiene un piano per la query.</span><span class="sxs-lookup"><span data-stu-id="d4052-148">This step is bypassed if the plan cache already contains a plan for this query.</span></span>  
  
4.  <span data-ttu-id="d4052-149">Un'interpretazione del piano di query viene elaborato dal motore di esecuzione delle query.</span><span class="sxs-lookup"><span data-stu-id="d4052-149">The query execution engine processes an interpretation of the query plan.</span></span>  
  
5.  <span data-ttu-id="d4052-150">Per ogni operatore Index Seek, Index Scan e Table Scan, il motore di esecuzione richiede righe delle rispettive strutture di indice e di tabella ad Access Methods.</span><span class="sxs-lookup"><span data-stu-id="d4052-150">For each index seek, index scan, and table scan operator, the execution engine requests rows from the respective index and table structures from Access Methods.</span></span>  
  
6.  <span data-ttu-id="d4052-151">Access Methods recupera le righe dalle pagine dell'indice e dei dati nel pool di buffer e carica le pagine dal disco nel pool di buffer in base alle esigenze.</span><span class="sxs-lookup"><span data-stu-id="d4052-151">Access Methods retrieves the rows from the index and data pages in the buffer pool and loads pages from disk into the buffer pool as needed.</span></span>  
  
 <span data-ttu-id="d4052-152">Per la prima query di esempio, il motore di esecuzione richiede ad Access Methods le righe dell'indice cluster di Customer e dell'indice non cluster di Order.</span><span class="sxs-lookup"><span data-stu-id="d4052-152">For the first example query, the execution engine requests rows in the clustered index on Customer and the nonclustered index on Order from Access Methods.</span></span> <span data-ttu-id="d4052-153">Access Methods attraversa le strutture di indice ad albero B per recuperare le righe richieste.</span><span class="sxs-lookup"><span data-stu-id="d4052-153">Access Methods traverses the B-tree index structures to retrieve the requested rows.</span></span> <span data-ttu-id="d4052-154">In questo caso vengono recuperate tutte le righe poiché il piano richiede le analisi complete degli indici.</span><span class="sxs-lookup"><span data-stu-id="d4052-154">In this case all rows are retrieved as the plan calls for full index scans.</span></span>  
  
## <a name="interpreted-tsql-access-to-memory-optimized-tables"></a><span data-ttu-id="d4052-155">Accesso del codice [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretato alle tabelle con ottimizzazione per la memoria</span><span class="sxs-lookup"><span data-stu-id="d4052-155">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] Access to Memory-Optimized Tables</span></span>  
 [!INCLUDE[tsql](../../../includes/tsql-md.md)] <span data-ttu-id="d4052-156">ai batch ad hoc e alle stored procedure si fa riferimento anche con l'espressione " [!INCLUDE[tsql](../../../includes/tsql-md.md)]interpretato".</span><span class="sxs-lookup"><span data-stu-id="d4052-156">ad hoc batches and stored procedures are also referred to as interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="d4052-157">L'interpretazione si riferisce al fatto che ogni operatore nel piano di query viene interpretato dal motore di esecuzione delle query.</span><span class="sxs-lookup"><span data-stu-id="d4052-157">Interpreted refers to the fact that the query plan is interpreted by the query execution engine for each operator in the query plan.</span></span> <span data-ttu-id="d4052-158">Il motore di esecuzione legge l'operatore e i relativi parametri ed esegue l'operazione.</span><span class="sxs-lookup"><span data-stu-id="d4052-158">The execution engine reads the operator and its parameters and performs the operation.</span></span>  
  
 <span data-ttu-id="d4052-159">Il codice [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretato può essere utilizzato per accedere sia a tabelle ottimizzate per la memoria che a tabelle basate su disco.</span><span class="sxs-lookup"><span data-stu-id="d4052-159">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] can be used to access both memory-optimized and disk-based tables.</span></span> <span data-ttu-id="d4052-160">Nella figura seguente viene illustrata l'elaborazione delle query per l'accesso del codice [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretato alle tabelle ottimizzate per la memoria:</span><span class="sxs-lookup"><span data-stu-id="d4052-160">The following figure illustrates query processing for interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access to memory-optimized tables:</span></span>  
  
 <span data-ttu-id="d4052-161">![Pipeline di elaborazione query per tsql interpretato.](../../database-engine/media/hekaton-query-plan-4.gif "Pipeline di elaborazione delle query per tsql interpretato.")</span><span class="sxs-lookup"><span data-stu-id="d4052-161">![Query processing pipeline for interpreted tsql.](../../database-engine/media/hekaton-query-plan-4.gif "Query processing pipeline for interpreted tsql.")</span></span>  
<span data-ttu-id="d4052-162">Pipeline di elaborazione delle query per l'accesso del codice Transact-SQL interpretato alle tabelle ottimizzate per la memoria.</span><span class="sxs-lookup"><span data-stu-id="d4052-162">Query processing pipeline for interpreted Transact-SQL access to memory-optimized tables.</span></span>  
  
 <span data-ttu-id="d4052-163">Come illustrato nella figura, la pipeline di elaborazione delle query rimane per lo più invariata:</span><span class="sxs-lookup"><span data-stu-id="d4052-163">As illustrated by the figure, the query processing pipeline remains mostly unchanged:</span></span>  
  
-   <span data-ttu-id="d4052-164">Il parser e il normalizzatore creano l'albero della query.</span><span class="sxs-lookup"><span data-stu-id="d4052-164">The parser and algebrizer construct the query tree.</span></span>  
  
-   <span data-ttu-id="d4052-165">Query Optimizer crea il piano di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="d4052-165">The optimizer creates the execution plan.</span></span>  
  
-   <span data-ttu-id="d4052-166">Il piano di esecuzione viene interpretato dal motore di esecuzione delle query.</span><span class="sxs-lookup"><span data-stu-id="d4052-166">The query execution engine interprets the execution plan.</span></span>  
  
 <span data-ttu-id="d4052-167">La differenza principale rispetto alla pipeline tradizionale di elaborazione delle query (figura 2) sta nel fatto che le righe delle tabelle ottimizzate per la memoria non vengono recuperate dal pool di buffer tramite Access Methods.</span><span class="sxs-lookup"><span data-stu-id="d4052-167">The main difference with the traditional query processing pipeline (figure 2) is that rows for memory-optimized tables are not retrieved from the buffer pool using Access Methods.</span></span> <span data-ttu-id="d4052-168">Al contrario, le righe vengono recuperate dalle strutture dei dati in memoria tramite il motore di OLTP in memoria.</span><span class="sxs-lookup"><span data-stu-id="d4052-168">Instead, rows are retrieved from the in-memory data structures through the In-Memory OLTP engine.</span></span> <span data-ttu-id="d4052-169">Le differenze nelle strutture dei dati provocano in alcuni casi la selezione di piani diversi da parte di Query Optimizer, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="d4052-169">Differences in data structures cause the optimizer to pick different plans in some cases, as illustrated by the following example.</span></span>  
  
 <span data-ttu-id="d4052-170">Lo script [!INCLUDE[tsql](../../../includes/tsql-md.md)] riportato di seguito contiene versioni ottimizzate per la memoria delle tabelle Order e Customer, con indici hash:</span><span class="sxs-lookup"><span data-stu-id="d4052-170">The following [!INCLUDE[tsql](../../../includes/tsql-md.md)] script contains memory-optimized versions of the Order and Customer tables, using hash indexes:</span></span>  
  
```sql  
CREATE TABLE dbo.[Customer] (  
  CustomerID nchar (5) NOT NULL PRIMARY KEY NONCLUSTERED,  
  ContactName nvarchar (30) NOT NULL   
) WITH (MEMORY_OPTIMIZED=ON)  
GO  
  
CREATE TABLE dbo.[Order] (  
  OrderID int NOT NULL PRIMARY KEY NONCLUSTERED,  
  CustomerID nchar (5) NOT NULL INDEX IX_CustomerID HASH(CustomerID) WITH (BUCKET_COUNT=100000),  
  OrderDate date NOT NULL INDEX IX_OrderDate HASH(OrderDate) WITH (BUCKET_COUNT=100000)  
) WITH (MEMORY_OPTIMIZED=ON)  
GO  
```  
  
 <span data-ttu-id="d4052-171">Si consideri la stessa query eseguita su tabelle ottimizzate per la memoria:</span><span class="sxs-lookup"><span data-stu-id="d4052-171">Consider the same query executed on memory-optimized tables:</span></span>  
  
```sql  
SELECT o.OrderID, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="d4052-172">Il piano stimato è il seguente:</span><span class="sxs-lookup"><span data-stu-id="d4052-172">The estimated plan is as follows:</span></span>  
  
 <span data-ttu-id="d4052-173">![Piano di query per il join di tabelle con ottimizzazione per la memoria.](../../database-engine/media/hekaton-query-plan-5.gif "Piano di query per il join di tabelle ottimizzate per la memoria.")</span><span class="sxs-lookup"><span data-stu-id="d4052-173">![Query plan for join of memory optimized tables.](../../database-engine/media/hekaton-query-plan-5.gif "Query plan for join of memory optimized tables.")</span></span>  
<span data-ttu-id="d4052-174">Piano di query per il join di tabelle ottimizzate per la memoria.</span><span class="sxs-lookup"><span data-stu-id="d4052-174">Query plan for join of memory-optimized tables.</span></span>  
  
 <span data-ttu-id="d4052-175">Osservare le seguenti differenze del piano per la stessa query su tabelle basate su disco (figura 1):</span><span class="sxs-lookup"><span data-stu-id="d4052-175">Observe the following differences with the plan for the same query on disk-based tables (figure 1):</span></span>  
  
-   <span data-ttu-id="d4052-176">Questo piano contiene un'analisi di tabella anziché un'analisi di indice cluster per la tabella Customer:</span><span class="sxs-lookup"><span data-stu-id="d4052-176">This plan contains a table scan rather than a clustered index scan for the table Customer:</span></span>  
  
    -   <span data-ttu-id="d4052-177">La definizione della tabella non include un indice cluster.</span><span class="sxs-lookup"><span data-stu-id="d4052-177">The definition of the table does not contain a clustered index.</span></span>  
  
    -   <span data-ttu-id="d4052-178">Gli indici cluster non sono supportati con le tabelle ottimizzate per la memoria.</span><span class="sxs-lookup"><span data-stu-id="d4052-178">Clustered indexes are not supported with memory-optimized tables.</span></span> <span data-ttu-id="d4052-179">Ogni tabella ottimizzata per la memoria deve invece disporre di almeno un indice non cluster e tutti gli indici delle tabelle ottimizzate per la memoria possono accedere in modo efficace a tutte le colonne della tabella senza che sia necessario archiviare tali colonne nell'indice o fare riferimento a un indice cluster.</span><span class="sxs-lookup"><span data-stu-id="d4052-179">Instead, every memory-optimized table must have at least one nonclustered index and all indexes on memory-optimized tables can efficiently access all columns in the table without having to store them in the index or refer to a clustered index.</span></span>  
  
-   <span data-ttu-id="d4052-180">Il piano contiene un `Hash Match` anziché un `Merge Join`.</span><span class="sxs-lookup"><span data-stu-id="d4052-180">This plan contains a `Hash Match` rather than a `Merge Join`.</span></span> <span data-ttu-id="d4052-181">Sia gli indici della tabella Order che quelli della tabella Customer sono indici hash, quindi non ordinati.</span><span class="sxs-lookup"><span data-stu-id="d4052-181">The indexes on both the Order and the Customer table are hash indexes, and are thus not ordered.</span></span> <span data-ttu-id="d4052-182">Un `Merge Join` richiederebbe un operatore di ordinamento, che ridurrebbe le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="d4052-182">A `Merge Join` would require sort operators that would decrease performance.</span></span>  
  
## <a name="natively-compiled-stored-procedures"></a><span data-ttu-id="d4052-183">stored procedure compilate in modo nativo</span><span class="sxs-lookup"><span data-stu-id="d4052-183">Natively Compiled Stored Procedures</span></span>  
 <span data-ttu-id="d4052-184">Le stored procedure compilate in modo nativo sono stored procedure [!INCLUDE[tsql](../../../includes/tsql-md.md)] compilate nel codice macchina, piuttosto che interpretate dal motore di esecuzione delle query.</span><span class="sxs-lookup"><span data-stu-id="d4052-184">Natively compiled stored procedures are [!INCLUDE[tsql](../../../includes/tsql-md.md)] stored procedures compiled to machine code, rather than interpreted by the query execution engine.</span></span> <span data-ttu-id="d4052-185">Lo script seguente crea una stored procedure compilata in modo nativo che esegue la query di esempio (della sezione Query di esempio).</span><span class="sxs-lookup"><span data-stu-id="d4052-185">The following script creates a natively compiled stored procedure that runs the example query (from the Example Query section).</span></span>  
  
```sql  
CREATE PROCEDURE usp_SampleJoin  
WITH NATIVE_COMPILATION, SCHEMABINDING, EXECUTE AS OWNER  
AS BEGIN ATOMIC WITH   
(  TRANSACTION ISOLATION LEVEL = SNAPSHOT,  
  LANGUAGE = 'english')  
  
  SELECT o.OrderID, c.CustomerID, c.ContactName   
FROM dbo.[Order] o INNER JOIN dbo.[Customer] c   
  ON c.CustomerID = o.CustomerID  
  
END  
```  
  
 <span data-ttu-id="d4052-186">Le stored procedure compilate in modo nativo vengono compilate al momento della creazione, mentre le stored procedure interpretate vengono compilate alla prima esecuzione</span><span class="sxs-lookup"><span data-stu-id="d4052-186">Natively compiled stored procedures are compiled at create time, whereas interpreted stored procedures are compiled at first execution time.</span></span> <span data-ttu-id="d4052-187">(una parte della compilazione, specificamente l'analisi e la normalizzazione, avviene al momento della creazione;</span><span class="sxs-lookup"><span data-stu-id="d4052-187">(A portion of the compilation, particularly parsing and algebrization, take place at create.</span></span> <span data-ttu-id="d4052-188">tuttavia, per le stored procedure interpretate, l'ottimizzazione dei piani di query ha luogo alla prima esecuzione). La logica di ricompilazione è simile.</span><span class="sxs-lookup"><span data-stu-id="d4052-188">However, for interpreted stored procedures, optimization of the query plans takes place at first execution.) The recompilation logic is similar.</span></span> <span data-ttu-id="d4052-189">Le stored procedure compilate in modo nativo vengono ricompilate alla prima esecuzione della procedura se il server viene riavviato.</span><span class="sxs-lookup"><span data-stu-id="d4052-189">Natively compiled stored procedures are recompiled on first execution of the procedure if the server is restarted.</span></span> <span data-ttu-id="d4052-190">Le stored procedure interpretate vengono ricompilate se il piano non si trova più nella cache dei piani.</span><span class="sxs-lookup"><span data-stu-id="d4052-190">Interpreted stored procedures are recompiled if the plan is no longer in the plan cache.</span></span> <span data-ttu-id="d4052-191">Nella tabella seguente vengono riepilogati i casi di compilazione e di ricompilazione per le stored procedure compilate in modo nativo e interpretate:</span><span class="sxs-lookup"><span data-stu-id="d4052-191">The following table summarizes compilation and recompilation cases for both natively compiled and interpreted stored procedures:</span></span>  
  
||<span data-ttu-id="d4052-192">Compilate in modo nativo</span><span class="sxs-lookup"><span data-stu-id="d4052-192">Natively compiled</span></span>|<span data-ttu-id="d4052-193">Accesso del codice</span><span class="sxs-lookup"><span data-stu-id="d4052-193">Interpreted</span></span>|  
|-|-----------------------|-----------------|  
|<span data-ttu-id="d4052-194">Compilazione iniziale</span><span class="sxs-lookup"><span data-stu-id="d4052-194">Initial compilation</span></span>|<span data-ttu-id="d4052-195">Al momento della creazione.</span><span class="sxs-lookup"><span data-stu-id="d4052-195">At create time.</span></span>|<span data-ttu-id="d4052-196">Alla prima esecuzione.</span><span class="sxs-lookup"><span data-stu-id="d4052-196">At first execution.</span></span>|  
|<span data-ttu-id="d4052-197">Ricompilazione automatica</span><span class="sxs-lookup"><span data-stu-id="d4052-197">Automatic recompilation</span></span>|<span data-ttu-id="d4052-198">Alla prima esecuzione della procedura dopo il riavvio del database o del server.</span><span class="sxs-lookup"><span data-stu-id="d4052-198">Upon first execution of the procedure after a database or server restart.</span></span>|<span data-ttu-id="d4052-199">Al riavvio del server.</span><span class="sxs-lookup"><span data-stu-id="d4052-199">On server restart.</span></span> <span data-ttu-id="d4052-200">In alternativa, eliminazione dalla cache dei piani, in genere in base alle modifiche di schema o di statistiche o a utilizzo elevato di memoria.</span><span class="sxs-lookup"><span data-stu-id="d4052-200">Or, eviction from the plan cache, usually based on schema or stats changes, or memory pressure.</span></span>|  
|<span data-ttu-id="d4052-201">Ricompilazione manuale</span><span class="sxs-lookup"><span data-stu-id="d4052-201">Manual recompilation</span></span>|<span data-ttu-id="d4052-202">Non supportata.</span><span class="sxs-lookup"><span data-stu-id="d4052-202">Not supported.</span></span> <span data-ttu-id="d4052-203">La soluzione alternativa consiste nell'eliminare e ricreare la stored procedure.</span><span class="sxs-lookup"><span data-stu-id="d4052-203">The workaround is to drop and recreate the stored procedure.</span></span>|<span data-ttu-id="d4052-204">Usare `sp_recompile`.</span><span class="sxs-lookup"><span data-stu-id="d4052-204">Use `sp_recompile`.</span></span> <span data-ttu-id="d4052-205">È possibile eliminare manualmente il piano dalla cache, ad esempio tramite DBCC FREEPROCCACHE.</span><span class="sxs-lookup"><span data-stu-id="d4052-205">You can manually evict the plan from the cache, for example through DBCC FREEPROCCACHE.</span></span> <span data-ttu-id="d4052-206">È inoltre possibile creare la stored procedure specificando WITH RECOMPILE affinché venga ricompilata a ogni esecuzione.</span><span class="sxs-lookup"><span data-stu-id="d4052-206">You can also create the stored procedure WITH RECOMPILE and the stored procedure will be recompiled at every execution.</span></span>|  
  
### <a name="compilation-and-query-processing"></a><span data-ttu-id="d4052-207">Compilazione ed elaborazione delle query</span><span class="sxs-lookup"><span data-stu-id="d4052-207">Compilation and Query Processing</span></span>  
 <span data-ttu-id="d4052-208">Nel diagramma seguente viene illustrato il processo di compilazione per le stored procedure compilate in modo nativo:</span><span class="sxs-lookup"><span data-stu-id="d4052-208">The following diagram illustrates the compilation process for natively compiled stored procedures:</span></span>  
  
 <span data-ttu-id="d4052-209">![Compilazione nativa delle stored procedure.](../../database-engine/media/hekaton-query-plan-6.gif "Compilazione nativa delle stored procedure.")</span><span class="sxs-lookup"><span data-stu-id="d4052-209">![Native compilation of stored procedures.](../../database-engine/media/hekaton-query-plan-6.gif "Native compilation of stored procedures.")</span></span>  
<span data-ttu-id="d4052-210">Compilazione nativa delle stored procedure.</span><span class="sxs-lookup"><span data-stu-id="d4052-210">Native compilation of stored procedures.</span></span>  
  
 <span data-ttu-id="d4052-211">Il processo è il seguente:</span><span class="sxs-lookup"><span data-stu-id="d4052-211">The process is described as,</span></span>  
  
1.  <span data-ttu-id="d4052-212">L'utente esegue un'istruzione `CREATE PROCEDURE` in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="d4052-212">The user issues a `CREATE PROCEDURE` statement to [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span>  
  
2.  <span data-ttu-id="d4052-213">Il parser e il normalizzatore creano il flusso di elaborazione per la stored procedure, oltre ad alberi per le query [!INCLUDE[tsql](../../../includes/tsql-md.md)] nella stored procedure.</span><span class="sxs-lookup"><span data-stu-id="d4052-213">The parser and algebrizer create the processing flow for the procedure, as well as query trees for the [!INCLUDE[tsql](../../../includes/tsql-md.md)] queries in the stored procedure.</span></span>  
  
3.  <span data-ttu-id="d4052-214">Query Optimizer crea piani di esecuzione ottimizzati per tutte le query nella stored procedure.</span><span class="sxs-lookup"><span data-stu-id="d4052-214">The optimizer creates optimized query execution plans for all the queries in the stored procedure.</span></span>  
  
4.  <span data-ttu-id="d4052-215">Il compilatore di OLTP in memoria acquisisce il flusso di elaborazione con i piani di query ottimizzati incorporati e genera una DLL contenente il codice macchina per l'esecuzione della stored procedure.</span><span class="sxs-lookup"><span data-stu-id="d4052-215">The In-Memory OLTP compiler takes the processing flow with the embedded optimized query plans and generates a DLL that contains the machine code for executing the stored procedure.</span></span>  
  
5.  <span data-ttu-id="d4052-216">La DLL generata viene caricata in memoria.</span><span class="sxs-lookup"><span data-stu-id="d4052-216">The generated DLL is loaded into memory.</span></span>  
  
 <span data-ttu-id="d4052-217">La chiamata di una stored procedure compilata in modo nativo viene convertita in chiamata a una funzione nella DLL.</span><span class="sxs-lookup"><span data-stu-id="d4052-217">Invocation of a natively compiled stored procedure translates to calling a function in the DLL.</span></span>  
  
 <span data-ttu-id="d4052-218">![Esecuzione di stored procedure compilate in modo nativo.](../../database-engine/media/hekaton-query-plan-7.gif "Esecuzione di stored procedure compilate in modo nativo.")</span><span class="sxs-lookup"><span data-stu-id="d4052-218">![Execution of natively compiled stored procedures.](../../database-engine/media/hekaton-query-plan-7.gif "Execution of natively compiled stored procedures.")</span></span>  
<span data-ttu-id="d4052-219">Esecuzione di stored procedure compilate in modo nativo.</span><span class="sxs-lookup"><span data-stu-id="d4052-219">Execution of natively compiled stored procedures.</span></span>  
  
 <span data-ttu-id="d4052-220">La chiamata di una stored procedure compilata in modo nativo viene descritta nel modo riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="d4052-220">Invocation of a natively compiled stored procedure is described as follows:</span></span>  
  
1.  <span data-ttu-id="d4052-221">L'utente rilascia un' `EXEC` istruzione *usp_myproc* .</span><span class="sxs-lookup"><span data-stu-id="d4052-221">The user issues an `EXEC`*usp_myproc* statement.</span></span>  
  
2.  <span data-ttu-id="d4052-222">Il parser estrae il nome e i parametri della stored procedure.</span><span class="sxs-lookup"><span data-stu-id="d4052-222">The parser extracts the name and stored procedure parameters.</span></span>  
  
     <span data-ttu-id="d4052-223">Se l'istruzione è stata preparata, ad esempio utilizzando `sp_prep_exec`, il parser non deve estrarre il nome e i parametri della stored procedure in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="d4052-223">If the statement was prepared, for example using `sp_prep_exec`, the parser does not need to extract the procedure name and parameters at execution time.</span></span>  
  
3.  <span data-ttu-id="d4052-224">Il runtime di OLTP in memoria individua il punto di ingresso della DLL per la stored procedure.</span><span class="sxs-lookup"><span data-stu-id="d4052-224">The In-Memory OLTP runtime locates the DLL entry point for the stored procedure.</span></span>  
  
4.  <span data-ttu-id="d4052-225">Viene eseguito il codice della macchina nella DLL e i risultati vengono restituiti al client.</span><span class="sxs-lookup"><span data-stu-id="d4052-225">The machine code in the DLL is executed and the results of are returned to the client.</span></span>  
  
 <span data-ttu-id="d4052-226">**Sniffing dei parametri**</span><span class="sxs-lookup"><span data-stu-id="d4052-226">**Parameter sniffing**</span></span>  
  
 <span data-ttu-id="d4052-227">Le stored procedure [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretate vengono compilate alla prima esecuzione, contrariamente alle stored procedure compilate in modo nativo che vengono compilate al momento della creazione.</span><span class="sxs-lookup"><span data-stu-id="d4052-227">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] stored procedures are compiled at first execution, in contrast to natively compiled stored procedures, which are compiled at create time.</span></span> <span data-ttu-id="d4052-228">Quando le stored procedure interpretate vengono compilate al momento della chiamata, i valori dei parametri forniti per la chiamata vengono utilizzati da Query Optimizer durante la generazione del piano di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="d4052-228">When interpreted stored procedures are compiled at invocation, the values of the parameters supplied for this invocation are used by the optimizer when generating the execution plan.</span></span> <span data-ttu-id="d4052-229">Questo utilizzo dei parametri durante la compilazione viene chiamato sniffing dei parametri.</span><span class="sxs-lookup"><span data-stu-id="d4052-229">This use of parameters during compilation is called parameter sniffing.</span></span>  
  
 <span data-ttu-id="d4052-230">Lo sniffing dei parametri non viene utilizzato per la compilazione delle stored procedure compilate in modo nativo.</span><span class="sxs-lookup"><span data-stu-id="d4052-230">Parameter sniffing is not used for compiling natively compiled stored procedures.</span></span> <span data-ttu-id="d4052-231">Tutti i parametri della stored procedure vengono considerati con valore UNKNOWN.</span><span class="sxs-lookup"><span data-stu-id="d4052-231">All parameters to the stored procedure are considered to have UNKNOWN values.</span></span> <span data-ttu-id="d4052-232">Analogamente alle stored procedure interpretate, anche le stored procedure compilate in modo nativo supportano l'hint `OPTIMIZE FOR`.</span><span class="sxs-lookup"><span data-stu-id="d4052-232">Like interpreted stored procedures, natively compiled stored procedures also support the `OPTIMIZE FOR` hint.</span></span> <span data-ttu-id="d4052-233">Per altre informazioni, vedere [Hint per la query &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-query).</span><span class="sxs-lookup"><span data-stu-id="d4052-233">For more information, see [Query Hints &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-query).</span></span>  
  
### <a name="retrieving-a-query-execution-plan-for-natively-compiled-stored-procedures"></a><span data-ttu-id="d4052-234">Recupero di un piano di esecuzione di query per le stored procedure compilate in modo nativo</span><span class="sxs-lookup"><span data-stu-id="d4052-234">Retrieving a Query Execution Plan for Natively Compiled Stored Procedures</span></span>  
 <span data-ttu-id="d4052-235">Il piano di esecuzione di query per una stored procedure compilata in modo nativo può essere recuperato usando **Piano di esecuzione stimato** in [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)]o tramite l'opzione SHOWPLAN_XML in [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="d4052-235">The query execution plan for a natively compiled stored procedure can be retrieved using **Estimated Execution Plan** in [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)], or using the SHOWPLAN_XML option in [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="d4052-236">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="d4052-236">For example:</span></span>  
  
```sql  
SET SHOWPLAN_XML ON  
GO  
EXEC dbo.usp_myproc  
GO  
SET SHOWPLAN_XML OFF  
GO  
```  
  
 <span data-ttu-id="d4052-237">Il piano di esecuzione generato da Query Optimizer consiste in un albero con gli operatori di query sui nodi e sulle foglie.</span><span class="sxs-lookup"><span data-stu-id="d4052-237">The execution plan generated by the query optimizer consists of a tree with query operators on the nodes and leaves of the tree.</span></span> <span data-ttu-id="d4052-238">La struttura dell'albero determina l'interazione (il flusso di righe da un operatore a un altro) tra operatori.</span><span class="sxs-lookup"><span data-stu-id="d4052-238">The structure of the tree determines the interaction (the flow of rows from one operator to another) between the operators.</span></span> <span data-ttu-id="d4052-239">Nella visualizzazione grafica di [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)], la direzione del flusso è da destra a sinistra.</span><span class="sxs-lookup"><span data-stu-id="d4052-239">In the graphical view of [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)], the flow is from right to left.</span></span> <span data-ttu-id="d4052-240">Ad esempio, il piano di query nella figura 1 contiene due operatori Index Scan che forniscono le righe a un operatore Merge Join.</span><span class="sxs-lookup"><span data-stu-id="d4052-240">For example, the query plan in figure 1 contains two index scan operators, which supplies rows to a merge join operator.</span></span> <span data-ttu-id="d4052-241">L'operatore Merge Join fornisce le righe a un operatore Select.</span><span class="sxs-lookup"><span data-stu-id="d4052-241">The merge join operator supplies rows to a select operator.</span></span> <span data-ttu-id="d4052-242">L'operatore Select, infine, restituisce le righe al client.</span><span class="sxs-lookup"><span data-stu-id="d4052-242">The select operator, finally, returns the rows to the client.</span></span>  
  
### <a name="query-operators-in-natively-compiled-stored-procedures"></a><span data-ttu-id="d4052-243">Operatori di query nelle stored procedure compilate in modo nativo</span><span class="sxs-lookup"><span data-stu-id="d4052-243">Query Operators in Natively Compiled Stored Procedures</span></span>  
 <span data-ttu-id="d4052-244">Nella tabella seguente vengono riepilogati gli operatori di query supportati nelle stored procedure compilate in modo nativo:</span><span class="sxs-lookup"><span data-stu-id="d4052-244">The following table summarizes the query operators supported inside natively compiled stored procedures:</span></span>  
  
|<span data-ttu-id="d4052-245">Operatore</span><span class="sxs-lookup"><span data-stu-id="d4052-245">Operator</span></span>|<span data-ttu-id="d4052-246">Query di esempio</span><span class="sxs-lookup"><span data-stu-id="d4052-246">Sample query</span></span>|  
|--------------|------------------|  
|<span data-ttu-id="d4052-247">SELECT</span><span class="sxs-lookup"><span data-stu-id="d4052-247">SELECT</span></span>|`SELECT OrderID FROM dbo.[Order]`|  
|<span data-ttu-id="d4052-248">INSERT</span><span class="sxs-lookup"><span data-stu-id="d4052-248">INSERT</span></span>|`INSERT dbo.Customer VALUES ('abc', 'def')`|  
|<span data-ttu-id="d4052-249">UPDATE</span><span class="sxs-lookup"><span data-stu-id="d4052-249">UPDATE</span></span>|`UPDATE dbo.Customer SET ContactName='ghi' WHERE CustomerID='abc'`|  
|<span data-ttu-id="d4052-250">DELETE</span><span class="sxs-lookup"><span data-stu-id="d4052-250">DELETE</span></span>|`DELETE dbo.Customer WHERE CustomerID='abc'`|  
|<span data-ttu-id="d4052-251">Compute Scalar</span><span class="sxs-lookup"><span data-stu-id="d4052-251">Compute Scalar</span></span>|<span data-ttu-id="d4052-252">Questo operatore viene utilizzato sia per le funzioni intrinseche che per le conversioni dei tipi.</span><span class="sxs-lookup"><span data-stu-id="d4052-252">This operator is used both for intrinsic functions and type conversions.</span></span> <span data-ttu-id="d4052-253">Non tutte le funzioni e conversioni dei tipi sono supportate nelle stored procedure compilate in modo nativo.</span><span class="sxs-lookup"><span data-stu-id="d4052-253">Not all functions and type conversions are supported inside natively compiled stored procedures.</span></span><br /><br /> `SELECT OrderID+1 FROM dbo.[Order]`|  
|<span data-ttu-id="d4052-254">Join a cicli annidati</span><span class="sxs-lookup"><span data-stu-id="d4052-254">Nested Loops Join</span></span>|<span data-ttu-id="d4052-255">Nested Loops è l'unico operatore di join supportato nelle stored procedure compilate in modo nativo.</span><span class="sxs-lookup"><span data-stu-id="d4052-255">Nested Loops is the only join operator supported in natively compiled stored procedures.</span></span> <span data-ttu-id="d4052-256">In tutti i piani che contengono join viene utilizzato l'operatore Nested Loops, anche se il piano per la stessa query eseguita come codice [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretato contiene un hash join o un merge join.</span><span class="sxs-lookup"><span data-stu-id="d4052-256">All plans that contain joins will use the Nested Loops operator, even if the plan for same query executed as interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] contains a hash or merge join.</span></span><br /><br /> `SELECT o.OrderID, c.CustomerID`  <br /> `FROM dbo.[Order] o INNER JOIN dbo.[Customer] c`|  
|<span data-ttu-id="d4052-257">Ordina</span><span class="sxs-lookup"><span data-stu-id="d4052-257">Sort</span></span>|`SELECT ContactName FROM dbo.Customer`  <br /> `ORDER BY ContactName`|  
|<span data-ttu-id="d4052-258">TOP</span><span class="sxs-lookup"><span data-stu-id="d4052-258">Top</span></span>|`SELECT TOP 10 ContactName FROM dbo.Customer`|  
|<span data-ttu-id="d4052-259">Top-sort</span><span class="sxs-lookup"><span data-stu-id="d4052-259">Top-sort</span></span>|<span data-ttu-id="d4052-260">L'espressione `TOP` (il numero di righe da restituire) non può superare le 8.000 righe.</span><span class="sxs-lookup"><span data-stu-id="d4052-260">The `TOP` expression (the number of rows to be returned) cannot exceed 8,000 rows.</span></span> <span data-ttu-id="d4052-261">Meno se nella query sono presenti anche operatori di aggregazione e di join.</span><span class="sxs-lookup"><span data-stu-id="d4052-261">Fewer if there are also join and aggregation operators in the query.</span></span> <span data-ttu-id="d4052-262">I join e le aggregazioni in genere riducono il numero di righe da ordinare, rispetto al numero di righe delle tabelle di base.</span><span class="sxs-lookup"><span data-stu-id="d4052-262">Joins and aggregation do typically reduce the number of rows to be sorted, compared with the row count of the base tables.</span></span><br /><br /> `SELECT TOP 10 ContactName FROM dbo.Customer`  <br /> `ORDER BY ContactName`|  
|<span data-ttu-id="d4052-263">Stream Aggregate</span><span class="sxs-lookup"><span data-stu-id="d4052-263">Stream Aggregate</span></span>|<span data-ttu-id="d4052-264">Si noti che l'operatore Hash Match non è supportato per l'aggregazione.</span><span class="sxs-lookup"><span data-stu-id="d4052-264">Note that the Hash Match operator is not supported for aggregation.</span></span> <span data-ttu-id="d4052-265">Pertanto, in tutte le aggregazioni nelle stored procedure compilate in modo nativo viene utilizzato l'operatore Stream Aggregate, anche se il piano per la stessa query nel codice [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretato utilizza l'operatore Hash Match.</span><span class="sxs-lookup"><span data-stu-id="d4052-265">Therefore, all aggregation in natively compiled stored procedures uses the Stream Aggregate operator, even if the plan for the same query in interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] uses the Hash Match operator.</span></span><br /><br /> `SELECT count(CustomerID) FROM dbo.Customer`|  
  
## <a name="column-statistics-and-joins"></a><span data-ttu-id="d4052-266">Statistiche di colonna e join</span><span class="sxs-lookup"><span data-stu-id="d4052-266">Column Statistics and Joins</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="d4052-267">mantiene statistiche sui valori nelle colonne chiave di indice per facilitare la stima del costo di determinate operazioni, quali l'analisi e le ricerche sugli indici.</span><span class="sxs-lookup"><span data-stu-id="d4052-267">maintains statistics on values in index key columns to help estimate the cost of certain operations, such as index scan and index seeks.</span></span> <span data-ttu-id="d4052-268">Con [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] è anche possibile creare statistiche sulle colonne chiave non di indice, se create in modo esplicito dall'utente o create da Query Optimizer in risposta a una query con un predicato. La principale metrica nella stima dei costi è il numero di righe elaborate da un singolo operatore.</span><span class="sxs-lookup"><span data-stu-id="d4052-268">( [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] also creates statistics on non-index key columns if you explicitly create them or if the query optimizer creates them in response to a query with a predicate.) The main metric in cost estimation is the number of rows processed by a single operator.</span></span> <span data-ttu-id="d4052-269">Si noti che, per le tabelle basate su disco, il numero di pagine a cui accede un operatore specifico è significativo nella stima dei costi.</span><span class="sxs-lookup"><span data-stu-id="d4052-269">Note that for disk-based tables, the number of pages accessed by a particular operator is significant in cost estimation.</span></span> <span data-ttu-id="d4052-270">Tuttavia, poiché il conteggio delle pagine non è importante per le tabelle ottimizzate per la memoria (è sempre zero), questa descrizione è incentrata sul conteggio delle righe.</span><span class="sxs-lookup"><span data-stu-id="d4052-270">However, as page count is not important for memory-optimized tables (it is always zero), this discussion focuses on row count.</span></span> <span data-ttu-id="d4052-271">La stima inizia con gli operatori Index Seek e Index Scan nel piano e viene quindi estesa agli altri operatori, quale l'operatore di join.</span><span class="sxs-lookup"><span data-stu-id="d4052-271">The estimation starts with the index seek and scan operators in the plan, and is then extended to include the other operators, like the join operator.</span></span> <span data-ttu-id="d4052-272">Il numero stimato di righe da elaborare da parte di un operatore di join è basato sulla stima per gli operatori Index Seek e Index Scan sottostanti.</span><span class="sxs-lookup"><span data-stu-id="d4052-272">The estimated number of rows to be processed by a join operator is based on the estimation for the underlying index, seek, and scan operators.</span></span> <span data-ttu-id="d4052-273">Per l'accesso del codice [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretato alle tabelle ottimizzate per la memoria, è possibile osservare il piano di esecuzione effettivo per vedere la differenza tra il numero di righe stimato ed effettivo per gli operatori nel piano.</span><span class="sxs-lookup"><span data-stu-id="d4052-273">For interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access to memory-optimized tables, you can observe the actual execution plan to see the difference between the estimated and actual row counts for the operators in the plan.</span></span>  
  
 <span data-ttu-id="d4052-274">Per l'esempio nella figura 1:</span><span class="sxs-lookup"><span data-stu-id="d4052-274">For the example in figure 1,</span></span>  
  
-   <span data-ttu-id="d4052-275">L'operatore Clustered Index Scan su Customer presenta un valore stimato di 91 ed effettivo di 91.</span><span class="sxs-lookup"><span data-stu-id="d4052-275">The clustered index scan on Customer has estimated 91; actual 91.</span></span>  
  
-   <span data-ttu-id="d4052-276">L'operatore Nonclustered Index Scan su CustomerID presenta un valore stimato di 830 ed effettivo di 830.</span><span class="sxs-lookup"><span data-stu-id="d4052-276">The nonclustered index scan on CustomerID has estimated 830; actual 830.</span></span>  
  
-   <span data-ttu-id="d4052-277">L'operatore Merge Join presenta un valore stimato di 815 ed effettivo di 830.</span><span class="sxs-lookup"><span data-stu-id="d4052-277">The Merge Join operator has estimated 815; actual 830.</span></span>  
  
 <span data-ttu-id="d4052-278">Le stime per le analisi di indice sono accurate.</span><span class="sxs-lookup"><span data-stu-id="d4052-278">The estimates for the index scans are accurate.</span></span> [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="d4052-279">mantiene il conteggio delle righe per le tabelle basate su disco.</span><span class="sxs-lookup"><span data-stu-id="d4052-279">maintains the row count for disk-based tables.</span></span> <span data-ttu-id="d4052-280">Le stime per le analisi complete di tabelle e indici sono sempre accurate.</span><span class="sxs-lookup"><span data-stu-id="d4052-280">Estimates for full table and index scans are always accurate.</span></span> <span data-ttu-id="d4052-281">Anche la stima per il join è ragionevolmente accurata.</span><span class="sxs-lookup"><span data-stu-id="d4052-281">The estimate for the join is fairly accurate, too.</span></span>  
  
 <span data-ttu-id="d4052-282">Se le stime cambiano, cambiano anche le considerazioni sui costi per le diverse alternative di piano.</span><span class="sxs-lookup"><span data-stu-id="d4052-282">If these estimates change, the cost considerations for different plan alternatives change as well.</span></span> <span data-ttu-id="d4052-283">Ad esempio, se uno dei lati del join presenta un conteggio stimato di una o solo poche righe, l'uso di join a cicli annidati è meno costoso.</span><span class="sxs-lookup"><span data-stu-id="d4052-283">For example, if one of the sides of the join has an estimated row count of 1 or just a few rows, using a nested loops joins is less expensive.</span></span>  
  
 <span data-ttu-id="d4052-284">Di seguito è riportato il piano della query:</span><span class="sxs-lookup"><span data-stu-id="d4052-284">The following is the plan for the query:</span></span>  
  
```  
SELECT o.OrderID, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="d4052-285">Dopo aver eliminato tutte le righe tranne una nella tabella Customer:</span><span class="sxs-lookup"><span data-stu-id="d4052-285">After deleting all rows but one in the table Customer:</span></span>  
  
 <span data-ttu-id="d4052-286">![Statistiche di colonna e join.](../../database-engine/media/hekaton-query-plan-9.gif "Statistiche di colonna e join.")</span><span class="sxs-lookup"><span data-stu-id="d4052-286">![Column statistics and joins.](../../database-engine/media/hekaton-query-plan-9.gif "Column statistics and joins.")</span></span>  
  
 <span data-ttu-id="d4052-287">Rispetto a questo piano di query:</span><span class="sxs-lookup"><span data-stu-id="d4052-287">Regarding this query plan:</span></span>  
  
-   <span data-ttu-id="d4052-288">L'operatore Hash Match è stato sostituito con un operatore fisico di join a cicli annidati.</span><span class="sxs-lookup"><span data-stu-id="d4052-288">The Hash Match has been replaced with a Nested Loops physical join operator.</span></span>  
  
-   <span data-ttu-id="d4052-289">L'analisi completa dell'indice su IX_CustomerID è stata sostituita con una ricerca nell'indice.</span><span class="sxs-lookup"><span data-stu-id="d4052-289">The full index scan on IX_CustomerID has been replaced with an index seek.</span></span> <span data-ttu-id="d4052-290">In questo modo sono state analizzate 5 righe, anziché le 830 righe richieste per l'analisi completa dell'indice.</span><span class="sxs-lookup"><span data-stu-id="d4052-290">This resulted in scanning 5 rows, instead of the 830 rows required for the full index scan.</span></span>  
  
### <a name="statistics-and-cardinality-for-memory-optimized-tables"></a><span data-ttu-id="d4052-291">Statistiche e cardinalità per le tabelle con ottimizzazione per la memoria</span><span class="sxs-lookup"><span data-stu-id="d4052-291">Statistics and Cardinality for Memory-Optimized Tables</span></span>  
 <span data-ttu-id="d4052-292">In [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] vengono mantenute statistiche a livello di colonna per le tabelle ottimizzate per la memoria.</span><span class="sxs-lookup"><span data-stu-id="d4052-292">[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] maintains column-level statistics for memory-optimized tables.</span></span> <span data-ttu-id="d4052-293">Inoltre, viene mantenuto il conteggio effettivo delle righe della tabella.</span><span class="sxs-lookup"><span data-stu-id="d4052-293">In addition, it maintains the actual row count of the table.</span></span> <span data-ttu-id="d4052-294">Tuttavia, diversamente dalle tabelle basate su disco, le statistiche per le tabelle ottimizzate per la memoria non vengono aggiornate automaticamente.</span><span class="sxs-lookup"><span data-stu-id="d4052-294">However, in contrast to disk-based tables, the statistics for memory-optimized tables are not automatically updated.</span></span> <span data-ttu-id="d4052-295">Pertanto, le statistiche devono essere aggiornate manualmente dopo aver effettuato modifiche significative nelle tabelle.</span><span class="sxs-lookup"><span data-stu-id="d4052-295">Therefore, statistics need to be manually updated after significant changes in the tables.</span></span> <span data-ttu-id="d4052-296">Per altre informazioni, vedere [Statistiche per tabelle con ottimizzazione per la memoria](memory-optimized-tables.md).</span><span class="sxs-lookup"><span data-stu-id="d4052-296">For more information, see [Statistics for Memory-Optimized Tables](memory-optimized-tables.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d4052-297">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="d4052-297">See Also</span></span>  
 [<span data-ttu-id="d4052-298">Tabelle ottimizzate per la memoria</span><span class="sxs-lookup"><span data-stu-id="d4052-298">Memory-Optimized Tables</span></span>](memory-optimized-tables.md)  
  
  
