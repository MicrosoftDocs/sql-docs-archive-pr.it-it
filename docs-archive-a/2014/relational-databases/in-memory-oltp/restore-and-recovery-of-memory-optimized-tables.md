---
title: Ripristinare e recuperare tabelle con ottimizzazione per la memoria | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 294975b7-e7d1-491b-b66a-fdb1100d2acc
author: CarlRabeler
ms.author: carlrab
ms.openlocfilehash: 5e702798ea68745a038407fb65af7726a5c5d50e
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/04/2020
ms.locfileid: "87635584"
---
# <a name="restore-and-recovery-of-memory-optimized-tables"></a><span data-ttu-id="c0e75-102">Ripristinare e recuperare tabelle con ottimizzazione per la memoria</span><span class="sxs-lookup"><span data-stu-id="c0e75-102">Restore and Recovery of Memory-Optimized Tables</span></span>
  <span data-ttu-id="c0e75-103">Il meccanismo di base per recuperare o ripristinare un database con tabelle ottimizzate per la memoria è simile a quello per i database che hanno solo tabelle basate su disco.</span><span class="sxs-lookup"><span data-stu-id="c0e75-103">The basic mechanism to recover or restore a database with memory-optimized tables is similar to databases with only disk-based tables.</span></span> <span data-ttu-id="c0e75-104">A differenza delle tabelle basate su disco, le tabelle ottimizzate per la memoria devono essere caricate in memoria prima di rendere disponibile il database per l'accesso utente.</span><span class="sxs-lookup"><span data-stu-id="c0e75-104">But unlike disk-based tables, memory-optimized tables must be loaded into memory before database is available for user access.</span></span> <span data-ttu-id="c0e75-105">Si tratta di un nuovo passaggio nel processo di recupero del database.</span><span class="sxs-lookup"><span data-stu-id="c0e75-105">This adds a new step in the database recovery.</span></span> <span data-ttu-id="c0e75-106">I passaggi modificati per il recupero del database sono cambiati come indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="c0e75-106">The modified steps in database recovery are changed as follows:</span></span>

 <span data-ttu-id="c0e75-107">Al riavvio di [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] , ogni database attraversa una fase di recupero suddivisa in tre parti:</span><span class="sxs-lookup"><span data-stu-id="c0e75-107">When the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] restarts, each database goes through a recovery phase that consists of the following three phases:</span></span>

1.  <span data-ttu-id="c0e75-108">Fase di analisi.</span><span class="sxs-lookup"><span data-stu-id="c0e75-108">The analysis phase.</span></span> <span data-ttu-id="c0e75-109">Durante questa fase, viene eseguito un passaggio nei log delle transazioni attivi per rilevare le transazioni di cui è stato eseguito il commit e di cui non è stato eseguito il commit.</span><span class="sxs-lookup"><span data-stu-id="c0e75-109">During this phase, a pass is made on the active transaction logs to detect committed and uncommitted transactions.</span></span> <span data-ttu-id="c0e75-110">Il motore OLTP in memoria identifica il checkpoint per caricare e precaricare le voci di log della tabella di sistema.</span><span class="sxs-lookup"><span data-stu-id="c0e75-110">The In-Memory OLTP engine identifies the checkpoint to load and preloads its system table log entries.</span></span> <span data-ttu-id="c0e75-111">Elabora inoltre alcuni record di log delle allocazioni di file.</span><span class="sxs-lookup"><span data-stu-id="c0e75-111">It will also process some file allocation log records.</span></span>

2.  <span data-ttu-id="c0e75-112">Fase di rollforward.</span><span class="sxs-lookup"><span data-stu-id="c0e75-112">The redo phase.</span></span> <span data-ttu-id="c0e75-113">Questa fase viene eseguita contemporaneamente sia nelle tabelle basate su disco sia in quelle ottimizzate per la memoria.</span><span class="sxs-lookup"><span data-stu-id="c0e75-113">This phase is run concurrently on both disk-based and memory-optimized tables.</span></span>

     <span data-ttu-id="c0e75-114">Per le tabelle basate su disco, il database viene spostato al momento corrente e acquisisce i blocchi utilizzati dalle transazioni di cui non è stato eseguito il commit.</span><span class="sxs-lookup"><span data-stu-id="c0e75-114">For disk-based tables, the database is moved to the current point in time and acquires locks taken by uncommitted transactions.</span></span>

     <span data-ttu-id="c0e75-115">Per le tabelle ottimizzate per la memoria, i dati dalle coppie di file di dati e differenziali vengono caricati in memoria e aggiornati con il log delle transazioni attivo basato sull'ultimo checkpoint durevole.</span><span class="sxs-lookup"><span data-stu-id="c0e75-115">For memory-optimized tables, data from the data and delta file pairs are loaded into memory and then update the data with the active transaction log based on the last durable checkpoint.</span></span>

     <span data-ttu-id="c0e75-116">Quando vengono completate le operazioni riportate sopra per le tabelle basate su disco e le tabelle ottimizzate per la memoria, il database è disponibile per l'accesso.</span><span class="sxs-lookup"><span data-stu-id="c0e75-116">When the above operations on disk-based and memory-optimized tables are complete, the database is available for access.</span></span>

3.  <span data-ttu-id="c0e75-117">Fase di rollback.</span><span class="sxs-lookup"><span data-stu-id="c0e75-117">The undo phase.</span></span> <span data-ttu-id="c0e75-118">In questa fase, viene effettuato il rollback delle transazioni di cui non è stato eseguito il commit.</span><span class="sxs-lookup"><span data-stu-id="c0e75-118">In this phase, the uncommitted transactions are rolled back.</span></span>

 <span data-ttu-id="c0e75-119">Il caricamento delle tabelle ottimizzate per la memoria può influire sul tempo necessario per il pieno recupero dell'operatività (RTO, Recovery Time Objective).</span><span class="sxs-lookup"><span data-stu-id="c0e75-119">Loading memory-optimized tables into memory can affect performance of the recovery time objective (RTO).</span></span> <span data-ttu-id="c0e75-120">Per migliorare il tempo di caricamento dei dati ottimizzati per la memoria dai file di dati e differenziali, il motore OLTP in memoria carica i file di dati e differenziali in parallelo nel modo seguente:</span><span class="sxs-lookup"><span data-stu-id="c0e75-120">To improve the load time of memory-optimized data from data and delta files, the In-Memory OLTP engine loads the data/delta files in parallel as follows:</span></span>

-   <span data-ttu-id="c0e75-121">Creazione di un filtro mappa differenziale.</span><span class="sxs-lookup"><span data-stu-id="c0e75-121">Creating a Delta Map Filter.</span></span> <span data-ttu-id="c0e75-122">I file differenziali archiviano i riferimenti alle righe eliminate.</span><span class="sxs-lookup"><span data-stu-id="c0e75-122">Delta files store references to the deleted rows.</span></span> <span data-ttu-id="c0e75-123">Un thread per contenitore legge i file differenziali e crea un filtro mappa differenziale.</span><span class="sxs-lookup"><span data-stu-id="c0e75-123">One thread per container reads the delta files and creates a delta map filter.</span></span> <span data-ttu-id="c0e75-124">In un filegroup di dati con ottimizzazione per la memoria possono essere presenti più contenitori.</span><span class="sxs-lookup"><span data-stu-id="c0e75-124">(A memory optimized data filegroup can have one or more containers.)</span></span>

-   <span data-ttu-id="c0e75-125">Flusso dei file di dati.</span><span class="sxs-lookup"><span data-stu-id="c0e75-125">Streaming the data files.</span></span>  <span data-ttu-id="c0e75-126">Alla creazione del filtro mappa differenziale, i file di dati vengono letti utilizzando un numero di thread equivalente al numero di CPU logiche.</span><span class="sxs-lookup"><span data-stu-id="c0e75-126">Once the delta-map filter is created, data files are read using as many threads as there are logical CPUs.</span></span> <span data-ttu-id="c0e75-127">Ogni thread che legge il file di dati legge le righe di dati, controlla la mappa differenziale associata e inserisce la riga nella tabella solo se tale riga non è stata contrassegnata come eliminata.</span><span class="sxs-lookup"><span data-stu-id="c0e75-127">Each thread reading the data file reads the data rows, checks the associated delta map and only inserts the row into table if this row has not been marked deleted.</span></span> <span data-ttu-id="c0e75-128">Questa parte del recupero può essere associata alla CPU in alcuni casi riportati di seguito.</span><span class="sxs-lookup"><span data-stu-id="c0e75-128">This part of recovery can be CPU bound in some cases as noted below.</span></span>

 <span data-ttu-id="c0e75-129">![Tabelle con ottimizzazione per la memoria.](../../database-engine/media/memory-optimized-tables.gif "Tabelle ottimizzate per la memoria.")</span><span class="sxs-lookup"><span data-stu-id="c0e75-129">![Memory-optimized tables.](../../database-engine/media/memory-optimized-tables.gif "Memory-optimized tables.")</span></span>

 <span data-ttu-id="c0e75-130">Le tabelle con ottimizzazione per la memoria possono in genere essere caricate in memoria alla velocità di I/O, ma in alcuni casi il caricamento delle righe di dati in memoria è più lento.</span><span class="sxs-lookup"><span data-stu-id="c0e75-130">Memory-optimized tables can generally be loaded into memory at the speed of I/O but there are cases when loading data rows into memory will be slower.</span></span> <span data-ttu-id="c0e75-131">Alcuni casi specifici sono i seguenti:</span><span class="sxs-lookup"><span data-stu-id="c0e75-131">Specific cases are:</span></span>

-   <span data-ttu-id="c0e75-132">Un numero di bucket basso per l'indice hash può portare a conflitti eccessivi rallentando gli inserimenti delle righe di dati.</span><span class="sxs-lookup"><span data-stu-id="c0e75-132">Low bucket count for hash index can lead to excessive collision causing data row inserts to be slower.</span></span> <span data-ttu-id="c0e75-133">Ciò comporta in genere un utilizzo elevato della CPU per l'intero processo, in particolare verso la fine del recupero.</span><span class="sxs-lookup"><span data-stu-id="c0e75-133">This generally results in very high CPU utilization throughout, and especially towards the end of recovery.</span></span> <span data-ttu-id="c0e75-134">Se l'indice hash è stato configurato correttamente, non dovrebbe influire sul tempo di recupero.</span><span class="sxs-lookup"><span data-stu-id="c0e75-134">If you configured the hash index correctly, it should not impact the recovery time.</span></span>

-   <span data-ttu-id="c0e75-135">L'utilizzo della CPU può risultare elevato per le tabelle ottimizzate per la memoria di grandi dimensioni con uno o più indici non cluster in quanto, a differenza di un indice hash in cui il numero di bucket è stabilito al momento della creazione, gli indici non cluster aumentano in modo dinamico.</span><span class="sxs-lookup"><span data-stu-id="c0e75-135">Large memory-optimized tables with one or more nonclustered indexes, unlike a hash index whose bucket count is sized at create time, the nonclustered indexes grow dynamically, resulting in high CPU utilization.</span></span>

## <a name="restoring-a-database-with-memory-optimized-tables"></a><span data-ttu-id="c0e75-136">Ripristino di un database con tabelle con ottimizzazione per la memoria</span><span class="sxs-lookup"><span data-stu-id="c0e75-136">Restoring a Database with Memory-optimized tables</span></span>
 <span data-ttu-id="c0e75-137">Si sa che è disponibile memoria sufficiente nel server per ripristinare un database, ma è necessario che la memoria richiesta dal database venga calcolata come parte di un pool di risorse esistente.</span><span class="sxs-lookup"><span data-stu-id="c0e75-137">You know that you have sufficient memory on the server to restore a database, but there's a requirement  that the memory needed by the database is accounted for as part of an existing Resource Pool.</span></span>  <span data-ttu-id="c0e75-138">Si sa che non è possibile creare l'associazione al pool di risorse prima che il database sia disponibile, quindi si esegue il ripristino con l'opzione RESTORE WITH RECOVERY.</span><span class="sxs-lookup"><span data-stu-id="c0e75-138">You know that you cannot create the binding to the resource pool before the database exists, so you perform the restore WITH NORECOVERY.</span></span>  <span data-ttu-id="c0e75-139">In questo modo, l'immagine disco del database viene ripristinata e il database viene creato, ma non viene usata memoria OLTP in memoria in quanto il database non viene portato online.</span><span class="sxs-lookup"><span data-stu-id="c0e75-139">This causes the disk image of the database to be restored and the database to be created, but no In-Memory OLTP memory is consumed because the database is not brought online.</span></span>

 <span data-ttu-id="c0e75-140">A questo punto, è possibile creare il pool di risorse per l'associazione del database e quindi usare RESTORE WITH RECOVERY per portare online il database ripristinato.</span><span class="sxs-lookup"><span data-stu-id="c0e75-140">At this point, you can create the Resource Pool to Database binding, and then use RESTORE WITH RECOVERY to bring the restored database online.</span></span>  <span data-ttu-id="c0e75-141">Poiché l'associazione è disponibile prima che il database venga portato online, l'utilizzo della memoria OLTP in memoria viene calcolato correttamente.</span><span class="sxs-lookup"><span data-stu-id="c0e75-141">Since the binding is in place before the database is brought online, its In-Memory OLTP memory consumption is properly accounted for.</span></span> <span data-ttu-id="c0e75-142">Ciò richiede che il database venga ripristinato una sola volta.</span><span class="sxs-lookup"><span data-stu-id="c0e75-142">This requires restoring the database only once.</span></span> <span data-ttu-id="c0e75-143">Il primo comando RESTORE è un comando informativo che legge solo l'intestazione del backup, mentre l'ultimo comando attiva semplicemente il ripristino senza effettivamente ripristinare alcun bit.</span><span class="sxs-lookup"><span data-stu-id="c0e75-143">The first RESTORE command is an informational command that only reads the backup header, and the last command simply triggers recovery without actually restoring any bits.</span></span>

## <a name="see-also"></a><span data-ttu-id="c0e75-144">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="c0e75-144">See Also</span></span>
 [<span data-ttu-id="c0e75-145">Eseguire il backup, ripristinare e recuperare tabelle con ottimizzazione per la memoria</span><span class="sxs-lookup"><span data-stu-id="c0e75-145">Backup, Restore, and Recovery of Memory-Optimized Tables</span></span>](memory-optimized-tables.md)


