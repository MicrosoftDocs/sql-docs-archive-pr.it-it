---
title: Introduzione alle tabelle con ottimizzazione per la memoria | Microsoft Docs
ms.custom: ''
ms.date: 07/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: ef1cc7de-63be-4fa3-a622-6d93b440e3ac
author: rothja
ms.author: jroth
ms.openlocfilehash: edcdea9d266cf0ef231b1e16be4da7009372dcd6
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/04/2020
ms.locfileid: "87725783"
---
# <a name="introduction-to-memory-optimized-tables"></a><span data-ttu-id="61e8b-102">Introduzione alle tabelle con ottimizzazione per la memoria</span><span class="sxs-lookup"><span data-stu-id="61e8b-102">Introduction to Memory-Optimized Tables</span></span>
  <span data-ttu-id="61e8b-103">Le tabelle con ottimizzazione per la memoria sono tabelle create usando [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="61e8b-103">Memory-optimized tables are tables, created using [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql).</span></span>  
  
 <span data-ttu-id="61e8b-104">Le tabelle con ottimizzazione per la memoria risiedono in memoria.</span><span class="sxs-lookup"><span data-stu-id="61e8b-104">Memory-optimized tables reside in memory.</span></span> <span data-ttu-id="61e8b-105">Le righe della tabella vengono lette e scritte in memoria.</span><span class="sxs-lookup"><span data-stu-id="61e8b-105">Rows in the table are read from and written to memory.</span></span> <span data-ttu-id="61e8b-106">L'intera tabella risiede in memoria.</span><span class="sxs-lookup"><span data-stu-id="61e8b-106">The entire table resides in memory.</span></span> <span data-ttu-id="61e8b-107">Una seconda copia dei dati della tabella viene mantenuta su disco, ma solo per motivi di durabilità.</span><span class="sxs-lookup"><span data-stu-id="61e8b-107">A second copy of the table data is maintained on disk, but only for durability purposes.</span></span>  
  
 <span data-ttu-id="61e8b-108">OLTP in memoria viene integrato con [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] per fornire un'esperienza senza problemi in tutte le aree, ad esempio sviluppo, distribuzione, gestibilità e supporto.</span><span class="sxs-lookup"><span data-stu-id="61e8b-108">In-Memory OLTP is integrated with [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to provide a seamless experience in all areas such as development, deployment, manageability, and supportability.</span></span> <span data-ttu-id="61e8b-109">Un database può contenere sia oggetti in memoria che oggetti basati su disco.</span><span class="sxs-lookup"><span data-stu-id="61e8b-109">A database can contain in-memory as well as disk-based objects.</span></span>  
  
 <span data-ttu-id="61e8b-110">Le righe delle tabelle ottimizzate per la memoria dispongono di versioni.</span><span class="sxs-lookup"><span data-stu-id="61e8b-110">Rows in memory-optimized tables are versioned.</span></span> <span data-ttu-id="61e8b-111">Ciò significa che ogni riga nella tabella dispone potenzialmente di più versioni.</span><span class="sxs-lookup"><span data-stu-id="61e8b-111">This means that each row in the table potentially has multiple versions.</span></span> <span data-ttu-id="61e8b-112">Tutte le versioni delle righe vengono mantenute nella stessa struttura dei dati della tabella.</span><span class="sxs-lookup"><span data-stu-id="61e8b-112">All row versions are maintained in the same table data structure.</span></span> <span data-ttu-id="61e8b-113">Il controllo delle versioni delle righe viene utilizzato per consentire letture e scritture simultanee nella stessa riga.</span><span class="sxs-lookup"><span data-stu-id="61e8b-113">Row versioning is used to allow concurrent reads and writes on the same row.</span></span> <span data-ttu-id="61e8b-114">Per ulteriori informazioni sulle letture e scritture simultanee nella stessa riga, vedere [transazioni nelle tabelle ottimizzate per la memoria](memory-optimized-tables.md).</span><span class="sxs-lookup"><span data-stu-id="61e8b-114">For more information about concurrent reads and writes on the same row, see [Transactions in Memory-Optimized Tables](memory-optimized-tables.md).</span></span>  
  
 <span data-ttu-id="61e8b-115">Nella figura seguente viene illustrato il controllo di più versioni.</span><span class="sxs-lookup"><span data-stu-id="61e8b-115">The following figure illustrates multi-versioning.</span></span> <span data-ttu-id="61e8b-116">Nella figura è illustrata una tabella con tre righe e ogni riga ha diverse versioni.</span><span class="sxs-lookup"><span data-stu-id="61e8b-116">The figure shows a table with three rows and each row has different versions.</span></span>  
  
 <span data-ttu-id="61e8b-117">![Controllo di più versioni.](../../database-engine/media/hekaton-tables-1.gif "Controllo di più versioni.")</span><span class="sxs-lookup"><span data-stu-id="61e8b-117">![Multi-versioning.](../../database-engine/media/hekaton-tables-1.gif "Multi-versioning.")</span></span>  
  
 <span data-ttu-id="61e8b-118">Nella tabella sono presenti tre righe: r1, r2 e r3.</span><span class="sxs-lookup"><span data-stu-id="61e8b-118">The table has three rows: r1, r2, and r3.</span></span> <span data-ttu-id="61e8b-119">r1 include tre versioni, r2 due versioni e r3 quattro versioni.</span><span class="sxs-lookup"><span data-stu-id="61e8b-119">r1 has three versions, r2 has two versions, and r3 has four versions.</span></span> <span data-ttu-id="61e8b-120">Si noti che diverse versioni della stessa riga non occupano necessariamente posizioni di memoria consecutive.</span><span class="sxs-lookup"><span data-stu-id="61e8b-120">Note that different versions of the same row do not necessarily occupy consecutive memory locations.</span></span> <span data-ttu-id="61e8b-121">Le diverse versioni delle righe possono essere presenti in diverse posizioni della struttura dei dati della tabella.</span><span class="sxs-lookup"><span data-stu-id="61e8b-121">The different row versions can be dispersed throughout the table data structure.</span></span>  
  
 <span data-ttu-id="61e8b-122">La struttura dei dati della tabella ottimizzata per la memoria può essere considerata una raccolta di versioni di riga.</span><span class="sxs-lookup"><span data-stu-id="61e8b-122">The memory-optimized table data structure can be seen as a collection of row versions.</span></span> <span data-ttu-id="61e8b-123">Le righe nelle tabelle basate su disco sono organizzate in pagine ed extent e alle singole righe viene fatto riferimento utilizzando il numero e l'offset della pagina, alle versioni di riga nelle tabelle ottimizzate per la memoria viene fatto riferimento tramite puntatori alla memoria a 8 byte.</span><span class="sxs-lookup"><span data-stu-id="61e8b-123">Rows in disk-based tables are organized in pages and extents, and individual rows addressed using page number and page offset, row versions in memory-optimized tables are addressed using 8-byte memory pointers.</span></span>  
  
## <a name="durability"></a><span data-ttu-id="61e8b-124">Durabilità</span><span class="sxs-lookup"><span data-stu-id="61e8b-124">Durability</span></span>  
 <span data-ttu-id="61e8b-125">Le tabelle ottimizzate per la memoria sono completamente durevoli per impostazione predefinita e, come le transazioni in tabelle tradizionali basate su disco, le transazioni completamente durevoli nelle tabelle ottimizzate per la memoria sono completamente ACID (atomicità, coerenza, isolamento e durabilità).</span><span class="sxs-lookup"><span data-stu-id="61e8b-125">Memory-optimized tables are fully durable by default, and, like transactions on (traditional) disk-based tables, fully durable transactions on memory-optimized tables are fully atomic, consistent, isolated, and durable (ACID).</span></span> <span data-ttu-id="61e8b-126">Le tabelle con ottimizzazione per la memoria e le stored procedure compilate in modo nativo supportano un subset di [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="61e8b-126">Memory-optimized tables and natively compiled stored procedures support a subset of [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span>  
  
 <span data-ttu-id="61e8b-127">La funzionalità OLTP in memoria supporta le tabelle durevoli con transazioni con durabilità ritardata.</span><span class="sxs-lookup"><span data-stu-id="61e8b-127">In-Memory OLTP supports durable tables with transaction durability delayed.</span></span> <span data-ttu-id="61e8b-128">Le transazioni con durabilità ritardata sono salvate su disco subito dopo il commit della transazione.</span><span class="sxs-lookup"><span data-stu-id="61e8b-128">Delayed durable transactions are saved to disk soon after the transaction has committed.</span></span> <span data-ttu-id="61e8b-129">In cambio di un miglioramento delle prestazioni, le transazioni di cui è stato eseguito il commit non salvate su disco vengono perse in caso di arresto anomalo del server o di failover.</span><span class="sxs-lookup"><span data-stu-id="61e8b-129">In exchange for the increased performance, committed transactions that have not saved to disk are lost in a server crash or failover.</span></span>  
  
 <span data-ttu-id="61e8b-130">Oltre alle tabelle ottimizzate per la memoria durevoli predefinite, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] supporta anche le tabelle ottimizzate per la memoria non durevoli che non vengono registrate e i cui dati non vengono salvati in modo persistente su disco.</span><span class="sxs-lookup"><span data-stu-id="61e8b-130">Besides the default durable memory-optimized tables, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] also supports non-durable memory-optimized tables, which are not logged and their data is not persisted on disk.</span></span> <span data-ttu-id="61e8b-131">Ciò significa che le transazioni in tali tabelle non richiedono alcuna attività di I/O su disco, ma i dati non verranno recuperati in caso di un arresto anomalo o di un failover del server.</span><span class="sxs-lookup"><span data-stu-id="61e8b-131">This means that transactions on these tables do not require any disk IO, but the data will not be recovered if there is a server crash or failover.</span></span>  
  
## <a name="accessing-data-in-memory-optimized-tables"></a><span data-ttu-id="61e8b-132">Accesso ai dati nelle tabelle con ottimizzazione per la memoria</span><span class="sxs-lookup"><span data-stu-id="61e8b-132">Accessing Data in Memory-Optimized Tables</span></span>  
 <span data-ttu-id="61e8b-133">Ai dati nelle tabelle ottimizzate per la memoria è possibile accedere in due modi:</span><span class="sxs-lookup"><span data-stu-id="61e8b-133">Data in memory-optimized tables is accessed in two ways:</span></span>  
  
-   <span data-ttu-id="61e8b-134">Tramite codice [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretato, all'esterno di una stored procedure compilata in modo nativo.</span><span class="sxs-lookup"><span data-stu-id="61e8b-134">Through interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] (outside of a natively-compiled stored procedure).</span></span> <span data-ttu-id="61e8b-135">Queste istruzioni [!INCLUDE[tsql](../../../includes/tsql-md.md)] possono essere incluse in stored procedure interpretate o essere istruzioni [!INCLUDE[tsql](../../../includes/tsql-md.md)] ad hoc.</span><span class="sxs-lookup"><span data-stu-id="61e8b-135">These [!INCLUDE[tsql](../../../includes/tsql-md.md)] statements may be either inside interpreted stored procedures or they may be ad-hoc [!INCLUDE[tsql](../../../includes/tsql-md.md)] statements.</span></span>  
  
-   <span data-ttu-id="61e8b-136">Tramite stored procedure compilate in modo nativo.</span><span class="sxs-lookup"><span data-stu-id="61e8b-136">Through natively compiled stored procedures.</span></span>  
  
 <span data-ttu-id="61e8b-137">È possibile accedere alle tabelle con ottimizzazione per la memoria in modo più efficiente da stored procedure compilate in modo nativo ([Stored procedure compilate in modo nativo](natively-compiled-stored-procedures.md)).</span><span class="sxs-lookup"><span data-stu-id="61e8b-137">Memory-optimized tables can be accessed most efficiently from natively compiled stored procedures ([Natively Compiled Stored Procedures](natively-compiled-stored-procedures.md)).</span></span> <span data-ttu-id="61e8b-138">È inoltre possibile accedere alle tabelle con ottimizzazione per la memoria con codice [!INCLUDE[tsql](../../../includes/tsql-md.md)]tradizionale interpretato.</span><span class="sxs-lookup"><span data-stu-id="61e8b-138">Memory-optimized tables can also be accessed with (traditional) interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="61e8b-139">Con [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretato si fa riferimento all'accesso a tabelle ottimizzate per la memoria senza una stored procedure compilata in modo nativo.</span><span class="sxs-lookup"><span data-stu-id="61e8b-139">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] refers to accessing memory-optimized tables without a natively compiled stored procedure.</span></span> <span data-ttu-id="61e8b-140">Alcuni esempi di accesso [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretato includono l'accesso a una tabella ottimizzata per la memoria da un trigger DML o un batch, una vista e una funzione con valori di tabella [!INCLUDE[tsql](../../../includes/tsql-md.md)] ad hoc.</span><span class="sxs-lookup"><span data-stu-id="61e8b-140">Some examples of interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access include accessing a memory-optimized table from a DML trigger, ad hoc [!INCLUDE[tsql](../../../includes/tsql-md.md)] batch, view, and table-valued function.</span></span>  
  
 <span data-ttu-id="61e8b-141">Nella tabella seguente viene riepilogato l'accesso [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretato e nativo per vari oggetti.</span><span class="sxs-lookup"><span data-stu-id="61e8b-141">The following table summarizes native and interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access for various objects.</span></span>  
  
|<span data-ttu-id="61e8b-142">Funzionalità</span><span class="sxs-lookup"><span data-stu-id="61e8b-142">Feature</span></span>|<span data-ttu-id="61e8b-143">Accesso tramite una stored procedure compilata in modo nativo</span><span class="sxs-lookup"><span data-stu-id="61e8b-143">Access Using a Natively Compiled Stored Procedure</span></span>|<span data-ttu-id="61e8b-144">Accesso [!INCLUDE[tsql](../../../includes/tsql-md.md)] interpretato</span><span class="sxs-lookup"><span data-stu-id="61e8b-144">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] Access</span></span>|<span data-ttu-id="61e8b-145">Accesso con CLR</span><span class="sxs-lookup"><span data-stu-id="61e8b-145">CLR Access</span></span>|  
|-------------|-------------------------------------------------------|-------------------------------------------|----------------|  
|<span data-ttu-id="61e8b-146">Tabelle ottimizzate per la memoria</span><span class="sxs-lookup"><span data-stu-id="61e8b-146">Memory-optimized tables</span></span>|<span data-ttu-id="61e8b-147">Sì</span><span class="sxs-lookup"><span data-stu-id="61e8b-147">Yes</span></span>|<span data-ttu-id="61e8b-148">Sì</span><span class="sxs-lookup"><span data-stu-id="61e8b-148">Yes</span></span>|<span data-ttu-id="61e8b-149">No <sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="61e8b-149">No <sup>1</sup></span></span>|  
|[<span data-ttu-id="61e8b-150">Variabili di tabella con ottimizzazione per la memoria</span><span class="sxs-lookup"><span data-stu-id="61e8b-150">Memory-Optimized Table Variables</span></span>](../../database-engine/memory-optimized-table-variables.md)|<span data-ttu-id="61e8b-151">Sì</span><span class="sxs-lookup"><span data-stu-id="61e8b-151">Yes</span></span>|<span data-ttu-id="61e8b-152">Sì</span><span class="sxs-lookup"><span data-stu-id="61e8b-152">Yes</span></span>|<span data-ttu-id="61e8b-153">No</span><span class="sxs-lookup"><span data-stu-id="61e8b-153">No</span></span>|  
|[<span data-ttu-id="61e8b-154">Stored procedure compilate in modo nativo</span><span class="sxs-lookup"><span data-stu-id="61e8b-154">Natively Compiled Stored Procedures</span></span>](https://msdn.microsoft.com/library/dn133184.aspx)|<span data-ttu-id="61e8b-155">Non è possibile utilizzare l'istruzione EXECUTE per eseguire una stored procedure qualsiasi da una stored procedure compilata in modo nativo.</span><span class="sxs-lookup"><span data-stu-id="61e8b-155">You cannot use the EXECUTE statement to execute any stored procedure from a natively compiled stored procedure.</span></span>|<span data-ttu-id="61e8b-156">Sì</span><span class="sxs-lookup"><span data-stu-id="61e8b-156">Yes</span></span>|<span data-ttu-id="61e8b-157">No <sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="61e8b-157">No <sup>1</sup></span></span>|  
  
 <span data-ttu-id="61e8b-158"><sup>1</sup> non è possibile accedere a una tabella ottimizzata per la memoria o a una stored procedure compilata in modo nativo dalla connessione del contesto (la connessione da [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] quando si esegue un modulo CLR).</span><span class="sxs-lookup"><span data-stu-id="61e8b-158"><sup>1</sup> You cannot access a memory-optimized table or natively compiled stored procedure from the context connection (the connection from [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] when executing a CLR module).</span></span> <span data-ttu-id="61e8b-159">È tuttavia possibile creare e aprire un'altra connessione da cui accedere a tabelle ottimizzate per la memoria e stored procedure compilate in modo nativo.</span><span class="sxs-lookup"><span data-stu-id="61e8b-159">You can, however, create and open another connection from which you can access memory-optimized tables and natively compiled stored procedures.</span></span> <span data-ttu-id="61e8b-160">Per altre informazioni, vedere [confronto tra normali e connessioni di contesto](../clr-integration/data-access/context-connections-vs-regular-connections.md).</span><span class="sxs-lookup"><span data-stu-id="61e8b-160">For more information, see [Regular vs. Context Connections](../clr-integration/data-access/context-connections-vs-regular-connections.md).</span></span>  
  
## <a name="performance-and-scalability"></a><span data-ttu-id="61e8b-161">Prestazioni e scalabilità</span><span class="sxs-lookup"><span data-stu-id="61e8b-161">Performance and Scalability</span></span>  
 <span data-ttu-id="61e8b-162">I seguenti fattori influiranno sui miglioramenti delle prestazioni che possono essere ottenuti con OLTP in memoria:</span><span class="sxs-lookup"><span data-stu-id="61e8b-162">The following factors will affect the performance gains that can be achieved with In-Memory OLTP:</span></span>  
  
 <span data-ttu-id="61e8b-163">Comunicazione</span><span class="sxs-lookup"><span data-stu-id="61e8b-163">Communication</span></span>  
 <span data-ttu-id="61e8b-164">Il miglioramento delle prestazioni per un'applicazione con molte chiamate a stored procedure brevi può risultare inferiore rispetto a un'applicazione con meno chiamate e più funzionalità implementate in ogni stored procedure.</span><span class="sxs-lookup"><span data-stu-id="61e8b-164">An application with many calls to short stored procedures may see a smaller performance gain compared to an application with fewer calls and more functionality implemented in each stored procedure.</span></span>  
  
 [!INCLUDE[tsql](../../../includes/tsql-md.md)] <span data-ttu-id="61e8b-165">Esecuzione</span><span class="sxs-lookup"><span data-stu-id="61e8b-165">Execution</span></span>  
 <span data-ttu-id="61e8b-166">In OLTP in memoria si ottengono le migliori prestazioni quando si utilizzano le stored procedure compilate in modo nativo anziché le stored procedure interpretate o l'esecuzione delle query.</span><span class="sxs-lookup"><span data-stu-id="61e8b-166">In-Memory OLTP achieves the best performance when using natively compiled stored procedures rather than interpreted stored procedures or query execution.</span></span> <span data-ttu-id="61e8b-167">Le stored procedure che comportano l'esecuzione di altre stored procedure non possono essere compilate in modo nativo, ma l'accesso alle tabelle ottimizzate per la memoria da queste stored procedure può offrire alcuni vantaggi.</span><span class="sxs-lookup"><span data-stu-id="61e8b-167">Stored procedures that execute other stored procedures cannot be natively compiled, but there can be a benefit to accessing memory-optimized tables from such stored procedures.</span></span>  
  
 <span data-ttu-id="61e8b-168">Analisi dell'intervallo e ricerca di punti</span><span class="sxs-lookup"><span data-stu-id="61e8b-168">Range Scan vs Point Lookup</span></span>  
 <span data-ttu-id="61e8b-169">Gli indici non cluster con ottimizzazione per la memoria supportano le analisi di intervalli e le analisi ordinate.</span><span class="sxs-lookup"><span data-stu-id="61e8b-169">Memory-optimized nonclustered indexes support range scans and ordered scans.</span></span> <span data-ttu-id="61e8b-170">Per le ricerche a punti, gli indici hash ottimizzati per la memoria offrono prestazioni migliori rispetto agli indici non cluster ottimizzati per la memoria.</span><span class="sxs-lookup"><span data-stu-id="61e8b-170">For point lookups, memory-optimized hash indexes have better performance than memory-optimized nonclustered indexes.</span></span> <span data-ttu-id="61e8b-171">Gli indici non cluster con ottimizzazione per la memoria offrono prestazioni migliori rispetto agli indici basati su disco.</span><span class="sxs-lookup"><span data-stu-id="61e8b-171">Memory-optimized nonclustered indexes have better performance than disk-based indexes.</span></span>  
  
 <span data-ttu-id="61e8b-172">Le operazioni sugli indici non vengono registrate e sono presenti solo in memoria.</span><span class="sxs-lookup"><span data-stu-id="61e8b-172">Index operations are not logged and they exist only in memory.</span></span>  
  
 <span data-ttu-id="61e8b-173">Concorrenza</span><span class="sxs-lookup"><span data-stu-id="61e8b-173">Concurrency</span></span>  
 <span data-ttu-id="61e8b-174">Le prestazioni di applicazioni interessate dalla concorrenza a livello di motore, ad esempio la contesa di latch o il blocco, migliorano significativamente quando l'applicazione viene spostata in OLTP in memoria.</span><span class="sxs-lookup"><span data-stu-id="61e8b-174">Applications whose performance is affected by engine-level concurrency, such as latch contention or blocking, improves significantly when the application moves to In-Memory OLTP.</span></span>  
  
 <span data-ttu-id="61e8b-175">Nella tabella seguente sono elencati i problemi relativi a prestazioni e scalabilità presenti in genere nei database relazionali e viene descritto in che modo OLTP in memoria può consentire il miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="61e8b-175">The following table lists the performance and scalability issues that are commonly found in relational databases and how In-Memory OLTP can improve performance.</span></span>  
  
|<span data-ttu-id="61e8b-176">Problema</span><span class="sxs-lookup"><span data-stu-id="61e8b-176">Issue</span></span>|<span data-ttu-id="61e8b-177">Impatto di OLTP in memoria</span><span class="sxs-lookup"><span data-stu-id="61e8b-177">In-Memory OLTP Impact</span></span>|  
|-----------|----------------------------|  
|<span data-ttu-id="61e8b-178">Prestazioni</span><span class="sxs-lookup"><span data-stu-id="61e8b-178">Performance</span></span><br /><br /> <span data-ttu-id="61e8b-179">Utilizzo elevato delle risorse (CPU, I/O, rete o memoria).</span><span class="sxs-lookup"><span data-stu-id="61e8b-179">High resource (CPU, I/O, network or memory) usage.</span></span>|<span data-ttu-id="61e8b-180">CPU</span><span class="sxs-lookup"><span data-stu-id="61e8b-180">CPU</span></span><br /> <span data-ttu-id="61e8b-181">Le stored procedure compilate in modo nativo possono ridurre in modo significativo l'utilizzo della CPU perché richiedono un numero decisamente inferiore di istruzioni per eseguire un'istruzione [!INCLUDE[tsql](../../../includes/tsql-md.md)] rispetto alle stored procedure interpretate.</span><span class="sxs-lookup"><span data-stu-id="61e8b-181">Natively compiled stored procedures can lower CPU usage significantly because they require significantly fewer instructions to execute a [!INCLUDE[tsql](../../../includes/tsql-md.md)] statement compared to interpreted stored procedures.</span></span><br /><br /> <span data-ttu-id="61e8b-182">OLTP in memoria può ridurre l'investimento hardware nei carichi di lavoro con scalabilità orizzontale, in quanto un server può potenzialmente fornire la velocità effettiva di cinque/dieci server.</span><span class="sxs-lookup"><span data-stu-id="61e8b-182">In-Memory OLTP can help reduce the hardware investment in scaled-out workloads because one server can potentially deliver the throughput of five to ten servers.</span></span><br /><br /> <span data-ttu-id="61e8b-183">I/O</span><span class="sxs-lookup"><span data-stu-id="61e8b-183">I/O</span></span><br /> <span data-ttu-id="61e8b-184">Se si verifica un collo di bottiglia a livello di I/O in seguito all'elaborazione di pagine di dati o di indice, in OLTP in memoria il collo di bottiglia potrebbe risultare contenuto.</span><span class="sxs-lookup"><span data-stu-id="61e8b-184">If you encounter an I/O bottleneck from processing to data or index pages, In-Memory OLTP may reduce the bottleneck.</span></span> <span data-ttu-id="61e8b-185">Inoltre, il checkpoint degli oggetti di OLTP in memoria è continuo e non genera aumenti improvvisi nelle operazioni di I/O.</span><span class="sxs-lookup"><span data-stu-id="61e8b-185">Additionally, the checkpointing of In-Memory OLTP objects is continuous and does not lead to sudden increases in I/O operations.</span></span> <span data-ttu-id="61e8b-186">Se tuttavia il working set delle tabelle critiche per le prestazioni eccede la memoria disponibile, OLTP in memoria non sarà in grado di migliorare le prestazioni in quanto è necessario che i dati siano residenti in memoria.</span><span class="sxs-lookup"><span data-stu-id="61e8b-186">However, if the working set of the performance critical tables does not fit in memory, In-Memory OLTP will not improve performance because it requires data to be memory resident.</span></span> <span data-ttu-id="61e8b-187">Se si verifica un collo di bottiglia a livello di I/O durante la registrazione, OLTP in memoria può ridurre il collo di bottiglia perché richiede meno attività di registrazione.</span><span class="sxs-lookup"><span data-stu-id="61e8b-187">If you encounter an I/O bottleneck in logging, In-Memory OLTP can reduce the bottleneck because it does less logging.</span></span> <span data-ttu-id="61e8b-188">Se una o più tabelle ottimizzate per la memoria sono configurate come tabelle non durevoli, è possibile eliminare la registrazione dei dati.</span><span class="sxs-lookup"><span data-stu-id="61e8b-188">If one or more memory-optimized tables are configured as non-durable tables, you can eliminate logging for data.</span></span><br /><br /> <span data-ttu-id="61e8b-189">Memoria</span><span class="sxs-lookup"><span data-stu-id="61e8b-189">Memory</span></span><br /> <span data-ttu-id="61e8b-190">Con OLTP in memoria non si ottiene alcun vantaggio in termini di prestazioni.</span><span class="sxs-lookup"><span data-stu-id="61e8b-190">In-Memory OLTP does not offer any performance benefit.</span></span> <span data-ttu-id="61e8b-191">È possibile che OLTP in memoria comporti un utilizzo elevato di memoria, in quando gli oggetti devono essere residenti in memoria.</span><span class="sxs-lookup"><span data-stu-id="61e8b-191">In-Memory OLTP can put extra pressure on memory as the objects need to be memory resident.</span></span><br /><br /> <span data-ttu-id="61e8b-192">Rete</span><span class="sxs-lookup"><span data-stu-id="61e8b-192">Network</span></span><br /> <span data-ttu-id="61e8b-193">Con OLTP in memoria non si ottiene alcun vantaggio in termini di prestazioni.</span><span class="sxs-lookup"><span data-stu-id="61e8b-193">In-Memory OLTP does not offer any performance benefit.</span></span> <span data-ttu-id="61e8b-194">I dati devo essere comunicati dal livello dati al livello applicazione.</span><span class="sxs-lookup"><span data-stu-id="61e8b-194">The data needs to be communicated from data tier to application tier.</span></span>|  
|<span data-ttu-id="61e8b-195">Scalabilità</span><span class="sxs-lookup"><span data-stu-id="61e8b-195">Scalability</span></span><br /><br /> <span data-ttu-id="61e8b-196">La maggior parte dei problemi di scalabilità nelle applicazioni di [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] è causata da problemi di concorrenza, ad esempio la contesa in blocchi, latch e spinlock.</span><span class="sxs-lookup"><span data-stu-id="61e8b-196">Most scaling issues in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] applications are caused by concurrency issues such as contention in locks, latches, and spinlocks.</span></span>|<span data-ttu-id="61e8b-197">Contesa di latch</span><span class="sxs-lookup"><span data-stu-id="61e8b-197">Latch Contention</span></span><br /> <span data-ttu-id="61e8b-198">Uno scenario tipico riguarda la contesa nell'ultima pagina di un indice quando vengono inserite contemporaneamente righe nell'ordine delle chiavi.</span><span class="sxs-lookup"><span data-stu-id="61e8b-198">A typical scenario is contention on the last page of an index when inserting rows concurrently in key order.</span></span> <span data-ttu-id="61e8b-199">Poiché in OLTP in memoria non vengono utilizzati latch per l'accesso ai dati, i problemi di scalabilità correlati alle contese di latch vengono completamente rimossi.</span><span class="sxs-lookup"><span data-stu-id="61e8b-199">Because In-Memory OLTP does not take latches when accessing data, the scalability issues related to latch contentions are fully removed.</span></span><br /><br /> <span data-ttu-id="61e8b-200">Contesa di spinlock</span><span class="sxs-lookup"><span data-stu-id="61e8b-200">Spinlock Contention</span></span><br /> <span data-ttu-id="61e8b-201">Poiché in OLTP in memoria non vengono utilizzati latch per l'accesso ai dati, i problemi di scalabilità correlati alle contese di spinlock vengono completamente rimossi.</span><span class="sxs-lookup"><span data-stu-id="61e8b-201">Because In-Memory OLTP does not take latches when accessing data, the scalability issues related to spinlock contentions are fully removed.</span></span><br /><br /> <span data-ttu-id="61e8b-202">Contesa correlata al blocco</span><span class="sxs-lookup"><span data-stu-id="61e8b-202">Locking Related Contention</span></span><br /> <span data-ttu-id="61e8b-203">Se nell'applicazione di database vengono rilevati problemi di blocco tra operazioni di lettura e scrittura, con OLTP in memoria vengono rimossi i problemi che impediscono di proseguire perché è previsto l'utilizzo di una nuova forma di controllo della concorrenza ottimistica per implementare tutti i livelli di isolamento delle transazioni.</span><span class="sxs-lookup"><span data-stu-id="61e8b-203">If your database application encounters blocking issues between read and write operations, In-Memory OLTP removes the blocking issues because it uses a new form of optimistic concurrency control to implement all transaction isolation levels.</span></span> <span data-ttu-id="61e8b-204">In OLTP in memoria, TempDB non viene utilizzato per l'archiviazione delle versioni di riga.</span><span class="sxs-lookup"><span data-stu-id="61e8b-204">In-Memory OLTP does not use TempDB to store row versions.</span></span><br /><br /> <span data-ttu-id="61e8b-205">Se il problema di scalabilità è determinato dal conflitto tra due operazioni di scrittura, ad esempio due transazioni simultanee che tentano di aggiornare la stessa riga, OLTP in memoria consente il completamento di una transazione e genera un errore per l'altra.</span><span class="sxs-lookup"><span data-stu-id="61e8b-205">If the scaling issue is caused by conflict between two write operations, such as two concurrent transactions trying to update the same row, In-Memory OLTP lets one transaction succeed and fails the other transaction.</span></span> <span data-ttu-id="61e8b-206">La transazione non riuscita deve essere inviata di nuovo in modo esplicito o implicito, ripetendone l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="61e8b-206">The failed transaction must be re-submitted either explicitly or implicitly, re-trying the transaction.</span></span> <span data-ttu-id="61e8b-207">In entrambi i casi è necessario apportare modifiche all'applicazione.</span><span class="sxs-lookup"><span data-stu-id="61e8b-207">In either case, you need to make changes to the application.</span></span><br /><br /> <span data-ttu-id="61e8b-208">Se nell'applicazione si verificano frequenti conflitti tra due operazioni di scrittura, il valore del blocco ottimistico viene ridotto.</span><span class="sxs-lookup"><span data-stu-id="61e8b-208">If your application experiences frequent conflicts between two write operations, the value of optimistic locking is diminished.</span></span> <span data-ttu-id="61e8b-209">L'applicazione non è appropriata per OLTP in memoria.</span><span class="sxs-lookup"><span data-stu-id="61e8b-209">The application is not suitable for In-Memory OLTP.</span></span> <span data-ttu-id="61e8b-210">La maggior parte delle applicazioni OLTP non presenta conflitti di scrittura, a meno che il conflitto non venga attivato da escalation blocchi.</span><span class="sxs-lookup"><span data-stu-id="61e8b-210">Most OLTP applications don't have a write conflicts unless the conflict is induced by lock escalation.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="61e8b-211">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="61e8b-211">See Also</span></span>  
 [<span data-ttu-id="61e8b-212">OLTP in memoria &#40;ottimizzazione per la memoria&#41;</span><span class="sxs-lookup"><span data-stu-id="61e8b-212">In-Memory OLTP &#40;In-Memory Optimization&#41;</span></span>](in-memory-oltp-in-memory-optimization.md)  
  
  
