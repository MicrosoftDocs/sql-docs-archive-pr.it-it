---
title: Tabelle e indici partizionati | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
helpviewer_keywords:
- partitioned tables [SQL Server], about partitioned tables
- partitioned indexes [SQL Server], architecture
- partitioned tables [SQL Server], architecture
- partitioned indexes [SQL Server], about partitioned indexes
ms.assetid: cc5bf181-18a0-44d5-8bd7-8060d227c927
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: e8d041abcfe491f311e38bc8dab4be4ea253e37c
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/04/2020
ms.locfileid: "87723739"
---
# <a name="partitioned-tables-and-indexes"></a><span data-ttu-id="c893e-102">Partitioned Tables and Indexes</span><span class="sxs-lookup"><span data-stu-id="c893e-102">Partitioned Tables and Indexes</span></span>
  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="c893e-103">supporta il partizionamento di tabelle e indici.</span><span class="sxs-lookup"><span data-stu-id="c893e-103">supports table and index partitioning.</span></span> <span data-ttu-id="c893e-104">I dati di tabelle e indici partizionati vengono divisi in unità distribuibili tra più filegroup in un database.</span><span class="sxs-lookup"><span data-stu-id="c893e-104">The data of partitioned tables and indexes is divided into units that can be spread across more than one filegroup in a database.</span></span> <span data-ttu-id="c893e-105">I dati sono partizionati in senso orizzontale, in modo che per gruppi di righe venga eseguito il mapping in singole partizioni.</span><span class="sxs-lookup"><span data-stu-id="c893e-105">The data is partitioned horizontally, so that groups of rows are mapped into individual partitions.</span></span> <span data-ttu-id="c893e-106">Tutte le partizioni di un singolo indice o di una singola tabella devono trovarsi nello stesso database.</span><span class="sxs-lookup"><span data-stu-id="c893e-106">All partitions of a single index or table must reside in the same database.</span></span> <span data-ttu-id="c893e-107">La tabella o indice viene gestito come singola entità logica quando si eseguono query o aggiornamenti sui dati.</span><span class="sxs-lookup"><span data-stu-id="c893e-107">The table or index is treated as a single logical entity when queries or updates are performed on the data.</span></span> <span data-ttu-id="c893e-108">Le tabelle e gli indici partizionati sono disponibili solo in alcune edizioni di [!INCLUDE[msCoName](../../includes/msconame-md.md)][!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="c893e-108">Partitioned tables and indexes are not available in every edition of [!INCLUDE[msCoName](../../includes/msconame-md.md)][!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="c893e-109">Per un elenco delle funzionalità supportate dalle edizioni di [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], vedere [Features Supported by the Editions of SQL Server 2014](../../getting-started/features-supported-by-the-editions-of-sql-server-2014.md).</span><span class="sxs-lookup"><span data-stu-id="c893e-109">For a list of features that are supported by the editions of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], see [Features Supported by the Editions of SQL Server 2014](../../getting-started/features-supported-by-the-editions-of-sql-server-2014.md).</span></span>  
  
> [!IMPORTANT]  
>  <span data-ttu-id="c893e-110">Per impostazione predefinita, in[!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] viene supportato un massimo di 15.000 partizioni.</span><span class="sxs-lookup"><span data-stu-id="c893e-110">[!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] supports up to 15,000 partitions by default.</span></span> <span data-ttu-id="c893e-111">Nelle versioni precedenti di [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], il numero di partizioni è stato limitato a 1.000 per impostazione predefinita. Nei sistemi x86, creare una tabella o un indice con più di 1000 partizioni è possibile, ma non è supportato.</span><span class="sxs-lookup"><span data-stu-id="c893e-111">In versions earlier than [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], the number of partitions was limited to 1,000 by default.On x86-based systems, creating a table or index with more than 1000 partitions is possible, but is not supported.</span></span>  
  
## <a name="benefits-of-partitioning"></a><span data-ttu-id="c893e-112">Vantaggi del partizionamento</span><span class="sxs-lookup"><span data-stu-id="c893e-112">Benefits of Partitioning</span></span>  
 <span data-ttu-id="c893e-113">Il partizionamento di tabelle o indici di grandi dimensioni può offrire i vantaggi in termini di gestibilità e prestazioni descritti di seguito.</span><span class="sxs-lookup"><span data-stu-id="c893e-113">Partitioning large tables or indexes can have the following manageability and performance benefits.</span></span>  
  
-   <span data-ttu-id="c893e-114">È possibile trasferire o accedere a subset di dati in modo rapido ed efficiente, salvaguardando al contempo l'integrità della raccolta di dati.</span><span class="sxs-lookup"><span data-stu-id="c893e-114">You can transfer or access subsets of data quickly and efficiently, while maintaining the integrity of a data collection.</span></span> <span data-ttu-id="c893e-115">Operazioni quali il caricamento di dati da un sistema OLTP a un sistema OLAP richiedono ad esempio solo pochi secondi invece che minuti o addirittura ore necessari invece quando i dati non sono partizionati.</span><span class="sxs-lookup"><span data-stu-id="c893e-115">For example, an operation such as loading data from an OLTP to an OLAP system takes only seconds, instead of the minutes and hours the operation takes when the data is not partitioned.</span></span>  
  
-   <span data-ttu-id="c893e-116">È possibile eseguire più rapidamente operazioni di manutenzione su una o più partizioni.</span><span class="sxs-lookup"><span data-stu-id="c893e-116">You can perform maintenance operations on one or more partitions more quickly.</span></span> <span data-ttu-id="c893e-117">Le operazioni risultano più efficienti perché vengono applicate solo a subset di dati e non all'intera tabella.</span><span class="sxs-lookup"><span data-stu-id="c893e-117">The operations are more efficient because they target only these data subsets, instead of the whole table.</span></span> <span data-ttu-id="c893e-118">È ad esempio possibile scegliere di comprimere i dati in una o più partizioni oppure ricompilare una o più partizioni di un indice.</span><span class="sxs-lookup"><span data-stu-id="c893e-118">For example, you can choose to compress data in one or more partitions or rebuild one or more partitions of an index.</span></span>  
  
-   <span data-ttu-id="c893e-119">È possibile ottenere migliori prestazioni con le query in base alle tipologie eseguite con maggiore frequenza e alla configurazione hardware in uso.</span><span class="sxs-lookup"><span data-stu-id="c893e-119">You may improve query performance, based on the types of queries you frequently run and on your hardware configuration.</span></span> <span data-ttu-id="c893e-120">Ad esempio, Query Optimizer è in grado di elaborare query di tipo equijoin tra due o più tabelle partizionate in modo più rapido quando le colonne di partizionamento nelle tabelle corrispondono, in quanto è possibile unire in join le partizioni stesse.</span><span class="sxs-lookup"><span data-stu-id="c893e-120">For example, the query optimizer can process equi-join queries between two or more partitioned tables faster when the partitioning columns in the tables are the same, because the partitions themselves can be joined.</span></span>  
  
     <span data-ttu-id="c893e-121">Quando in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] viene eseguito l'ordinamento dei dati per le operazioni di I/O, i dati vengono innanzitutto ordinati in base alla partizione.</span><span class="sxs-lookup"><span data-stu-id="c893e-121">When [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] performs data sorting for I/O operations, it sorts the data first by partition.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="c893e-122">accede a un'unità per volta, il che può comportare una riduzione delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="c893e-122">accesses one drive at a time, and this might reduce performance.</span></span> <span data-ttu-id="c893e-123">Per migliorare le prestazioni di ordinamento dei dati, eseguire lo striping dei file di dati delle partizioni tra più dischi configurando un sistema RAID.</span><span class="sxs-lookup"><span data-stu-id="c893e-123">To improve data sorting performance, stripe the data files of your partitions across more than one disk by setting up a RAID.</span></span> <span data-ttu-id="c893e-124">In questo modo, benché tramite [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] i dati vengano comunque ordinati in base alla partizione, è possibile accedere a tutte le unità di ogni partizione simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="c893e-124">In this way, although [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] still sorts data by partition, it can access all the drives of each partition at the same time.</span></span>  
  
     <span data-ttu-id="c893e-125">È inoltre possibile migliorare le prestazioni abilitando l'escalation blocchi a livello di partizione invece che di intera tabella.</span><span class="sxs-lookup"><span data-stu-id="c893e-125">In addition, you can improve performance by enabling lock escalation at the partition level instead of a whole table.</span></span> <span data-ttu-id="c893e-126">Ciò consente di ridurre gli effetti di contesa dei blocchi per la tabella.</span><span class="sxs-lookup"><span data-stu-id="c893e-126">This can reduce lock contention on the table.</span></span>  
  
## <a name="components-and-concepts"></a><span data-ttu-id="c893e-127">Componenti e concetti</span><span class="sxs-lookup"><span data-stu-id="c893e-127">Components and Concepts</span></span>  
 <span data-ttu-id="c893e-128">I termini seguenti sono applicabili al partizionamento di tabelle e indici.</span><span class="sxs-lookup"><span data-stu-id="c893e-128">The following terms are applicable to table and index partitioning.</span></span>  
  
 <span data-ttu-id="c893e-129">Funzione di partizione</span><span class="sxs-lookup"><span data-stu-id="c893e-129">Partition function</span></span>  
 <span data-ttu-id="c893e-130">Oggetto di database che definisce la modalità con cui viene eseguito il mapping delle righe di una tabella o di un indice a un set di partizioni in base ai valori di una determinata colonna, denominata colonna di partizionamento.</span><span class="sxs-lookup"><span data-stu-id="c893e-130">A database object that defines how the rows of a table or index are mapped to a set of partitions based on the values of certain column, called a partitioning column.</span></span> <span data-ttu-id="c893e-131">Ovvero, la funzione di partizione definisce il numero di partizioni che la tabella avrà e come sono definiti i limiti delle partizioni.</span><span class="sxs-lookup"><span data-stu-id="c893e-131">That is, the partition function defines the number of partitions that the table will have and how the boundaries of the partitions are defined.</span></span> <span data-ttu-id="c893e-132">Ad esempio, data una tabella che contiene i dati degli ordini di vendita, si può decidere di partizionare la tabella in dodici (ogni mese) partizioni basate su una colonna di tipo `datetime`, quale una data di vendita.</span><span class="sxs-lookup"><span data-stu-id="c893e-132">For example, given a table that contains sales order data, you may want to partition the table into twelve (monthly) partitions based on a `datetime` column such as a sales date.</span></span>  
  
 <span data-ttu-id="c893e-133">Schema di partizione</span><span class="sxs-lookup"><span data-stu-id="c893e-133">Partition scheme</span></span>  
 <span data-ttu-id="c893e-134">Oggetto di database che mappa le partizioni di una funzione di partizione a un set di filegroup.</span><span class="sxs-lookup"><span data-stu-id="c893e-134">A database object that maps the partitions of a partition function to a set of filegroups.</span></span> <span data-ttu-id="c893e-135">Il principale motivo per cui inserire le partizioni in filegroup separati consiste nel fatto che in tal modo è possibile eseguire operazioni di backup nelle partizioni in modo indipendente,</span><span class="sxs-lookup"><span data-stu-id="c893e-135">The primary reason for placing your partitions on separate filegroups is to make sure that you can independently perform backup operations on partitions.</span></span> <span data-ttu-id="c893e-136">in quanto è possibile eseguire backup in filegroup singoli.</span><span class="sxs-lookup"><span data-stu-id="c893e-136">This is because you can perform backups on individual filegroups.</span></span>  
  
 <span data-ttu-id="c893e-137">Colonna di partizionamento</span><span class="sxs-lookup"><span data-stu-id="c893e-137">Partitioning column</span></span>  
 <span data-ttu-id="c893e-138">Colonna di una tabella o di un indice utilizzata da una funzione di partizione per partizionare la tabella o l'indice.</span><span class="sxs-lookup"><span data-stu-id="c893e-138">The column of a table or index that a partition function uses to partition the table or index.</span></span> <span data-ttu-id="c893e-139">Le colonne calcolate che partecipano a una funzione di partizione devono essere contrassegnate in modo esplicito come PERSISTED.</span><span class="sxs-lookup"><span data-stu-id="c893e-139">Computed columns that participate in a partition function must be explicitly marked PERSISTED.</span></span> <span data-ttu-id="c893e-140">È possibile utilizzare come colonna di partizionamento tutti i tipi di dati che possono essere utilizzati come colonne di indice, eccetto il tipo di dati `timestamp`.</span><span class="sxs-lookup"><span data-stu-id="c893e-140">All data types that are valid for use as index columns can be used as a partitioning column, except `timestamp`.</span></span> <span data-ttu-id="c893e-141">Non è possibile specificare i tipi di dati `ntext`, `text`, `image`, `xml`, `varchar(max)`, `nvarchar(max)` o `varbinary(max)`.</span><span class="sxs-lookup"><span data-stu-id="c893e-141">The `ntext`, `text`, `image`, `xml`, `varchar(max)`, `nvarchar(max)`, or `varbinary(max)` data types cannot be specified.</span></span> <span data-ttu-id="c893e-142">Inoltre, non è possibile specificare colonne di tipo definito dall'utente Common Language Runtime (CLR) di Microsoft .NET Framework né colonne di tipo di dati alias.</span><span class="sxs-lookup"><span data-stu-id="c893e-142">Also, Microsoft .NET Framework common language runtime (CLR) user-defined type and alias data type columns cannot be specified.</span></span>  
  
 <span data-ttu-id="c893e-143">Indice allineato</span><span class="sxs-lookup"><span data-stu-id="c893e-143">Aligned index</span></span>  
 <span data-ttu-id="c893e-144">Indice basato sullo stesso schema di partizione della relativa tabella corrispondente.</span><span class="sxs-lookup"><span data-stu-id="c893e-144">An index that is built on the same partition scheme as its corresponding table.</span></span> <span data-ttu-id="c893e-145">Se una tabella e i relativi indici sono allineati, in SQL Server è possibile cambiare le partizioni in modo rapido ed efficiente, mantenendo inalterata la struttura della tabella e degli indici.</span><span class="sxs-lookup"><span data-stu-id="c893e-145">When a table and its indexes are in alignment, SQL Server can switch partitions quickly and efficiently while maintaining the partition structure of both the table and its indexes.</span></span> <span data-ttu-id="c893e-146">Per poter essere allineato alla relativa tabella di base, non è necessario che un indice sia inserito nella stessa funzione di partizione denominata.</span><span class="sxs-lookup"><span data-stu-id="c893e-146">An index does not have to participate in the same named partition function to be aligned with its base table.</span></span> <span data-ttu-id="c893e-147">Le funzioni di partizione dell'indice e della tabella di base devono tuttavia condividere alcune caratteristiche, ad esempio i tipi di dati degli argomenti devono essere uguali, il numero di partizioni definito deve corrispondere e i valori limite delle partizioni devono essere uguali.</span><span class="sxs-lookup"><span data-stu-id="c893e-147">However, the partition function of the index and the base table must be essentially the same, in that 1) the arguments of the partition functions have the same data type, 2) they define the same number of partitions, and 3) they define the same boundary values for partitions.</span></span>  
  
 <span data-ttu-id="c893e-148">Indice non allineato</span><span class="sxs-lookup"><span data-stu-id="c893e-148">Nonaligned index</span></span>  
 <span data-ttu-id="c893e-149">Indice partizionato in modo indipendente rispetto alla relativa tabella corrispondente.</span><span class="sxs-lookup"><span data-stu-id="c893e-149">An index partitioned independently from its corresponding table.</span></span> <span data-ttu-id="c893e-150">Ciò significa che l'indice presenta uno schema di partizione diverso oppure che si trova in un filegroup separato rispetto alla tabella di base.</span><span class="sxs-lookup"><span data-stu-id="c893e-150">That is, the index has a different partition scheme or is placed on a separate filegroup from the base table.</span></span> <span data-ttu-id="c893e-151">La progettazione di un indice partizionato non allineato può risultare utile nei casi seguenti:</span><span class="sxs-lookup"><span data-stu-id="c893e-151">Designing an nonaligned partitioned index can be useful in the following cases:</span></span>  
  
-   <span data-ttu-id="c893e-152">La tabella di base non è stata partizionata.</span><span class="sxs-lookup"><span data-stu-id="c893e-152">The base table has not been partitioned.</span></span>  
  
-   <span data-ttu-id="c893e-153">La chiave dell'indice è univoca e non contiene la colonna di partizionamento della tabella.</span><span class="sxs-lookup"><span data-stu-id="c893e-153">The index key is unique and it does not contain the partitioning column of the table.</span></span>  
  
-   <span data-ttu-id="c893e-154">Si desidera che la tabella di base sia inserita in join collocati con più tabelle che utilizzano colonne di join diverse.</span><span class="sxs-lookup"><span data-stu-id="c893e-154">You want the base table to participate in collocated joins with more tables using different join columns.</span></span>  
  
 <span data-ttu-id="c893e-155">Eliminazione di partizioni</span><span class="sxs-lookup"><span data-stu-id="c893e-155">Partition elimination</span></span>  
 <span data-ttu-id="c893e-156">Processo mediante il quale Query Optimizer accede solo alle partizioni rilevanti per soddisfare i criteri di filtro della query.</span><span class="sxs-lookup"><span data-stu-id="c893e-156">The process by which the query optimizer accesses only the relevant partitions to satisfy the filter criteria of the query.</span></span>  
  
## <a name="performance-guidelines"></a><span data-ttu-id="c893e-157">Linee guida relative alle prestazioni</span><span class="sxs-lookup"><span data-stu-id="c893e-157">Performance Guidelines</span></span>  
 <span data-ttu-id="c893e-158">Il nuovo limite massimo di 15.000 partizioni influisce sulla memoria, sulle operazioni degli indici partizionati, sui comandi DBCC e sulle query.</span><span class="sxs-lookup"><span data-stu-id="c893e-158">The new, higher limit of 15,000 partitions affects memory, partitioned index operations, DBCC commands, and queries.</span></span> <span data-ttu-id="c893e-159">In questa sezione vengono descritte le implicazioni relative alle prestazioni determinate dall'aumento del numero di partizioni al di sopra di 1000 e vengono illustrate soluzioni alternative a seconda delle necessità.</span><span class="sxs-lookup"><span data-stu-id="c893e-159">This section describes the performance implications of increasing the number of partitions above 1,000 and provides workarounds as needed.</span></span> <span data-ttu-id="c893e-160">Con l'aumento del limite al numero massimo di partizioni fino a 15.000, è possibile archiviare dati per periodi prolungati.</span><span class="sxs-lookup"><span data-stu-id="c893e-160">With the limit on the maximum number of partitions being increased to 15,000, you can store data for a longer time.</span></span> <span data-ttu-id="c893e-161">Tuttavia, è consigliabile mantenere i dati solo per il tempo strettamente necessario e preservare l'equilibrio tra livello di prestazioni e numero di partizioni.</span><span class="sxs-lookup"><span data-stu-id="c893e-161">However, you should retain data only for as long as it is needed and maintain a balance between performance and number of partitions.</span></span>  
  
### <a name="memory-usage-and-guidelines"></a><span data-ttu-id="c893e-162">Utilizzo della memoria e linee guida</span><span class="sxs-lookup"><span data-stu-id="c893e-162">Memory Usage and Guidelines</span></span>  
 <span data-ttu-id="c893e-163">È consigliabile disporre di almeno 16 GB di RAM se si utilizza un numero elevato di partizioni.</span><span class="sxs-lookup"><span data-stu-id="c893e-163">We recommend that you use at least 16 GB of RAM if a large number of partitions are in use.</span></span> <span data-ttu-id="c893e-164">Se il sistema non dispone di memoria sufficiente, le istruzioni DML (Data Manipulation Language) e DDL (Data Definition Language) nonché altri tipi di operazioni potrebbero avere esito negativo.</span><span class="sxs-lookup"><span data-stu-id="c893e-164">If the system does not have enough memory, Data Manipulation Language (DML) statements, Data Definition Language (DDL) statements and other operations can fail due to insufficient memory.</span></span> <span data-ttu-id="c893e-165">Nei sistemi provvisti di 16 GB di RAM in cui vengono eseguiti numerosi processi che richiedono un'elevata quantità di memoria, quest'ultima potrebbe esaurirsi in caso di operazioni su un numero elevato di partizioni.</span><span class="sxs-lookup"><span data-stu-id="c893e-165">Systems with 16 GB of RAM that run many memory-intensive processes may run out of memory on operations that run on a large number of partitions.</span></span> <span data-ttu-id="c893e-166">Pertanto, la probabilità che si verifichino problemi di prestazioni o di memoria si riduce in funzione della quantità di memoria disponibile oltre i 16 GB.</span><span class="sxs-lookup"><span data-stu-id="c893e-166">Therefore, the more memory you have over 16 GB, the less likely you are to encounter performance and memory issues.</span></span>  
  
 <span data-ttu-id="c893e-167">Le limitazioni relative alla memoria possono influire sulle prestazioni o sulla capacità stessa di compilare un indice partizionato in SQL Server,</span><span class="sxs-lookup"><span data-stu-id="c893e-167">Memory limitations can affect the performance or ability of SQL Server to build a partitioned index.</span></span> <span data-ttu-id="c893e-168">specialmente se l'indice non è allineato alla relativa tabella di base o al relativo indice cluster eventualmente applicato.</span><span class="sxs-lookup"><span data-stu-id="c893e-168">This is especially the case when the index is not aligned with its base table or is not aligned with its clustered index, if the table already has a clustered index applied to it.</span></span>  
  
### <a name="partitioned-index-operations"></a><span data-ttu-id="c893e-169">Operazioni relative agli indici partizionati</span><span class="sxs-lookup"><span data-stu-id="c893e-169">Partitioned Index Operations</span></span>  
 <span data-ttu-id="c893e-170">Le limitazioni relative alla memoria possono influire sulle prestazioni o sulla capacità stessa di compilare un indice partizionato in SQL Server,</span><span class="sxs-lookup"><span data-stu-id="c893e-170">Memory limitations can affect the performance or ability of SQL Server to build a partitioned index.</span></span> <span data-ttu-id="c893e-171">specialmente del caso di indici non allineati.</span><span class="sxs-lookup"><span data-stu-id="c893e-171">This is especially the case with nonaligned indexes.</span></span> <span data-ttu-id="c893e-172">La creazione e la ricompilazione di indici non allineati per una tabella con oltre 1.000 partizioni sono possibili, ma non supportate.</span><span class="sxs-lookup"><span data-stu-id="c893e-172">Creating and rebuilding nonaligned indexes on a table with more than 1,000 partitions is possible, but is not supported.</span></span> <span data-ttu-id="c893e-173">Questo tipo di operazioni può causare riduzioni delle prestazioni e un eccessivo consumo della memoria.</span><span class="sxs-lookup"><span data-stu-id="c893e-173">Doing so may cause degraded performance or excessive memory consumption during these operations.</span></span>  
  
 <span data-ttu-id="c893e-174">La creazione e la ricompilazione di indici allineati possono richiedere più tempo a seconda del numero di partizioni.</span><span class="sxs-lookup"><span data-stu-id="c893e-174">Creating and rebuilding aligned indexes could take longer to execute as the number of partitions increases.</span></span> <span data-ttu-id="c893e-175">È consigliabile non eseguire più comandi di creazione e ricompilazione degli indici contemporaneamente poiché potrebbero verificarsi problemi di prestazioni e memoria.</span><span class="sxs-lookup"><span data-stu-id="c893e-175">We recommend that you do not run multiple create and rebuild index commands at the same time as you may run into performance and memory issues.</span></span>  
  
 <span data-ttu-id="c893e-176">Quando in SQL Server viene eseguito l'ordinamento per compilare indici partizionati, viene innanzitutto creata una tabella di ordinamento per ciascuna partizione.</span><span class="sxs-lookup"><span data-stu-id="c893e-176">When SQL Server performs sorting to build partitioned indexes, it first builds one sort table for each partition.</span></span> <span data-ttu-id="c893e-177">Vengono quindi compilate le tabelle di ordinamento nel rispettivo filegroup di ogni partizione oppure in `tempdb`, se è specificata l'opzione di indice SORT_IN_TEMPDB.</span><span class="sxs-lookup"><span data-stu-id="c893e-177">It then builds the sort tables either in the respective filegroup of each partition or in `tempdb`, if the SORT_IN_TEMPDB index option is specified.</span></span> <span data-ttu-id="c893e-178">Per poter compilare una tabella di ordinamento, è necessaria una quantità di memoria minima che varia in base alla tabella.</span><span class="sxs-lookup"><span data-stu-id="c893e-178">Each sort table requires a minimum amount of memory to build.</span></span> <span data-ttu-id="c893e-179">Quando si compila un indice partizionato allineato alla relativa tabella di base, le tabelle di ordinamento vengono compilate una alla volta e la quantità di memoria necessaria è minore.</span><span class="sxs-lookup"><span data-stu-id="c893e-179">When you are building a partitioned index that is aligned with its base table, sort tables are built one at a time, using less memory.</span></span> <span data-ttu-id="c893e-180">Quando invece si compila un indice partizionato non allineato, le tabelle di ordinamento vengono compilate simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="c893e-180">However, when you are building a nonaligned partitioned index, the sort tables are built at the same time.</span></span> <span data-ttu-id="c893e-181">È pertanto necessaria una quantità di memoria sufficiente a gestire simultaneamente tali ordinamenti.</span><span class="sxs-lookup"><span data-stu-id="c893e-181">As a result, there must be sufficient memory to handle these concurrent sorts.</span></span> <span data-ttu-id="c893e-182">Maggiore è il numero di partizioni e maggiore sarà la quantità di memoria necessaria.</span><span class="sxs-lookup"><span data-stu-id="c893e-182">The larger the number of partitions, the more memory required.</span></span> <span data-ttu-id="c893e-183">La dimensione minima di ogni tabella di ordinamento per ogni partizione è di 40 pagine, ognuna delle quali contiene 8 kilobyte.</span><span class="sxs-lookup"><span data-stu-id="c893e-183">The minimum size for each sort table, for each partition, is 40 pages, with 8 kilobytes per page.</span></span> <span data-ttu-id="c893e-184">Ad esempio, per un indice partizionato non allineato con 100 partizioni è necessaria una quantità di memoria sufficiente per ordinare simultaneamente in modo seriale 4.000 (40 \* 100) pagine.</span><span class="sxs-lookup"><span data-stu-id="c893e-184">For example, a nonaligned partitioned index with 100 partitions requires sufficient memory to serially sort 4,000 (40 \* 100) pages at the same time.</span></span> <span data-ttu-id="c893e-185">Se la memoria è disponibile, l'indice verrà compilato anche se è possibile che l'operazione influisca negativamente sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="c893e-185">If this memory is available, the build operation will succeed, but performance may suffer.</span></span> <span data-ttu-id="c893e-186">Se la memoria non è disponibile, l'indice non verrà compilato.</span><span class="sxs-lookup"><span data-stu-id="c893e-186">If this memory is not available, the build operation will fail.</span></span> <span data-ttu-id="c893e-187">Per un indice partizionato allineato con 100 partizioni è invece necessaria solo la memoria per l'ordinamento di 40 pagine, perché gli ordinamenti non vengono eseguiti simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="c893e-187">Alternatively, an aligned partitioned index with 100 partitions requires only sufficient memory to sort 40 pages, because the sorts are not performed at the same time.</span></span>  
  
 <span data-ttu-id="c893e-188">È possibile che i requisiti di memoria per gli indici allineati e non allineati siamo maggiori se SQL Server applica gradi di parallelismo alla compilazione in un computer multiprocessore.</span><span class="sxs-lookup"><span data-stu-id="c893e-188">For both aligned and nonaligned indexes, the memory requirement can be greater if SQL Server is applying degrees of parallelism to the build operation on a multiprocessor computer.</span></span> <span data-ttu-id="c893e-189">Ciò dipende dal fatto che maggiori sono i gradi di parallelismo, maggiore sarà la quantità di memoria richiesta.</span><span class="sxs-lookup"><span data-stu-id="c893e-189">This is because the greater the degrees of parallelism, the greater the memory requirement.</span></span> <span data-ttu-id="c893e-190">Se ad esempio SQL Server imposta i gradi di parallelismo su 4, per un indice partizionato non allineato con 100 partizioni sarà necessaria una quantità di memoria che consenta a quattro processori di ordinare simultaneamente 4.000 pagine, ovvero 16.000 pagine in totale.</span><span class="sxs-lookup"><span data-stu-id="c893e-190">For example, if SQL Server sets degrees of parallelism to 4, a nonaligned partitioned index with 100 partitions requires sufficient memory for four processors to sort 4,000 pages at the same time, or 16,000 pages.</span></span> <span data-ttu-id="c893e-191">Se l'indice partizionato è allineato, la quantità di memoria si riduce alla quantità necessaria a quattro processori per ordinare 40 pagine, ovvero 160 (4 \* 40) pagine.</span><span class="sxs-lookup"><span data-stu-id="c893e-191">If the partitioned index is aligned, the memory requirement is reduced to four processors sorting 40 pages, or 160 (4 \* 40) pages.</span></span> <span data-ttu-id="c893e-192">Per ridurre manualmente i gradi di parallelismo, è possibile utilizzare l'opzione di indice MAXDOP.</span><span class="sxs-lookup"><span data-stu-id="c893e-192">You can use the MAXDOP index option to manually reduce the degrees of parallelism.</span></span>  
  
### <a name="dbcc-commands"></a><span data-ttu-id="c893e-193">Comandi DBCC</span><span class="sxs-lookup"><span data-stu-id="c893e-193">DBCC Commands</span></span>  
 <span data-ttu-id="c893e-194">In presenza di un numero elevato di partizioni, l'esecuzione di comandi DBCC può richiedere un tempo proporzionalmente maggiore.</span><span class="sxs-lookup"><span data-stu-id="c893e-194">With a larger number of partitions, DBCC commands could take longer to execute as the number of partitions increases.</span></span>  
  
### <a name="queries"></a><span data-ttu-id="c893e-195">Query</span><span class="sxs-lookup"><span data-stu-id="c893e-195">Queries</span></span>  
 <span data-ttu-id="c893e-196">Le query per le quali si utilizza l'eliminazione di partizioni possono offrire prestazioni analoghe o migliorate con un numero elevato di partizioni.</span><span class="sxs-lookup"><span data-stu-id="c893e-196">Queries that use partition elimination could have comparable or improved performance with larger number of partitions.</span></span> <span data-ttu-id="c893e-197">L'esecuzione di query che non utilizzano l'eliminazione di partizioni può richiedere più tempo a seconda del numero di partizioni.</span><span class="sxs-lookup"><span data-stu-id="c893e-197">Queries that do not use partition elimination could take longer to execute as the number of partitions increases.</span></span>  
  
 <span data-ttu-id="c893e-198">Si supponga ad esempio che una tabella contenga 100 milioni di righe e le colonne `A`, `B`e `C`.</span><span class="sxs-lookup"><span data-stu-id="c893e-198">For example, assume a table has 100 million rows and columns `A`, `B`, and `C`.</span></span> <span data-ttu-id="c893e-199">Nello scenario 1 la tabella è divisa in 1000 partizioni per la colonna `A`.</span><span class="sxs-lookup"><span data-stu-id="c893e-199">In scenario 1, the table is divided into 1000 partitions on column `A`.</span></span> <span data-ttu-id="c893e-200">Nello scenario 2, la tabella è divisa in 10.000 partizioni per la colonna `A`.</span><span class="sxs-lookup"><span data-stu-id="c893e-200">In scenario 2, the table is divided into 10,000 partitions on column `A`.</span></span> <span data-ttu-id="c893e-201">Una query eseguita su tale tabella con clausola WHERE per filtrare la colonna `A` utilizza l'eliminazione di partizioni ed analizza una partizione.</span><span class="sxs-lookup"><span data-stu-id="c893e-201">A query on the table that has a WHERE clause filtering on column `A` will perform partition elimination and scan one partition.</span></span> <span data-ttu-id="c893e-202">Se eseguita nello scenario 2, la stessa query risulta più rapida in quanto è presente un numero minore di righe da analizzare in una partizione.</span><span class="sxs-lookup"><span data-stu-id="c893e-202">That same query may run faster in scenario 2 as there are fewer rows to scan in a partition.</span></span> <span data-ttu-id="c893e-203">Una query con clausola WHERE per filtrare la colonna B analizza tutte le partizioni.</span><span class="sxs-lookup"><span data-stu-id="c893e-203">A query that has a WHERE clause filtering on column B will scan all partitions.</span></span> <span data-ttu-id="c893e-204">Nello scenario 1, tale query viene eseguita in meno tempo rispetto allo scenario 2 in quanto sono presenti meno partizioni da analizzare.</span><span class="sxs-lookup"><span data-stu-id="c893e-204">The query may run faster in scenario 1 than in scenario 2 as there are fewer partitions to scan.</span></span>  
  
 <span data-ttu-id="c893e-205">Le query che utilizzano operatori quali TOP o MAX/MIN su colonne diverse dalla colonna di partizionamento possono comportare prestazioni ridotte con il partizionamento perché tutte le partizioni devono essere valutate.</span><span class="sxs-lookup"><span data-stu-id="c893e-205">Queries that use operators such as TOP or MAX/MIN on columns other than the partitioning column may experience reduced performance with partitioning because all partitions must be evaluated.</span></span>  
  
## <a name="behavior-changes-in-statistics-computation-during-partitioned-index-operations"></a><span data-ttu-id="c893e-206">Modifiche di comportamento nel calcolo delle statistiche durante operazioni su indici partizionati</span><span class="sxs-lookup"><span data-stu-id="c893e-206">Behavior Changes in Statistics Computation During Partitioned Index Operations</span></span>  
 <span data-ttu-id="c893e-207">A partire da [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)]le statistiche non vengono create analizzando tutte le righe nella tabella se viene creato o ricompilato un indice partizionato.</span><span class="sxs-lookup"><span data-stu-id="c893e-207">Beginning with [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], statistics are not created by scanning all the rows in the table when a partitioned index is created or rebuilt.</span></span> <span data-ttu-id="c893e-208">Query Optimizer utilizza invece l'algoritmo di campionamento predefinito per generare statistiche.</span><span class="sxs-lookup"><span data-stu-id="c893e-208">Instead, the query optimizer uses the default sampling algorithm to generate statistics.</span></span> <span data-ttu-id="c893e-209">Dopo avere aggiornato un database con gli indici partizionati, è possibile notare una differenza nei dati dell'istogramma relativamente a tali indici.</span><span class="sxs-lookup"><span data-stu-id="c893e-209">After upgrading a database with partitioned indexes, you may notice a difference in the histogram data for these indexes.</span></span> <span data-ttu-id="c893e-210">Tale cambiamento potrebbe non influire sulle prestazioni di query.</span><span class="sxs-lookup"><span data-stu-id="c893e-210">This change in behavior may not affect query performance.</span></span> <span data-ttu-id="c893e-211">Per ottenere statistiche sugli indici partizionati analizzando tutte le righe nella tabella, utilizzare CREATE STATISTICS o UPDATE STATISTICS con la clausola FULLSCAN.</span><span class="sxs-lookup"><span data-stu-id="c893e-211">To obtain statistics on partitioned indexes by scanning all the rows in the table, use CREATE STATISTICS or UPDATE STATISTICS with the FULLSCAN clause.</span></span>  
  
## <a name="related-tasks"></a><span data-ttu-id="c893e-212">Attività correlate</span><span class="sxs-lookup"><span data-stu-id="c893e-212">Related Tasks</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c893e-213">**Attività**</span><span class="sxs-lookup"><span data-stu-id="c893e-213">**Tasks**</span></span>|<span data-ttu-id="c893e-214">**Argomento**</span><span class="sxs-lookup"><span data-stu-id="c893e-214">**Topic**</span></span>|  
|<span data-ttu-id="c893e-215">Viene illustrato come creare funzioni e schemi di partizione e quindi applicarli a una tabella e a un indice.</span><span class="sxs-lookup"><span data-stu-id="c893e-215">Describes how to create partition functions and partition schemes and then apply these to a table and index.</span></span>|[<span data-ttu-id="c893e-216">Creare tabelle e indici partizionati</span><span class="sxs-lookup"><span data-stu-id="c893e-216">Create Partitioned Tables and Indexes</span></span>](create-partitioned-tables-and-indexes.md)|  
|||  
  
## <a name="related-content"></a><span data-ttu-id="c893e-217">Contenuto correlato</span><span class="sxs-lookup"><span data-stu-id="c893e-217">Related Content</span></span>  
 <span data-ttu-id="c893e-218">I seguenti white paper sulle strategie e le implementazioni relative a tabelle e indici partizionati possono risultare particolarmente utili (le informazioni potrebbero essere in lingua inglese).</span><span class="sxs-lookup"><span data-stu-id="c893e-218">You may find the following white papers on partitioned table and index strategies and implementations useful.</span></span>  
  
-   <span data-ttu-id="c893e-219">[Strategie relative a tabelle e indici partizionati in SQL Server 2008](https://msdn.microsoft.com/library/dd578580\(SQL.100\).aspx)</span><span class="sxs-lookup"><span data-stu-id="c893e-219">[Partitioned Table and Index Strategies Using SQL Server 2008](https://msdn.microsoft.com/library/dd578580\(SQL.100\).aspx)</span></span>  
  
-   <span data-ttu-id="c893e-220">[Come implementare una finestra temporale scorrevole automatica](https://msdn.microsoft.com/library/aa964122\(SQL.90\).aspx)</span><span class="sxs-lookup"><span data-stu-id="c893e-220">[How to Implement an Automatic Sliding Window](https://msdn.microsoft.com/library/aa964122\(SQL.90\).aspx)</span></span>  
  
-   [<span data-ttu-id="c893e-221">Caricamento bulk in una tabella partizionata</span><span class="sxs-lookup"><span data-stu-id="c893e-221">Bulk Loading into a Partitioned Table</span></span>](https://msdn.microsoft.com/library/cc966380.aspx)  
  
-   [<span data-ttu-id="c893e-222">Miglioramenti apportati all'elaborazione di query su tabelle e indici partizionati</span><span class="sxs-lookup"><span data-stu-id="c893e-222">Query Processing Enhancements on Partitioned Tables and Indexes</span></span>](https://msdn.microsoft.com/library/ms345599.aspx)  
  
-   [<span data-ttu-id="c893e-223">Post di blog Prime 10 procedure consigliate per la creazione di un data warehouse relazionale di dimensioni elevate</span><span class="sxs-lookup"><span data-stu-id="c893e-223">Top 10 Best Practices for Building a Large Scale Relational Data Warehouse</span></span>](http://sqlcat.com/top10lists/archive/2008/02/06/top-10-best-practices-for-building-a-large-scale-relational-data-warehouse.aspx)  
  
  
