---
title: Tipi di dati XPath (SQLXML 4,0) | Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: reference
helpviewer_keywords:
- mapping XDR types to XPath types [SQLXML]
- data types [XPath]
- arithmetic operators
- mapping data types [SQLXML]
- relational operators [SQLXML]
- node-set [SQLXML]
- data types [SQLXML], XPath
- XPath operators [SQLXML]
- XDR data type [SQLXML]
- equality operators [SQLXML]
- XPath conversions [SQLXML]
- converting data types [SQLXML]
- Boolean operators
- XPath queries [SQLXML], data types
- XPath data types [SQLXML]
- operators [SQLXML]
ms.assetid: a90374bf-406f-4384-ba81-59478017db68
author: rothja
ms.author: jroth
ms.openlocfilehash: 846fc5a17ac97d30b6f0ab65fee176ac459c20cc
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/04/2020
ms.locfileid: "87634944"
---
# <a name="xpath-data-types-sqlxml-40"></a><span data-ttu-id="58476-102">Tipi di dati XPath (SQLXML 4.0)</span><span class="sxs-lookup"><span data-stu-id="58476-102">XPath Data Types (SQLXML 4.0)</span></span>
  [!INCLUDE[msCoName](../../includes/msconame-md.md)]<span data-ttu-id="58476-103">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], XPath e XML Schema (XSD) hanno tipi di dati molto diversi.</span><span class="sxs-lookup"><span data-stu-id="58476-103">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], XPath, and XML Schema (XSD) have very different data types.</span></span> <span data-ttu-id="58476-104">XPath, ad esempio, non include tipi di dati integer o di data, mentre [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] e XSD ne includono diversi.</span><span class="sxs-lookup"><span data-stu-id="58476-104">For example, XPath does not have integer or date data types, but [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] and XSD have many.</span></span> <span data-ttu-id="58476-105">XSD utilizza una precisione in nanosecondi per i valori di ora, mentre [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] utilizza al massimo una precisione di 1/300 secondi.</span><span class="sxs-lookup"><span data-stu-id="58476-105">XSD uses nanosecond precision for time values, and [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] uses at most 1/300-second precision.</span></span> <span data-ttu-id="58476-106">Di conseguenza, il mapping di un tipo di dati a un altro non è sempre possibile.</span><span class="sxs-lookup"><span data-stu-id="58476-106">Consequently, mapping one data type to another is not always possible.</span></span> <span data-ttu-id="58476-107">Per ulteriori informazioni sul mapping [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] dei tipi di dati ai tipi di dati XSD, vedere [coercizione del tipo di dati e l'annotazione sql: DataType &#40;SQLXML 4,0&#41;](../sqlxml-annotated-xsd-schemas-using/data-type-coercions-and-the-sql-datatype-annotation-sqlxml-4-0.md).</span><span class="sxs-lookup"><span data-stu-id="58476-107">For more information about mapping [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] data types to XSD data types, see [Data Type Coercions and the sql:datatype Annotation &#40;SQLXML 4.0&#41;](../sqlxml-annotated-xsd-schemas-using/data-type-coercions-and-the-sql-datatype-annotation-sqlxml-4-0.md).</span></span>  
  
 <span data-ttu-id="58476-108">XPath utilizza tre tipi di dati: `string`, `number` e `boolean`.</span><span class="sxs-lookup"><span data-stu-id="58476-108">XPath has three data types: `string`, `number`, and `boolean`.</span></span> <span data-ttu-id="58476-109">Il tipo di dati `number` corrisponde sempre a un valore IEEE 754 a virgola mobile con precisione doppia.</span><span class="sxs-lookup"><span data-stu-id="58476-109">The `number` data type is always an IEEE 754 double-precision floating-point.</span></span> <span data-ttu-id="58476-110">Il [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] `float(53)` tipo di dati è il più vicino a XPath `number` .</span><span class="sxs-lookup"><span data-stu-id="58476-110">The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]`float(53)` data type is the closest to XPath `number`.</span></span> <span data-ttu-id="58476-111">`float(53)`, tuttavia, non è esattamente un valore IEEE 754.</span><span class="sxs-lookup"><span data-stu-id="58476-111">However, `float(53)` is not exactly IEEE 754.</span></span> <span data-ttu-id="58476-112">Ad esempio, non viene utilizzato né un valore diverso da un numero (NaN, Not-a-Number) né un valore infinito.</span><span class="sxs-lookup"><span data-stu-id="58476-112">For example, neither NaN (Not-a-Number) nor infinity is used.</span></span> <span data-ttu-id="58476-113">Eventuali tentativi di convertire una stringa non numerica in `number` e di dividere per zero restituiscono un errore.</span><span class="sxs-lookup"><span data-stu-id="58476-113">Attempting to convert a nonnumeric string to `number` and trying to divide by zero results in an error.</span></span>  
  
## <a name="xpath-conversions"></a><span data-ttu-id="58476-114">Conversioni XPath</span><span class="sxs-lookup"><span data-stu-id="58476-114">XPath Conversions</span></span>  
 <span data-ttu-id="58476-115">Quando si utilizza una query XPath, ad esempio `OrderDetail[@UnitPrice > "10.0"]`, le conversioni dei tipi di dati implicite ed esplicite possono modificare impercettibilmente il significato della query.</span><span class="sxs-lookup"><span data-stu-id="58476-115">When you use an XPath query such as `OrderDetail[@UnitPrice > "10.0"]`, implicit and explicit data type conversions can change the meaning of the query in subtle ways.</span></span> <span data-ttu-id="58476-116">È pertanto importante comprendere le modalità di implementazione dei tipi di dati XPath.</span><span class="sxs-lookup"><span data-stu-id="58476-116">Therefore, it is important to understand how XPath data types are implemented.</span></span> <span data-ttu-id="58476-117">Le specifiche del linguaggio XPath, XML Path Language (XPath) versione 1,0 W3C proposed Recommendation 8 ottobre 1999, sono reperibili nel sito Web W3C all'indirizzo http://www.w3.org/TR/1999/PR-xpath-19991008.html .</span><span class="sxs-lookup"><span data-stu-id="58476-117">The XPath language specification, XML Path Language (XPath) version 1.0 W3C Proposed Recommendation 8 October 1999, can be found at the W3C Web site at http://www.w3.org/TR/1999/PR-xpath-19991008.html.</span></span>  
  
 <span data-ttu-id="58476-118">Gli operatori XPath sono suddivisi in quattro categorie:</span><span class="sxs-lookup"><span data-stu-id="58476-118">XPath operators are divided into four categories:</span></span>  
  
-   <span data-ttu-id="58476-119">Operatori booleani (and, or)</span><span class="sxs-lookup"><span data-stu-id="58476-119">Boolean operators (and, or)</span></span>  
  
-   <span data-ttu-id="58476-120">Operatori relazionali ( \<, > , \<=, > =)</span><span class="sxs-lookup"><span data-stu-id="58476-120">Relational operators (\<, >, \<=, >=)</span></span>  
  
-   <span data-ttu-id="58476-121">Operatori di uguaglianza (=, !=)</span><span class="sxs-lookup"><span data-stu-id="58476-121">Equality operators (=, !=)</span></span>  
  
-   <span data-ttu-id="58476-122">Operatori aritmetici: (+, -, \*, div, mod)</span><span class="sxs-lookup"><span data-stu-id="58476-122">Arithmetic operators (+, -, \*, div, mod)</span></span>  
  
 <span data-ttu-id="58476-123">Ogni categoria di operatore converte in modo diverso gli operandi.</span><span class="sxs-lookup"><span data-stu-id="58476-123">Each category of operator converts its operands differently.</span></span> <span data-ttu-id="58476-124">Se necessario, gli operatori XPath convertono gli operandi in modo implicito.</span><span class="sxs-lookup"><span data-stu-id="58476-124">XPath operators implicitly convert their operands if necessary.</span></span> <span data-ttu-id="58476-125">Gli operatori aritmetici convertono gli operandi in `number` e restituiscono un valore numerico.</span><span class="sxs-lookup"><span data-stu-id="58476-125">Arithmetic operators convert their operands to `number`, and result in a number value.</span></span> <span data-ttu-id="58476-126">Gli operatori booleani convertono gli operandi in `boolean` e restituiscono un valore booleano.</span><span class="sxs-lookup"><span data-stu-id="58476-126">Boolean operators convert their operands to `boolean`, and result in a Boolean value.</span></span> <span data-ttu-id="58476-127">Gli operatori relazionali e gli operatori di uguaglianza restituiscono un valore booleano,</span><span class="sxs-lookup"><span data-stu-id="58476-127">Relational operators and equality operators result in a Boolean value.</span></span> <span data-ttu-id="58476-128">ma utilizzano regole di conversione diverse a seconda dei tipi di dati originali degli operandi, come illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="58476-128">However, they have different conversion rules depending on the original data types of their operands, as shown in this table.</span></span>  
  
|<span data-ttu-id="58476-129">Operando</span><span class="sxs-lookup"><span data-stu-id="58476-129">Operand</span></span>|<span data-ttu-id="58476-130">Operatore relazionale</span><span class="sxs-lookup"><span data-stu-id="58476-130">Relational operator</span></span>|<span data-ttu-id="58476-131">Operatore di uguaglianza</span><span class="sxs-lookup"><span data-stu-id="58476-131">Equality operator</span></span>|  
|-------------|-------------------------|-----------------------|  
|<span data-ttu-id="58476-132">Entrambi gli operandi sono set di nodi.</span><span class="sxs-lookup"><span data-stu-id="58476-132">Both operands are node-sets.</span></span>|<span data-ttu-id="58476-133">TRUE solo se è presente un nodo in un set e un nodo nel secondo set in modo tale che il confronto dei rispettivi valori `string` sia TRUE.</span><span class="sxs-lookup"><span data-stu-id="58476-133">TRUE if and only if there is a node in one set and a node in the second set such that the comparison of their `string` values is TRUE.</span></span>|<span data-ttu-id="58476-134">Idem</span><span class="sxs-lookup"><span data-stu-id="58476-134">Same.</span></span>|  
|<span data-ttu-id="58476-135">Uno è un set di nodi, l'altro è un valore `string`.</span><span class="sxs-lookup"><span data-stu-id="58476-135">One is a node-set, the other a `string`.</span></span>|<span data-ttu-id="58476-136">TRUE solo se è presente un nodo nel set di nodi in modo tale che, se convertito in `number`, il confronto con il valore `string` convertito in `number` sia TRUE.</span><span class="sxs-lookup"><span data-stu-id="58476-136">TRUE if and only if there is a node in the node-set such that when converted to `number`, the comparison of it with the `string` converted to `number` is TRUE.</span></span>|<span data-ttu-id="58476-137">TRUE solo se è presente un nodo nel set di nodi in modo tale che, se convertito in `string`, il confronto con il valore `string` sia TRUE.</span><span class="sxs-lookup"><span data-stu-id="58476-137">TRUE if and only if there is a node in the node-set such that when converted to `string`, the comparison of it with the `string` is TRUE.</span></span>|  
|<span data-ttu-id="58476-138">Uno è un set di nodi, l'altro è un valore `number`.</span><span class="sxs-lookup"><span data-stu-id="58476-138">One is a node-set, the other a `number`.</span></span>|<span data-ttu-id="58476-139">TRUE solo se è presente un nodo nel set di nodi in modo tale che, se convertito in `number`, il confronto con il valore `number` sia TRUE.</span><span class="sxs-lookup"><span data-stu-id="58476-139">TRUE if and only if there is a node in the node-set such that when converted to `number`, the comparison of it with the `number` is TRUE.</span></span>|<span data-ttu-id="58476-140">Idem</span><span class="sxs-lookup"><span data-stu-id="58476-140">Same.</span></span>|  
|<span data-ttu-id="58476-141">Uno è un set di nodi, l'altro è un valore `boolean`.</span><span class="sxs-lookup"><span data-stu-id="58476-141">One is a node-set, the other a `boolean`.</span></span>|<span data-ttu-id="58476-142">TRUE solo se è presente un nodo nel set di nodi in modo tale che, se convertito in `boolean` e quindi in `number`, il confronto con il valore `boolean` convertito in `number` sia TRUE.</span><span class="sxs-lookup"><span data-stu-id="58476-142">TRUE if and only if there is a node in the node-set such that when converted to `boolean` and then to `number`, the comparison of it with the `boolean` converted to `number` is TRUE.</span></span>|<span data-ttu-id="58476-143">TRUE solo se è presente un nodo nel set di nodi in modo tale che, se convertito in `boolean`, il confronto con il valore `boolean` sia TRUE.</span><span class="sxs-lookup"><span data-stu-id="58476-143">TRUE if and only if there is a node in the node-set such that when converted to `boolean`, the comparison of it with the `boolean` is TRUE.</span></span>|  
|<span data-ttu-id="58476-144">Nessuno è un set di nodi.</span><span class="sxs-lookup"><span data-stu-id="58476-144">Neither is a node-set.</span></span>|<span data-ttu-id="58476-145">Convertire entrambi gli operandi in `number` e quindi eseguire il confronto.</span><span class="sxs-lookup"><span data-stu-id="58476-145">Convert both operands to `number` and then compare.</span></span>|<span data-ttu-id="58476-146">Convertire entrambi gli operandi in un tipo comune e quindi eseguire il confronto.</span><span class="sxs-lookup"><span data-stu-id="58476-146">Convert both operands to a common type and then compare.</span></span> <span data-ttu-id="58476-147">Convertire in `boolean` se uno degli operandi è `boolean`, in `number` se uno degli operandi è `number`; in caso contrario, convertire in `string`.</span><span class="sxs-lookup"><span data-stu-id="58476-147">Convert to `boolean` if either is `boolean`, `number` if either is `number`; otherwise, convert to `string`.</span></span>|  
  
> [!NOTE]  
>  <span data-ttu-id="58476-148">Poiché gli operatori relazionali XPath convertono sempre gli operandi in `number`, i confronti `string` non sono possibili.</span><span class="sxs-lookup"><span data-stu-id="58476-148">Because XPath relational operators always convert their operands to `number`, `string` comparisons are not possible.</span></span> <span data-ttu-id="58476-149">Per includere confronti relativi alla data, in SQL Server 2000 è disponibile una variazione alla specifica XPath: quando un operatore relazionale confronta un valore `string` con un valore `string`, un set di nodi con un valore `string` o un set di nodi che restituisce una stringa con un altro set di nodi che restituisce una stringa, viene eseguito un confronto `string` e non un confronto `number`.</span><span class="sxs-lookup"><span data-stu-id="58476-149">To include date comparisons, SQL Server 2000 offers this variation to the XPath specification: When a relational operator compares a `string` to a `string`, a node-set to a `string`, or a string-valued node-set to a string-valued node-set, a `string` comparison (not a `number` comparison) is performed.</span></span>  
  
## <a name="node-set-conversions"></a><span data-ttu-id="58476-150">Conversioni dei set di nodi</span><span class="sxs-lookup"><span data-stu-id="58476-150">Node-Set Conversions</span></span>  
 <span data-ttu-id="58476-151">Le conversioni dei set di nodi non sono sempre intuitive.</span><span class="sxs-lookup"><span data-stu-id="58476-151">Node-set conversions are not always intuitive.</span></span> <span data-ttu-id="58476-152">Un set di nodi viene convertito in un tipo `string` assumendo il valore stringa solo del primo nodo nel set.</span><span class="sxs-lookup"><span data-stu-id="58476-152">A node-set is converted to a `string` by taking the string value of only the first node in the set.</span></span> <span data-ttu-id="58476-153">Un set di nodi viene convertito in `number` tramite la conversione in `string` e quindi convertendo `string` in `number`.</span><span class="sxs-lookup"><span data-stu-id="58476-153">A node-set is converted to `number` by converting it to `string`, and then converting `string` to `number`.</span></span> <span data-ttu-id="58476-154">Un set di nodi viene convertito in `boolean` verificandone l'esistenza.</span><span class="sxs-lookup"><span data-stu-id="58476-154">A node-set is converted to `boolean` by testing for its existence.</span></span>  
  
> [!NOTE]  
>  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="58476-155">non esegue la selezione della posizione nei set di nodi: la query XPath `Customer[3]`, ad esempio, indica il terzo cliente. Questo tipo di selezione della posizione non è supportato in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="58476-155">does not perform positional selection on node-sets: for example, the XPath query `Customer[3]` means the third customer; this type of positional selection is not supported in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="58476-156">Pertanto, le conversioni node-set-to-`string` o node-set-to-`number` come descritto dalla specifica XPath non sono implementate.</span><span class="sxs-lookup"><span data-stu-id="58476-156">Therefore, the node-set-to-`string` or node-set-to-`number` conversions as described by the XPath specification are not implemented.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="58476-157">utilizza le semantiche "any" dove la specifica XPath specifica la semantica "first".</span><span class="sxs-lookup"><span data-stu-id="58476-157">uses "any" semantics wherever the XPath specification specifies "first" semantics.</span></span> <span data-ttu-id="58476-158">Ad esempio, in base alla specifica XPath W3C, la query XPath `Order[OrderDetail/@UnitPrice > 10.0]` Seleziona gli ordini con il primo **OrderDetail** con un **PrezzoUnitario** maggiore di 10,0.</span><span class="sxs-lookup"><span data-stu-id="58476-158">For example, based on the W3C XPath specification, the XPath query `Order[OrderDetail/@UnitPrice > 10.0]` selects those orders with the first **OrderDetail** that has a **UnitPrice** greater than 10.0.</span></span> <span data-ttu-id="58476-159">In [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] questa query XPath seleziona gli ordini con qualsiasi **OrderDetail** con un **PrezzoUnitario** maggiore di 10,0.</span><span class="sxs-lookup"><span data-stu-id="58476-159">In [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], this XPath query selects those orders with any **OrderDetail** that has a **UnitPrice** greater than 10.0.</span></span>  
  
 <span data-ttu-id="58476-160">La conversione in `boolean` genera un test di esistenza e, pertanto, la query XPath `Products[@Discontinued=true()]` equivale all'espressione SQL "Products.Discontinued is not null", non all'espressione SQL "Products.Discontinued = 1".</span><span class="sxs-lookup"><span data-stu-id="58476-160">Conversion to `boolean` generates an existence test; therefore, the XPath query `Products[@Discontinued=true()]` is equivalent to the SQL expression "Products.Discontinued is not null", not the SQL expression "Products.Discontinued = 1".</span></span> <span data-ttu-id="58476-161">Per rendere la query equivalente all'espressione SQL successiva, convertire innanzitutto il set di nodi in un tipo non `boolean`, ad esempio `number`.</span><span class="sxs-lookup"><span data-stu-id="58476-161">To make the query equivalent to the latter SQL expression, first convert the node-set to a non-`boolean` type, such as `number`.</span></span> <span data-ttu-id="58476-162">Ad esempio: `Products[number(@Discontinued) = true()]`.</span><span class="sxs-lookup"><span data-stu-id="58476-162">For example, `Products[number(@Discontinued) = true()]`.</span></span>  
  
 <span data-ttu-id="58476-163">Poiché la maggior parte degli operatori viene definita come TRUE se gli operatori sono TRUE per tutti i nodi nel set di nodi o per uno di essi, queste operazioni restituiscono sempre FALSE se il set di nodi è vuoto.</span><span class="sxs-lookup"><span data-stu-id="58476-163">Because most operators are defined to be TRUE if they are TRUE for any or one of the nodes in the node-set, these operations always evaluate to FALSE if the node-set is empty.</span></span> <span data-ttu-id="58476-164">In questo modo, se A è vuoto, sia `A = B` sia `A != B` sono FALSE e `not(A=B)` e `not(A!=B)` sono TRUE.</span><span class="sxs-lookup"><span data-stu-id="58476-164">Thus, if A is empty, both `A = B` and `A != B` are FALSE, and `not(A=B)` and `not(A!=B)` are TRUE.</span></span>  
  
 <span data-ttu-id="58476-165">In genere è presente un attributo o un elemento con mapping a una colonna se il valore della colonna nel database non è `null`.</span><span class="sxs-lookup"><span data-stu-id="58476-165">Usually, an attribute or element that maps to a column exists if the value of that column in the database is not `null`.</span></span> <span data-ttu-id="58476-166">Sono presenti elementi di cui è stato eseguito il mapping a righe se è presente uno qualunque dei figli.</span><span class="sxs-lookup"><span data-stu-id="58476-166">Elements that map to rows exist if any of their children exist.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="58476-167">Gli elementi annotati con `is-constant` sono sempre presenti.</span><span class="sxs-lookup"><span data-stu-id="58476-167">Elements annotated with `is-constant` always exist.</span></span> <span data-ttu-id="58476-168">Di conseguenza, i predicati XPath non possono essere utilizzati in elementi `is-constant`.</span><span class="sxs-lookup"><span data-stu-id="58476-168">Consequently, XPath predicates cannot be used on `is-constant` elements.</span></span>  
  
 <span data-ttu-id="58476-169">Quando un set di nodi viene convertito in `string` o `number`, il tipo XDR (se presente) viene controllato nello schema con annotazioni e viene utilizzato per determinare la conversione necessaria.</span><span class="sxs-lookup"><span data-stu-id="58476-169">When a node-set is converted to `string` or `number`, its XDR type (if any) is inspected in the annotated schema and that type is used to determine the conversion that is required.</span></span>  
  
## <a name="mapping-xdr-data-types-to-xpath-data-types"></a><span data-ttu-id="58476-170">Mapping di tipi di dati XDR a tipi di dati XPath</span><span class="sxs-lookup"><span data-stu-id="58476-170">Mapping XDR Data Types to XPath Data Types</span></span>  
 <span data-ttu-id="58476-171">Il tipo di dati XPath di un nodo viene derivato dal tipo di dati XDR nello schema, come illustrato nella tabella seguente (il nodo **EmployeeID** viene utilizzato a scopo illustrativo).</span><span class="sxs-lookup"><span data-stu-id="58476-171">The XPath data type of a node is derived from the XDR data type in the schema, as shown in the following table (the node **EmployeeID** is used for illustrative purpose).</span></span>  
  
|<span data-ttu-id="58476-172">Tipo di dati XDR</span><span class="sxs-lookup"><span data-stu-id="58476-172">XDR data type</span></span>|<span data-ttu-id="58476-173">Equivalente</span><span class="sxs-lookup"><span data-stu-id="58476-173">Equivalent</span></span><br /><br /> <span data-ttu-id="58476-174">Tipo di dati XPath</span><span class="sxs-lookup"><span data-stu-id="58476-174">XPath data type</span></span>|<span data-ttu-id="58476-175">Conversione SQL Server utilizzata</span><span class="sxs-lookup"><span data-stu-id="58476-175">SQL Server conversion used</span></span>|  
|-------------------|------------------------------------|--------------------------------|  
|<span data-ttu-id="58476-176">Nonebin.base64bin.hex</span><span class="sxs-lookup"><span data-stu-id="58476-176">Nonebin.base64bin.hex</span></span>|<span data-ttu-id="58476-177">N/D</span><span class="sxs-lookup"><span data-stu-id="58476-177">N/A</span></span>|<span data-ttu-id="58476-178">NoneEmployeeID</span><span class="sxs-lookup"><span data-stu-id="58476-178">NoneEmployeeID</span></span>|  
|<span data-ttu-id="58476-179">boolean</span><span class="sxs-lookup"><span data-stu-id="58476-179">boolean</span></span>|<span data-ttu-id="58476-180">boolean</span><span class="sxs-lookup"><span data-stu-id="58476-180">boolean</span></span>|<span data-ttu-id="58476-181">CONVERT(bit, EmployeeID)</span><span class="sxs-lookup"><span data-stu-id="58476-181">CONVERT(bit, EmployeeID)</span></span>|  
|<span data-ttu-id="58476-182">number, int, float, i1, i2, i4, i8,r4, r8ui1, ui2, ui4, ui8</span><span class="sxs-lookup"><span data-stu-id="58476-182">number, int, float,i1, i2, i4, i8,r4, r8ui1, ui2, ui4, ui8</span></span>|<span data-ttu-id="58476-183">Numero</span><span class="sxs-lookup"><span data-stu-id="58476-183">number</span></span>|<span data-ttu-id="58476-184">CONVERT(float(53), EmployeeID)</span><span class="sxs-lookup"><span data-stu-id="58476-184">CONVERT(float(53), EmployeeID)</span></span>|  
|<span data-ttu-id="58476-185">id, idref, idrefsentity, entities, enumerationnotation, nmtoken, nmtokens, chardate, Timedate, Time.tz, string, uri, uuid</span><span class="sxs-lookup"><span data-stu-id="58476-185">id, idref, idrefsentity, entities, enumerationnotation, nmtoken, nmtokens, chardate, Timedate, Time.tz, string, uri, uuid</span></span>|<span data-ttu-id="58476-186">string</span><span class="sxs-lookup"><span data-stu-id="58476-186">string</span></span>|<span data-ttu-id="58476-187">CONVERT(nvarchar(4000), EmployeeID, 126)</span><span class="sxs-lookup"><span data-stu-id="58476-187">CONVERT(nvarchar(4000), EmployeeID, 126)</span></span>|  
|<span data-ttu-id="58476-188">fixed14.4</span><span class="sxs-lookup"><span data-stu-id="58476-188">fixed14.4</span></span>|<span data-ttu-id="58476-189">N/D (in XPath non è disponibile alcun tipo di dati equivalente al tipo di dati XDR fixed14.4).</span><span class="sxs-lookup"><span data-stu-id="58476-189">N/A(There is no data type in XPath that is equivalent to the fixed14.4 XDR data type)</span></span>|<span data-ttu-id="58476-190">CONVERT(money, EmployeeID)</span><span class="sxs-lookup"><span data-stu-id="58476-190">CONVERT(money, EmployeeID)</span></span>|  
|<span data-ttu-id="58476-191">date</span><span class="sxs-lookup"><span data-stu-id="58476-191">date</span></span>|<span data-ttu-id="58476-192">string</span><span class="sxs-lookup"><span data-stu-id="58476-192">string</span></span>|<span data-ttu-id="58476-193">LEFT(CONVERT(nvarchar(4000), EmployeeID, 126), 10)</span><span class="sxs-lookup"><span data-stu-id="58476-193">LEFT(CONVERT(nvarchar(4000), EmployeeID, 126), 10)</span></span>|  
|<span data-ttu-id="58476-194">time</span><span class="sxs-lookup"><span data-stu-id="58476-194">time</span></span><br /><br /> <span data-ttu-id="58476-195">time.tz</span><span class="sxs-lookup"><span data-stu-id="58476-195">time.tz</span></span>|<span data-ttu-id="58476-196">string</span><span class="sxs-lookup"><span data-stu-id="58476-196">string</span></span>|<span data-ttu-id="58476-197">SUBSTRING(CONVERT(nvarchar(4000), EmployeeID, 126), 1 + CHARINDEX(N'T', CONVERT(nvarchar(4000), EmployeeID, 126)), 24)</span><span class="sxs-lookup"><span data-stu-id="58476-197">SUBSTRING(CONVERT(nvarchar(4000), EmployeeID, 126), 1 + CHARINDEX(N'T', CONVERT(nvarchar(4000), EmployeeID, 126)), 24)</span></span>|  
  
 <span data-ttu-id="58476-198">Le conversioni di data e ora sono progettate per funzionare se il valore viene archiviato nel database utilizzando il [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] `datetime` tipo di dati o `string` .</span><span class="sxs-lookup"><span data-stu-id="58476-198">The date and time conversions are designed to work whether the value is stored in the database using the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]`datetime` data type or a `string`.</span></span> <span data-ttu-id="58476-199">Si noti che il [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] `datetime` tipo di dati non utilizza `timezone` e ha una precisione minore rispetto al `time` tipo di dati XML.</span><span class="sxs-lookup"><span data-stu-id="58476-199">Note that the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]`datetime` data type does not use `timezone` and has a smaller precision than the XML `time` data type.</span></span> <span data-ttu-id="58476-200">Per includere il tipo di dati `timezone` o aggiungere ulteriore precisione, archiviare i dati in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] utilizzando un tipo `string`.</span><span class="sxs-lookup"><span data-stu-id="58476-200">To include the `timezone` data type or additional precision, store the data in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] using a `string` type.</span></span>  
  
 <span data-ttu-id="58476-201">Quando un nodo viene convertito dal relativo tipo di dati XDR al tipo di dati XPath, è talvolta necessaria un'ulteriore conversione (da un tipo di dati XPath a un altro tipo di dati XPath).</span><span class="sxs-lookup"><span data-stu-id="58476-201">When a node is converted from its XDR data type to the XPath data type, additional conversion is sometimes necessary (from one XPath data type to another XPath data type).</span></span> <span data-ttu-id="58476-202">Si consideri, ad esempio, la query XPath seguente:</span><span class="sxs-lookup"><span data-stu-id="58476-202">For example, consider this XPath query:</span></span>  
  
```  
(@m + 3) = 4  
```  
  
 <span data-ttu-id="58476-203">Se @m è del `fixed14.4` tipo di dati XDR, la conversione dal tipo di dati XDR al tipo di dati XPath viene eseguita utilizzando:</span><span class="sxs-lookup"><span data-stu-id="58476-203">If @m is of the `fixed14.4` XDR data type, the conversion from XDR data type to XPath data type is accomplished using:</span></span>  
  
```  
CONVERT(money, m)  
```  
  
 <span data-ttu-id="58476-204">In questa conversione il nodo `m` viene convertito da `fixed14.4` a `money`.</span><span class="sxs-lookup"><span data-stu-id="58476-204">In this conversion, the node `m` is converted from `fixed14.4` to `money`.</span></span> <span data-ttu-id="58476-205">Per aggiungere il valore 3, tuttavia, è necessaria un'ulteriore conversione:</span><span class="sxs-lookup"><span data-stu-id="58476-205">However, adding the value of 3, requires additional conversion:</span></span>  
  
```  
CONVERT(float(CONVERT(money, m))  
```  
  
 <span data-ttu-id="58476-206">L'espressione XPath viene valutata nel modo seguente:</span><span class="sxs-lookup"><span data-stu-id="58476-206">The XPath expression is evaluated as:</span></span>  
  
```  
CONVERT(float(CONVERT(money, m)) + CONVERT(float(53), 3) = CONVERT(float(53), 3)  
```  
  
 <span data-ttu-id="58476-207">Come illustrato nella tabella seguente, si tratta della stessa conversione applicata per altre espressioni XPath, ad esempio i valori letterali o le espressioni composte.</span><span class="sxs-lookup"><span data-stu-id="58476-207">As shown in the following table, this is the same conversion that is applied for other XPath expressions (such as literals or compound expressions).</span></span>  
  
||||||  
|-|-|-|-|-|  
||<span data-ttu-id="58476-208">X non è noto</span><span class="sxs-lookup"><span data-stu-id="58476-208">X is unknown</span></span>|<span data-ttu-id="58476-209">X è `string`</span><span class="sxs-lookup"><span data-stu-id="58476-209">X is `string`</span></span>|<span data-ttu-id="58476-210">X è `number`</span><span class="sxs-lookup"><span data-stu-id="58476-210">X is `number`</span></span>|<span data-ttu-id="58476-211">X è `boolean`</span><span class="sxs-lookup"><span data-stu-id="58476-211">X is `boolean`</span></span>|  
|<span data-ttu-id="58476-212">string(X)</span><span class="sxs-lookup"><span data-stu-id="58476-212">string(X)</span></span>|<span data-ttu-id="58476-213">CONVERT (nvarchar(4000), X, 126)</span><span class="sxs-lookup"><span data-stu-id="58476-213">CONVERT (nvarchar(4000), X, 126)</span></span>|-|<span data-ttu-id="58476-214">CONVERT (nvarchar(4000), X, 126)</span><span class="sxs-lookup"><span data-stu-id="58476-214">CONVERT (nvarchar(4000), X, 126)</span></span>|<span data-ttu-id="58476-215">CASE WHEN X THEN N'true' ELSE N'false' END</span><span class="sxs-lookup"><span data-stu-id="58476-215">CASE WHEN X THEN N'true' ELSE N'false' END</span></span>|  
|<span data-ttu-id="58476-216">number(X)</span><span class="sxs-lookup"><span data-stu-id="58476-216">number(X)</span></span>|<span data-ttu-id="58476-217">CONVERT (float(53), X)</span><span class="sxs-lookup"><span data-stu-id="58476-217">CONVERT (float(53), X)</span></span>|<span data-ttu-id="58476-218">CONVERT (float(53), X)</span><span class="sxs-lookup"><span data-stu-id="58476-218">CONVERT (float(53), X)</span></span>|-|<span data-ttu-id="58476-219">CASE WHEN X THEN 1 ELSE 0 END</span><span class="sxs-lookup"><span data-stu-id="58476-219">CASE WHEN X THEN 1 ELSE 0 END</span></span>|  
|<span data-ttu-id="58476-220">boolean(X)</span><span class="sxs-lookup"><span data-stu-id="58476-220">boolean(X)</span></span>|-|<span data-ttu-id="58476-221">LEN (X) > 0</span><span class="sxs-lookup"><span data-stu-id="58476-221">LEN(X) > 0</span></span>|<span data-ttu-id="58476-222">X != 0</span><span class="sxs-lookup"><span data-stu-id="58476-222">X != 0</span></span>|-|  
  
## <a name="examples"></a><span data-ttu-id="58476-223">Esempi</span><span class="sxs-lookup"><span data-stu-id="58476-223">Examples</span></span>  
  
### <a name="a-convert-a-data-type-in-an-xpath-query"></a><span data-ttu-id="58476-224">R.</span><span class="sxs-lookup"><span data-stu-id="58476-224">A.</span></span> <span data-ttu-id="58476-225">Convertire un tipo di dati in una query XPath</span><span class="sxs-lookup"><span data-stu-id="58476-225">Convert a data type in an XPath query</span></span>  
 <span data-ttu-id="58476-226">Nella query XPath seguente specificata su uno schema XSD con annotazioni, la query seleziona tutti i nodi **Employee** con il valore dell'attributo **EmployeeID** di E-1, dove "E-" è il prefisso specificato utilizzando l' `sql:id-prefix` annotazione.</span><span class="sxs-lookup"><span data-stu-id="58476-226">In the following XPath query specified against an annotated XSD schema, the query selects all **Employee** nodes with the **EmployeeID** attribute value of E-1, where "E-" is the prefix specified using the `sql:id-prefix` annotation.</span></span>  
  
 `Employee[@EmployeeID="E-1"]`  
  
 <span data-ttu-id="58476-227">Il predicato nella query equivale all'espressione SQL:</span><span class="sxs-lookup"><span data-stu-id="58476-227">The predicate in the query is equivalent to the SQL expression:</span></span>  
  
 `N'E-' + CONVERT(nvarchar(4000), Employees.EmployeeID, 126) = N'E-1'`  
  
 <span data-ttu-id="58476-228">Poiché **EmployeeID** è uno dei `id` valori del `idref` tipo di dati (,, `idrefs` `nmtoken` , `nmtokens` e così via) nello schema XSD, **EmployeeID** viene convertito nel tipo di `string` dati XPath utilizzando le regole di conversione descritte in precedenza.</span><span class="sxs-lookup"><span data-stu-id="58476-228">Because **EmployeeID** is one of the `id` (`idref`, `idrefs`, `nmtoken`, `nmtokens`, and so on) data type values in the XSD schema, **EmployeeID** is converted to the `string` XPath data type using the conversion rules described previously.</span></span>  
  
 `CONVERT(nvarchar(4000), Employees.EmployeeID, 126)`  
  
 <span data-ttu-id="58476-229">Il prefisso "E-" viene aggiunto alla stringa, e il risultato viene quindi confrontato con `N'E-1'`.</span><span class="sxs-lookup"><span data-stu-id="58476-229">The "E-" prefix is added to the string, and the result is then compared with `N'E-1'`.</span></span>  
  
### <a name="b-perform-several-data-type-conversions-in-an-xpath-query"></a><span data-ttu-id="58476-230">B.</span><span class="sxs-lookup"><span data-stu-id="58476-230">B.</span></span> <span data-ttu-id="58476-231">Eseguire diverse conversioni dei tipi di dati in una query XPath</span><span class="sxs-lookup"><span data-stu-id="58476-231">Perform several data type conversions in an XPath query</span></span>  
 <span data-ttu-id="58476-232">Considerare la seguente query XPath specificata su uno schema XSD con annotazioni: `OrderDetail[@UnitPrice * @OrderQty > 98]`</span><span class="sxs-lookup"><span data-stu-id="58476-232">Consider this XPath query specified against an annotated XSD schema: `OrderDetail[@UnitPrice * @OrderQty > 98]`</span></span>  
  
 <span data-ttu-id="58476-233">Questa query XPath restituisce tutti gli **\<OrderDetail>** elementi che soddisfano il predicato `@UnitPrice * @OrderQty > 98` .</span><span class="sxs-lookup"><span data-stu-id="58476-233">This XPath query returns all the **\<OrderDetail>** elements satisfying the predicate `@UnitPrice * @OrderQty > 98`.</span></span> <span data-ttu-id="58476-234">Se **PrezzoUnitario** viene annotato con un `fixed14.4` tipo di dati nello schema con annotazioni, questo predicato è equivalente all'espressione SQL:</span><span class="sxs-lookup"><span data-stu-id="58476-234">If the **UnitPrice** is annotated with a `fixed14.4` data type in the annotated schema, this predicate is equivalent to the SQL expression:</span></span>  
  
 `CONVERT(float(53), CONVERT(money, OrderDetail.UnitPrice)) * CONVERT(float(53), OrderDetail.OrderQty) > CONVERT(float(53), 98)`  
  
 <span data-ttu-id="58476-235">Nel convertire i valori nella query XPath, la prima operazione converte il tipo di dati XDR nel tipo di dati XPath.</span><span class="sxs-lookup"><span data-stu-id="58476-235">In converting the values in the XPath query, the first conversion converts the XDR data type to the XPath data type.</span></span> <span data-ttu-id="58476-236">Poiché il tipo di dati XSD di **PrezzoUnitario** è `fixed14.4` , come descritto nella tabella precedente, si tratta della prima conversione utilizzata:</span><span class="sxs-lookup"><span data-stu-id="58476-236">Because the XSD data type of **UnitPrice** is `fixed14.4`, as described in the previous table, this is the first conversion that is used:</span></span>  
  
```  
CONVERT(money, OrderDetail.UnitPrice))   
```  
  
 <span data-ttu-id="58476-237">Poiché gli operatori aritmetici convertono gli operandi nel tipo di dati XPath `number`, viene applicata la seconda conversione (da un tipo di dati XPath a un altro tipo di dati XPath), in cui il valore viene convertito in `float(53)`. `float(53)` è simile al tipo di dati XPath `number`:</span><span class="sxs-lookup"><span data-stu-id="58476-237">Because the arithmetic operators convert their operands to the `number` XPath data type, the second conversion (from one XPath data type to another XPath data type) is applied in which the value is converted to `float(53)` (`float(53)` is close to the XPath `number` data type):</span></span>  
  
```  
CONVERT(float(53), CONVERT(money, OrderDetail.UnitPrice))   
```  
  
 <span data-ttu-id="58476-238">Supponendo che l'attributo **OrderQty** non disponga di un tipo di dati XSD, **OrderQty** viene convertito in un `number` tipo di dati XPath in una singola conversione:</span><span class="sxs-lookup"><span data-stu-id="58476-238">Assuming the **OrderQty** attribute has no XSD data type, **OrderQty** is converted to a `number` XPath data type in a single conversion:</span></span>  
  
```  
CONVERT(float(53), OrderDetail.OrderQty)  
```  
  
 <span data-ttu-id="58476-239">Analogamente, il valore 98 viene convertito nel tipo di dati XPath `number`:</span><span class="sxs-lookup"><span data-stu-id="58476-239">Similarly, the value 98 is converted to the `number` XPath data type:</span></span>  
  
```  
CONVERT(float(53), 98)  
```  
  
> [!NOTE]  
>  <span data-ttu-id="58476-240">Se il tipo di dati XSD utilizzato nello schema non è compatibile con il tipo di dati di [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] sottostante nel database o se viene eseguita una conversione del tipo di dati XPath non consentita, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] può restituire un errore.</span><span class="sxs-lookup"><span data-stu-id="58476-240">If the XSD data type used in the schema is incompatible with the underlying [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] data type in the database, or if an impossible XPath data type conversion is performed, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] may return an error.</span></span> <span data-ttu-id="58476-241">Se, ad esempio, l'attributo **EmployeeID** viene annotato con `id-prefix` Annotation, XPath `Employee[@EmployeeID=1]` genera un errore, perché **EmployeeID** presenta l' `id-prefix` annotazione e non può essere convertito in `number` .</span><span class="sxs-lookup"><span data-stu-id="58476-241">For example, if the **EmployeeID** attribute is annotated with `id-prefix` annotation, the XPath `Employee[@EmployeeID=1]` generates an error, because **EmployeeID** has the `id-prefix` annotation and cannot be converted to `number`.</span></span>  
  
  
