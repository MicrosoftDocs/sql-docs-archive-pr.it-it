---
title: Utilizzi dei parametri con valori di tabella ODBC | Microsoft Docs
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- table-valued parameters (ODBC), scenarios
- ODBC, table-valued parameters
ms.assetid: f1b73932-4570-4a8a-baa0-0f229d9c32ee
author: rothja
ms.author: jroth
ms.openlocfilehash: 2b128246f7c4ed9a9cec5e28698c743877f9873d
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/04/2020
ms.locfileid: "87724567"
---
# <a name="uses-of-odbc-table-valued-parameters"></a><span data-ttu-id="bafe2-102">Utilizzi dei parametri con valori di tabella in ODBC</span><span class="sxs-lookup"><span data-stu-id="bafe2-102">Uses of ODBC Table-Valued Parameters</span></span>
  <span data-ttu-id="bafe2-103">In questo argomento vengono illustrati gli scenari utente principali relativi all'utilizzo di parametri con valori di tabella in ODBC:</span><span class="sxs-lookup"><span data-stu-id="bafe2-103">This topic discusses the primary user scenarios for using table-valued parameters with ODBC:</span></span>  
  
-   <span data-ttu-id="bafe2-104">Parametro con valori di tabella con buffer a più righe completamente associati (invio di dati come TVP con tutti i valori in memoria)</span><span class="sxs-lookup"><span data-stu-id="bafe2-104">Table-Valued Parameter with Fully Bound Multirow Buffers (Send Data as a TVP with All Values in Memory)</span></span>  
  
-   <span data-ttu-id="bafe2-105">Parametro con valori di tabella con flusso di righe (invio di dati come TVP mediante data-at-execution)</span><span class="sxs-lookup"><span data-stu-id="bafe2-105">Table-Valued Parameter with Row Streaming (Send Data as a TVP Using Data-At-Execution)</span></span>  
  
-   <span data-ttu-id="bafe2-106">Recupero dei metadati del parametro con valori di tabella dal catalogo di sistema</span><span class="sxs-lookup"><span data-stu-id="bafe2-106">Retrieving Table-Valued Parameter Metadata from the System Catalog</span></span>  
  
-   <span data-ttu-id="bafe2-107">Recupero di metadati del parametro con valori di tabella per un'istruzione preparata</span><span class="sxs-lookup"><span data-stu-id="bafe2-107">Retrieving Table-Valued Parameter Metadata for a Prepared Statement</span></span>  
  
## <a name="table-valued-parameter-with-fully-bound-multirow-buffers-send-data-as-a-tvp-with-all-values-in-memory"></a><span data-ttu-id="bafe2-108">Parametro con valori di tabella con buffer a più righe completamente associati (invio di dati come TVP con tutti i valori in memoria)</span><span class="sxs-lookup"><span data-stu-id="bafe2-108">Table-Valued Parameter with Fully Bound Multirow Buffers (Send Data as a TVP with All Values in Memory)</span></span>  
 <span data-ttu-id="bafe2-109">Se utilizzato con buffer a più righe completamente associati, tutti i valori del parametro sono disponibili in memoria.</span><span class="sxs-lookup"><span data-stu-id="bafe2-109">When used with fully bound multirow buffers, all parameter values are available in memory.</span></span> <span data-ttu-id="bafe2-110">È tipico, ad esempio, di una transazione OLTP nella quale i parametri con valori di tabella possono essere assemblati in una singola stored procedure.</span><span class="sxs-lookup"><span data-stu-id="bafe2-110">This is typical, for example, of an OLTP transaction, in which table-valued parameters can be packaged into a single stored procedure.</span></span> <span data-ttu-id="bafe2-111">Senza parametri con valori di tabella, risulta necessario generare dinamicamente un batch complesso con più istruzioni o effettuare più chiamate al server.</span><span class="sxs-lookup"><span data-stu-id="bafe2-111">Without table-valued parameters, this would involve either generating a complex multi-statement batch dynamically, or making multiple calls to the server.</span></span>  
  
 <span data-ttu-id="bafe2-112">Il parametro con valori di tabella viene associato utilizzando [SQLBindParameter](https://go.microsoft.com/fwlink/?LinkId=59328) insieme agli altri parametri.</span><span class="sxs-lookup"><span data-stu-id="bafe2-112">The table-valued parameter itself is bound by using [SQLBindParameter](https://go.microsoft.com/fwlink/?LinkId=59328) along with the other parameters.</span></span> <span data-ttu-id="bafe2-113">Dopo aver associato tutti i parametri, l'applicazione imposta l'attributo Focus del parametro, SQL_SOPT_SS_PARAM_FOCUS, su ogni parametro con valori di tabella e chiama SQLBindParameter per le colonne del parametro con valori di tabella.</span><span class="sxs-lookup"><span data-stu-id="bafe2-113">After all parameters have been bound, the application sets the parameter focus attribute, SQL_SOPT_SS_PARAM_FOCUS, on each table-valued parameter and calls SQLBindParameter for the columns of the table-valued parameter.</span></span>  
  
 <span data-ttu-id="bafe2-114">Il tipo di server per un parametro con valori di tabella è un nuovo tipo specifico per [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], SQL_SS_TABLE.</span><span class="sxs-lookup"><span data-stu-id="bafe2-114">The server type for a table-valued parameter is a new [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]-specific type, SQL_SS_TABLE.</span></span> <span data-ttu-id="bafe2-115">Il tipo C dell'associazione per SQL_SS_TABLE deve essere sempre SQL_C_DEFAULT.</span><span class="sxs-lookup"><span data-stu-id="bafe2-115">The binding C type for SQL_SS_TABLE must always be SQL_C_DEFAULT.</span></span> <span data-ttu-id="bafe2-116">Non vengono trasferiti dati per il parametro associato al parametro con valori di tabella; viene utilizzato per passare i metadati delle tabelle e per controllare il modo in cui passare i dati nelle colonne che costituiscono il parametro con valori di tabella.</span><span class="sxs-lookup"><span data-stu-id="bafe2-116">No data is transferred for the table-valued parameter bound parameter; it is used to pass table metadata and to control how to pass data in the constituent columns of the table-valued parameter.</span></span>  
  
 <span data-ttu-id="bafe2-117">La lunghezza del parametro con valori di tabella è impostata sul numero di righe inviate al server.</span><span class="sxs-lookup"><span data-stu-id="bafe2-117">The length of the table-valued parameter is set to the number of rows being sent to the server.</span></span> <span data-ttu-id="bafe2-118">Il parametro *ColumnSize* di SQLBindParameter per un parametro con valori di tabella specifica il numero massimo di righe che è possibile inviare. si tratta della dimensione della matrice dei buffer delle colonne.</span><span class="sxs-lookup"><span data-stu-id="bafe2-118">The *ColumnSize* parameter of SQLBindParameter for a table-valued parameter specifies the maximum number of rows that can be sent; this is the array size of the column buffers.</span></span> <span data-ttu-id="bafe2-119">*ParameterValuePtr* è il buffer del parametro, per un parametro con valori di tabella in SQLBindParameter.</span><span class="sxs-lookup"><span data-stu-id="bafe2-119">*ParameterValuePtr* is the parameter buffer,for a table-valued parameter in SQLBindParameter.</span></span> <span data-ttu-id="bafe2-120">*ParameterValuePtr* e i *bufferLength* associati vengono utilizzati per passare il nome del tipo del parametro con valori di tabella quando necessario.</span><span class="sxs-lookup"><span data-stu-id="bafe2-120">*ParameterValuePtr* and its associated *BufferLength* are used to pass the type name of the table-valued parameter when required.</span></span> <span data-ttu-id="bafe2-121">Il nome del tipo non è necessario per le chiamate alle stored procedure, mentre è necessario per le istruzioni SQL.</span><span class="sxs-lookup"><span data-stu-id="bafe2-121">The type name is not required for stored procedure calls, but it is required for SQL statements.</span></span>  
  
 <span data-ttu-id="bafe2-122">Quando un nome di tipo di parametro con valori di tabella viene specificato in una chiamata a SQLBindParameter, deve sempre essere specificato come valore Unicode, anche nelle applicazioni compilate come applicazioni ANSI.</span><span class="sxs-lookup"><span data-stu-id="bafe2-122">When a table-valued parameter type name is specified on a call to SQLBindParameter, it must always be specified as a Unicode value, even in applications that are built as ANSI applications.</span></span> <span data-ttu-id="bafe2-123">Quando si specifica un nome di tipo di parametro con valori di tabella tramite SQLSetDescField, è possibile utilizzare un valore letterale conforme al modo in cui viene compilata l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="bafe2-123">When you specify a table-valued parameter type name by using SQLSetDescField, you can use a literal that conforms to the way the application is built.</span></span> <span data-ttu-id="bafe2-124">In Gestione driver ODBC verrà eseguita la conversione Unicode necessaria.</span><span class="sxs-lookup"><span data-stu-id="bafe2-124">The ODBC Driver Manager will perform any required Unicode conversion.</span></span>  
  
 <span data-ttu-id="bafe2-125">I metadati per i parametri con valori di tabella e le colonne di parametri con valori di tabella possono essere modificati singolarmente e in modo esplicito tramite SQLGetDescRec, SQLSetDescRec, SQLGetDescField e SQLSetDescField.</span><span class="sxs-lookup"><span data-stu-id="bafe2-125">Metadata for table-valued parameters and table-valued parameter columns can be manipulated individually and explicitly by using SQLGetDescRec, SQLSetDescRec, SQLGetDescField, and SQLSetDescField.</span></span> <span data-ttu-id="bafe2-126">Tuttavia, l'overload di SQLBindParameter è in genere più pratico e non richiede l'accesso esplicito al descrittore nella maggior parte dei casi.</span><span class="sxs-lookup"><span data-stu-id="bafe2-126">However, overloading SQLBindParameter is usually more convenient and does not require explicit descriptor access in most cases.</span></span> <span data-ttu-id="bafe2-127">Questo approccio è coerente con la definizione di SQLBindParameter per altri tipi di dati, ad eccezione del fatto che per un parametro con valori di tabella i campi dei descrittori interessati sono leggermente diversi.</span><span class="sxs-lookup"><span data-stu-id="bafe2-127">This approach is consistent with the definition of SQLBindParameter for other data types, except that for a table-valued parameter the affected descriptor fields are slightly different.</span></span>  
  
 <span data-ttu-id="bafe2-128">Un'applicazione utilizza talvolta un parametro con valori di tabella con le istruzioni SQL dinamiche ed è necessario fornire il nome del tipo del parametro con valori di tabella.</span><span class="sxs-lookup"><span data-stu-id="bafe2-128">Sometimes, an application uses a table-valued parameter with dynamic SQL and the type name of the table-valued parameter must be supplied.</span></span> <span data-ttu-id="bafe2-129">In tal caso e se il parametro con valori di tabella non è definito nello schema predefinito corrente per la connessione, è necessario impostare SQL_CA_SS_TYPE_CATALOG_NAME e SQL_CA_SS_TYPE_SCHEMA_NAME utilizzando SQLSetDescField.</span><span class="sxs-lookup"><span data-stu-id="bafe2-129">If this is the case and the table-valued parameter is not defined in the current default schema for the connection, SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME must be set by using SQLSetDescField.</span></span> <span data-ttu-id="bafe2-130">Poiché le definizioni del tipo di tabella e i parametri con valori di tabella devono risiedere nello stesso database, SQL_CA_SS_TYPE_CATALOG_NAME non deve essere impostato se l'applicazione utilizza parametri con valori di tabella.</span><span class="sxs-lookup"><span data-stu-id="bafe2-130">Because table type definitions and table-valued parameters must be in the same database, SQL_CA_SS_TYPE_CATALOG_NAME must not be set if the application uses table-valued parameters.</span></span> <span data-ttu-id="bafe2-131">In caso contrario, SQLSetDescField segnalerà un errore.</span><span class="sxs-lookup"><span data-stu-id="bafe2-131">Otherwise, SQLSetDescField will report an error.</span></span>  
  
 <span data-ttu-id="bafe2-132">Il codice di esempio per questo scenario è nella procedura descritta `demo_fixed_TVP_binding` in [usare i parametri con valori di tabella &#40;&#41;ODBC ](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span><span class="sxs-lookup"><span data-stu-id="bafe2-132">Sample code for this scenario is in the procedure `demo_fixed_TVP_binding` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="table-valued-parameter-with-row-streaming-send-data-as-a-tvp-using-data-at-execution"></a><span data-ttu-id="bafe2-133">Parametro con valori di tabella con flusso di righe (invio di dati come TVP mediante data-at-execution)</span><span class="sxs-lookup"><span data-stu-id="bafe2-133">Table-Valued Parameter with Row Streaming (Send Data as a TVP Using Data-At-Execution)</span></span>  
 <span data-ttu-id="bafe2-134">In questo scenario l'applicazione fornisce le righe al driver nel modo in cui vengono richieste, le quali vengono poi trasferite al server.</span><span class="sxs-lookup"><span data-stu-id="bafe2-134">In this scenario, the application supplies rows to the driver as it requests them and they are streamed to the server.</span></span> <span data-ttu-id="bafe2-135">In questo modo si evita di dovere memorizzare tutte le righe nel buffer di memoria.</span><span class="sxs-lookup"><span data-stu-id="bafe2-135">This avoids having to buffer all rows in memory.</span></span> <span data-ttu-id="bafe2-136">Tale condizione è rappresentativa negli scenari di inserimento/aggiornamento bulk.</span><span class="sxs-lookup"><span data-stu-id="bafe2-136">This is representative of bulk insert/update scenarios.</span></span> <span data-ttu-id="bafe2-137">Le prestazioni dei parametri con valori di tabella sono a metà tra le matrici di parametri e la copia bulk.</span><span class="sxs-lookup"><span data-stu-id="bafe2-137">Table-valued parameters provide a performance point somewhere between parameter arrays and bulk copy.</span></span> <span data-ttu-id="bafe2-138">La programmazione dei parametri con valori di tabella è semplice quanto quella delle matrici di parametri, ma offre una maggiore flessibilità sul lato server.</span><span class="sxs-lookup"><span data-stu-id="bafe2-138">That is, table-valued parameters are about as easy to program as parameter arrays, but they provide greater flexibility at the server.</span></span>  
  
 <span data-ttu-id="bafe2-139">Il parametro con valori di tabella e le relative colonne vengono associate come descritto nella sezione precedente, Parametro con valori di tabella con buffer a più righe completamente associati, impostando però l'indicatore della lunghezza del parametro con valori di tabella su SQL_DATA_AT_EXEC.</span><span class="sxs-lookup"><span data-stu-id="bafe2-139">The table-valued parameter and its columns are bound as discussed in the previous section, Table-Valued Parameter with Fully Bound Multirow Buffers, but the length indicator of the table-valued parameter itself is set to SQL_DATA_AT_EXEC.</span></span> <span data-ttu-id="bafe2-140">Il driver risponde a SQLExecute o SQLExecuteDirect nel modo consueto per i parametri data-at-execution, ovvero restituendo SQL_NEED_DATA.</span><span class="sxs-lookup"><span data-stu-id="bafe2-140">The driver responds to SQLExecute or SQLExecuteDirect in the usual way for data-at-execution parameters-that is, by returning SQL_NEED_DATA.</span></span> <span data-ttu-id="bafe2-141">Quando il driver è pronto ad accettare i dati per un parametro con valori di tabella, SQLParamData restituisce il valore di *ParameterValuePtr* in SQLBindParameter.</span><span class="sxs-lookup"><span data-stu-id="bafe2-141">When the driver is ready to accept data for a table-valued parameter, SQLParamData returns the value of *ParameterValuePtr* in SQLBindParameter.</span></span>  
  
 <span data-ttu-id="bafe2-142">Un'applicazione utilizza SQLPutData per un parametro con valori di tabella per indicare la disponibilità dei dati per le colonne che costituiscono il parametro con valori di tabella.</span><span class="sxs-lookup"><span data-stu-id="bafe2-142">An application uses SQLPutData for a table-valued parameter to indicate the availability of data for table-valued parameter constituent columns.</span></span> <span data-ttu-id="bafe2-143">Quando SQLPutData viene chiamato per un parametro con valori di tabella, *DataPtr* deve sempre essere null e *StrLen_Or_Ind* deve essere 0 o un numero minore o uguale alla dimensione della matrice specificata per i buffer dei parametri con valori di tabella (il parametro *ColumnSize* di SQLBindParameter).</span><span class="sxs-lookup"><span data-stu-id="bafe2-143">When SQLPutData is called for a table-valued parameter, *DataPtr* must always be null and *StrLen_or_Ind* must be either 0 or a number less than or equal to the array size specified for table-valued parameter buffers (the *ColumnSize* parameter of SQLBindParameter).</span></span> <span data-ttu-id="bafe2-144">0 significa che non ci sono più righe per il parametro con valori di tabella e il driver procederà con l'elaborazione fino al successivo parametro effettivo della procedura.</span><span class="sxs-lookup"><span data-stu-id="bafe2-144">0 signifies that there are no more rows for the table-valued parameter, and the driver will proceed to process to the next actual procedure parameter.</span></span> <span data-ttu-id="bafe2-145">Quando *StrLen_Or_Ind* non è 0, il driver elaborerà le colonne che costituiscono il parametro con valori di tabella nello stesso modo dei parametri associati ai parametri non con valori di tabella: ogni colonna di parametri con valori di tabella può specificare la lunghezza effettiva dei dati, SQL_NULL_DATA o specificare i dati in fase di esecuzione tramite il buffer di lunghezza/indicatore.</span><span class="sxs-lookup"><span data-stu-id="bafe2-145">When *StrLen_or_Ind* is not 0, the driver will process the table-valued parameter constituent columns in the same way as non-table-valued parameter bound parameters: Each table-valued parameter column can specify its actual data length, SQL_NULL_DATA, or it can specify data at execution via its length/indicator buffer.</span></span> <span data-ttu-id="bafe2-146">I valori delle colonne dei parametri con valori di tabella possono essere passati da chiamate ripetute a SQLPutData come di consueto quando un valore binario o carattere deve essere passato in parti.</span><span class="sxs-lookup"><span data-stu-id="bafe2-146">Table-valued parameter column values can be passed by repeated calls to SQLPutData as usual when a character or binary value is to be passed in pieces.</span></span>  
  
 <span data-ttu-id="bafe2-147">Una volta elaborate tutte le colonne del parametro con valori di tabella, il driver torna al parametro con valori di tabella per elaborare ulteriori righe di dati del parametro con valori di tabella.</span><span class="sxs-lookup"><span data-stu-id="bafe2-147">When all table-valued parameter columns have been processed, the driver returns to the table-valued parameter to process further rows of table-valued parameter data.</span></span> <span data-ttu-id="bafe2-148">Pertanto, per i parametri con valori di tabella data-at-execution il driver non segue la solita analisi sequenziale dei parametri associati.</span><span class="sxs-lookup"><span data-stu-id="bafe2-148">Therefore, for data-at-execution table-valued parameters, the driver does not follow the usual sequential scan of bound parameters.</span></span> <span data-ttu-id="bafe2-149">Verrà eseguito il polling di un parametro con valori di tabella associato fino a quando non viene chiamato SQLPutData con *StrLen_or_IndPtr* uguale a 0, a quel punto il driver ignora le colonne dei parametri con valori di tabella e passa al parametro stored procedure effettivo successivo.</span><span class="sxs-lookup"><span data-stu-id="bafe2-149">A bound table-valued parameter will be polled until SQLPutData is called with *StrLen_Or_IndPtr* equal to 0, at which time the driver skips table-valued parameter columns and moves to the next actual stored procedure parameter.</span></span>  <span data-ttu-id="bafe2-150">Quando SQLPutData passa un valore indicatore maggiore o uguale a 1, il driver elabora le righe e le colonne dei parametri con valori di tabella in modo sequenziale fino a quando non contiene valori per tutte le righe e le colonne.</span><span class="sxs-lookup"><span data-stu-id="bafe2-150">When SQLPutData passes an indicator value greater than or equal to 1, the driver processes table-valued parameter columns and rows sequentially until it has values for all bound rows and columns.</span></span> <span data-ttu-id="bafe2-151">Dopodiché il driver torna al parametro con valori di tabella.</span><span class="sxs-lookup"><span data-stu-id="bafe2-151">Then the driver returns to the table-valued parameter.</span></span> <span data-ttu-id="bafe2-152">Tra la ricezione del token per il parametro con valori di tabella da SQLParamData e la chiamata di SQLPutData (hstmt, NULL, n) per un parametro con valori di tabella, l'applicazione deve impostare i dati delle colonne che costituiscono il parametro con valori di tabella e il contenuto del buffer dell'indicatore per la riga o le righe successive da passare al server.</span><span class="sxs-lookup"><span data-stu-id="bafe2-152">Between receiving the token for the table-valued parameter from SQLParamData and calling SQLPutData(hstmt, NULL, n) for a table-valued parameter, the application must set table-valued parameter constituent column data and indicator buffer contents for the next row or rows to be passed to the server.</span></span>  
  
 <span data-ttu-id="bafe2-153">Il codice di esempio per questo scenario è nella routine `demo_variable_TVP_binding` in [usare i parametri con valori di tabella &#40;&#41;ODBC ](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span><span class="sxs-lookup"><span data-stu-id="bafe2-153">Sample code for this scenario is in the routine `demo_variable_TVP_binding` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="retrieving-table-valued-parameter-metadata-from-the-system-catalog"></a><span data-ttu-id="bafe2-154">Recupero dei metadati del parametro con valori di tabella dal catalogo di sistema</span><span class="sxs-lookup"><span data-stu-id="bafe2-154">Retrieving Table-Valued Parameter Metadata from the System Catalog</span></span>  
 <span data-ttu-id="bafe2-155">Quando un'applicazione chiama SQLProcedureColumns per una procedura con parametri di parametro con valori di tabella, DATA_TYPE viene restituito come SQL_SS_TABLE e TYPE_NAME è il nome del tipo di tabella per il parametro con valori di tabella.</span><span class="sxs-lookup"><span data-stu-id="bafe2-155">When an application calls SQLProcedureColumns for a procedure that has table-valued parameter parameters, DATA_TYPE is returned as SQL_SS_TABLE and TYPE_NAME is the name of the table type for the table-valued parameter.</span></span> <span data-ttu-id="bafe2-156">Al set di risultati restituito da SQLProcedureColumns vengono aggiunte due colonne aggiuntive: SS_TYPE_CATALOG_NAME restituisce il nome del catalogo in cui è definito il tipo di tabella del parametro con valori di tabella e SS_TYPE_SCHEMA_NAME restituisce il nome dello schema in cui è definito il tipo di tabella del parametro con valori di tabella.</span><span class="sxs-lookup"><span data-stu-id="bafe2-156">Two additional columns are added to the result set returned by SQLProcedureColumns: SS_TYPE_CATALOG_NAME returns the name of the catalog where the table type of the table-value parameter is defined, and SS_TYPE_SCHEMA_NAME returns the name of the schema where the where the table type of the table-value parameter is defined.</span></span> <span data-ttu-id="bafe2-157">In conformità con la specifica ODBC, SS_TYPE_CATALOG_NAME e SS_TYPE_SCHEMA_NAME vengono visualizzati prima di tutte le colonne specifiche del driver che sono state aggiunte nelle versioni precedenti di [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] e dopo tutte le colonne richieste da ODBC stesso.</span><span class="sxs-lookup"><span data-stu-id="bafe2-157">In conformance with the ODBC specification, SS_TYPE_CATALOG_NAME and SS_TYPE_SCHEMA_NAME appear before all driver specific columns that were added in previous versions of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], and after all columns mandated by ODBC itself.</span></span>  
  
 <span data-ttu-id="bafe2-158">Le nuove colonne verranno popolate non solo per i parametri con valori di tabella, ma anche per i parametri del tipo CLR definito dall'utente.</span><span class="sxs-lookup"><span data-stu-id="bafe2-158">The new columns will be populated not only for table-valued parameters, but also for CLR user-defined type parameters.</span></span> <span data-ttu-id="bafe2-159">Le colonne esistenti dello schema e del catalogo dei parametri UDT verranno ancora popolate, ma la disponibilità di colonne comuni per lo schema e il catalogo da utilizzare per i tipi di dati semplificherà in futuro lo sviluppo di applicazioni.</span><span class="sxs-lookup"><span data-stu-id="bafe2-159">The existing schema and catalog columns of UDT parameters will still be populated, but having common schema and catalog columns for data types that require them will simplify application development in the future.</span></span> <span data-ttu-id="bafe2-160">Notare che le raccolte di XML Schema sono piuttosto diverse e non sono incluse in questa modifica.</span><span class="sxs-lookup"><span data-stu-id="bafe2-160">(Note that XML schema collections are somewhat different and are not included in this change.)</span></span>  
  
 <span data-ttu-id="bafe2-161">Un'applicazione utilizza SQLTables per determinare i nomi dei tipi di tabella esattamente come avviene per le tabelle, le tabelle di sistema e le viste permanenti.</span><span class="sxs-lookup"><span data-stu-id="bafe2-161">An application uses SQLTables to determine the names of table types the same way it does for persistent tables, system tables, and views.</span></span> <span data-ttu-id="bafe2-162">Viene introdotto un nuovo tipo di tabella, TABLE TYPE, per consentire a un'applicazione di identificare i tipi di tabella associati ai parametri con valori di tabella.</span><span class="sxs-lookup"><span data-stu-id="bafe2-162">A new table type, TABLE TYPE, is introduced to enable an application to identify table types associated with table-valued parameters.</span></span> <span data-ttu-id="bafe2-163">I tipi di tabella e le tabelle normali utilizzano spazi dei nomi diversi.</span><span class="sxs-lookup"><span data-stu-id="bafe2-163">Table types and regular tables use different namespaces.</span></span> <span data-ttu-id="bafe2-164">È pertanto possibile utilizzare lo stesso nome per un tipo di tabella e una tabella effettiva.</span><span class="sxs-lookup"><span data-stu-id="bafe2-164">This means that you can use the same name for both a table type and an actual table.</span></span> <span data-ttu-id="bafe2-165">A tale scopo è stato introdotto un nuovo attributo dell'istruzione, SQL_SOPT_SS_NAME_SCOPE.</span><span class="sxs-lookup"><span data-stu-id="bafe2-165">To handle this, a new statement attribute, SQL_SOPT_SS_NAME_SCOPE, has been introduced.</span></span> <span data-ttu-id="bafe2-166">Questo attributo specifica se SQLTables e altre funzioni di catalogo che accettano un nome di tabella come parametro devono interpretare il nome della tabella come nome di una tabella effettiva o il nome di un tipo di tabella.</span><span class="sxs-lookup"><span data-stu-id="bafe2-166">This attribute specifies whether SQLTables and other catalog functions that take a table name as a parameter should interpret the table name as the name of an actual table or the name of a table type.</span></span>  
  
 <span data-ttu-id="bafe2-167">Un'applicazione usa SQLColumns per determinare le colonne per un tipo di tabella nello stesso modo in cui avviene per le tabelle permanenti, ma è necessario prima impostare SQL_SOPT_SS_NAME_SCOPE per indicare che è in uso con i tipi di tabella anziché con le tabelle effettive.</span><span class="sxs-lookup"><span data-stu-id="bafe2-167">An application uses SQLColumns to determine the columns for a table type in the same way it does for persistent tables, but must first set SQL_SOPT_SS_NAME_SCOPE to indicate that it is working with table types rather than actual tables.</span></span> <span data-ttu-id="bafe2-168">SQLPrimaryKeys può essere usato anche con i tipi di tabella, usando di nuovo SQL_SOPT_SS_NAME_SCOPE.</span><span class="sxs-lookup"><span data-stu-id="bafe2-168">SQLPrimaryKeys can also be used with table types, again using SQL_SOPT_SS_NAME_SCOPE.</span></span>  
  
 <span data-ttu-id="bafe2-169">Il codice di esempio per questo scenario è nella routine `demo_metadata_from_catalog_APIs` in [usare i parametri con valori di tabella &#40;&#41;ODBC ](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span><span class="sxs-lookup"><span data-stu-id="bafe2-169">Sample code for this scenario is in the routine `demo_metadata_from_catalog_APIs` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="retrieving-table-valued-parameter-metadata-for-a-prepared-statement"></a><span data-ttu-id="bafe2-170">Recupero di metadati del parametro con valori di tabella per un'istruzione preparata</span><span class="sxs-lookup"><span data-stu-id="bafe2-170">Retrieving Table-Valued Parameter Metadata for a Prepared Statement</span></span>  
 <span data-ttu-id="bafe2-171">In questo scenario, un'applicazione utilizza SQLNumParameters e SQLDescribeParam per recuperare i metadati per i parametri con valori di tabella.</span><span class="sxs-lookup"><span data-stu-id="bafe2-171">In this scenario, an application uses SQLNumParameters and SQLDescribeParam to retrieve metadata for table-valued parameters.</span></span>  
  
 <span data-ttu-id="bafe2-172">Il campo IPD SQL_CA_SS_TYPE_NAME viene utilizzato per recuperare il nome del tipo per il parametro con valori di tabella.</span><span class="sxs-lookup"><span data-stu-id="bafe2-172">The IPD field SQL_CA_SS_TYPE_NAME is used to retrieve the type name for the table-valued parameter.</span></span> <span data-ttu-id="bafe2-173">I campi IPD SQL_CA_SS_TYPE_SCHEMA_NAME e SQL_CA_SS_TYPE_CATALOG_NAME vengono utilizzati per recuperare rispettivamente il catalogo e lo schema.</span><span class="sxs-lookup"><span data-stu-id="bafe2-173">The IPD fields SQL_CA_SS_TYPE_SCHEMA_NAME and SQL_CA_SS_TYPE_CATALOG_NAME are used to retrieve its catalog and schema, respectively.</span></span>  
  
 <span data-ttu-id="bafe2-174">Le definizioni del tipo di tabella e i parametri con valori di tabella devono essere nello stesso database.</span><span class="sxs-lookup"><span data-stu-id="bafe2-174">Table type definitions and table-valued parameters must be in the same database.</span></span> <span data-ttu-id="bafe2-175">SQLSetDescField segnala un errore se un'applicazione imposta SQL_CA_SS_TYPE_CATALOG_NAME quando si utilizzano parametri con valori di tabella.</span><span class="sxs-lookup"><span data-stu-id="bafe2-175">SQLSetDescField will report an error if an application sets SQL_CA_SS_TYPE_CATALOG_NAME when using table-valued parameters.</span></span>  
  
 <span data-ttu-id="bafe2-176">SQL_CA_SS_TYPE_CATALOG_NAME e SQL_CA_SS_TYPE_SCHEMA_NAME possono inoltre essere utilizzati per recuperare il catalogo e lo schema associati ai parametri del tipo CLR definito dall'utente.</span><span class="sxs-lookup"><span data-stu-id="bafe2-176">SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME can also be used to retrieve the catalog and schema associated with CLR user-defined type parameters.</span></span> <span data-ttu-id="bafe2-177">SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME sono le alternative agli attributi esistenti specifici del tipo per il catalogo e lo schema per i tipi CLR UDT.</span><span class="sxs-lookup"><span data-stu-id="bafe2-177">SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME are alternatives to the existing type specific catalog schema attributes for CLR UDT types.</span></span>  
  
 <span data-ttu-id="bafe2-178">In questo scenario, un'applicazione utilizza SQLColumns per recuperare i metadati della colonna per un parametro con valori di tabella, poiché SQLDescribeParam non restituisce metadati per le colonne di una colonna di parametri con valori di tabella.</span><span class="sxs-lookup"><span data-stu-id="bafe2-178">An application uses SQLColumns to retrieve column metadata for a table-valued parameter in this scenario, too, because SQLDescribeParam does not return metadata for the columns of a table-valued parameter column.</span></span>  
  
 <span data-ttu-id="bafe2-179">Il codice di esempio per questo caso di utilizzo è nella routine `demo_metadata_from_prepared_statement` in [utilizzare i parametri con valori di tabella &#40;&#41;ODBC ](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span><span class="sxs-lookup"><span data-stu-id="bafe2-179">Sample code for this use case is in the routine `demo_metadata_from_prepared_statement` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="bafe2-180">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="bafe2-180">See Also</span></span>  
 [<span data-ttu-id="bafe2-181">Parametri con valori di tabella &#40;&#41;ODBC</span><span class="sxs-lookup"><span data-stu-id="bafe2-181">Table-Valued Parameters &#40;ODBC&#41;</span></span>](table-valued-parameters-odbc.md)  
  
  
